{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection'; // We want to cache detection since the framework won't change\n\nvar frameworkCache;\nexport var frameworkChangeObservers = []; // Setup the detection reset tracking / timeout delays\n\nvar resetTriggered = false;\nvar SSR_RESET_TIMEOUT = 10; // ms\n\nvar WEB_RESET_TIMEOUT = 10; // ms\n\nvar PRIME_FRAMEWORK_DELAY = 1000; // ms\n\nexport var detectFramework = function () {\n  if (!frameworkCache) {\n    frameworkCache = detect();\n\n    if (resetTriggered) {\n      // The final run of detectFramework:\n      // Starting from this point, the `frameworkCache` becomes \"final\".\n      // So we don't need to notify the observers again so the observer\n      // can be removed after the final notice.\n      while (frameworkChangeObservers.length) {\n        frameworkChangeObservers.pop()();\n      }\n    } else {\n      // The first run of detectFramework:\n      // Every time we update the cache, call each observer function\n      frameworkChangeObservers.forEach(function (fcn) {\n        return fcn();\n      });\n    } // Retry once for either Unknown type after a delay (explained below)\n\n\n    resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n    resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n  }\n\n  return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\n\nexport var observeFrameworkChanges = function (fcn) {\n  // When the `frameworkCache` won't be updated again, we ignore all incoming\n  // observers.\n  if (resetTriggered) {\n    return;\n  }\n\n  frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n  frameworkCache = undefined;\n} // For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\n\nfunction resetTimeout(framework, delay) {\n  if (frameworkCache === framework && !resetTriggered) {\n    setTimeout(function () {\n      clearCache();\n      resetTriggered = true;\n      setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n    }, delay);\n  }\n}","map":{"version":3,"names":["Framework","detect","frameworkCache","frameworkChangeObservers","resetTriggered","SSR_RESET_TIMEOUT","WEB_RESET_TIMEOUT","PRIME_FRAMEWORK_DELAY","detectFramework","length","pop","forEach","fcn","resetTimeout","ServerSideUnknown","WebUnknown","observeFrameworkChanges","push","clearCache","undefined","framework","delay","setTimeout"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/core/lib-esm/Platform/detectFramework.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nvar frameworkCache;\nexport var frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nvar resetTriggered = false;\nvar SSR_RESET_TIMEOUT = 10; // ms\nvar WEB_RESET_TIMEOUT = 10; // ms\nvar PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport var detectFramework = function () {\n    if (!frameworkCache) {\n        frameworkCache = detect();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (frameworkChangeObservers.length) {\n                frameworkChangeObservers.pop()();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            frameworkChangeObservers.forEach(function (fcn) { return fcn(); });\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport var observeFrameworkChanges = function (fcn) {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(function () {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,SAAT,QAA0B,SAA1B;AACA,SAASC,MAAT,QAAuB,aAAvB,C,CACA;;AACA,IAAIC,cAAJ;AACA,OAAO,IAAIC,wBAAwB,GAAG,EAA/B,C,CACP;;AACA,IAAIC,cAAc,GAAG,KAArB;AACA,IAAIC,iBAAiB,GAAG,EAAxB,C,CAA4B;;AAC5B,IAAIC,iBAAiB,GAAG,EAAxB,C,CAA4B;;AAC5B,IAAIC,qBAAqB,GAAG,IAA5B,C,CAAkC;;AAClC,OAAO,IAAIC,eAAe,GAAG,YAAY;EACrC,IAAI,CAACN,cAAL,EAAqB;IACjBA,cAAc,GAAGD,MAAM,EAAvB;;IACA,IAAIG,cAAJ,EAAoB;MAChB;MACA;MACA;MACA;MACA,OAAOD,wBAAwB,CAACM,MAAhC,EAAwC;QACpCN,wBAAwB,CAACO,GAAzB;MACH;IACJ,CARD,MASK;MACD;MACA;MACAP,wBAAwB,CAACQ,OAAzB,CAAiC,UAAUC,GAAV,EAAe;QAAE,OAAOA,GAAG,EAAV;MAAe,CAAjE;IACH,CAfgB,CAgBjB;;;IACAC,YAAY,CAACb,SAAS,CAACc,iBAAX,EAA8BT,iBAA9B,CAAZ;IACAQ,YAAY,CAACb,SAAS,CAACe,UAAX,EAAuBT,iBAAvB,CAAZ;EACH;;EACD,OAAOJ,cAAP;AACH,CAtBM;AAuBP;AACA;AACA;;AACA,OAAO,IAAIc,uBAAuB,GAAG,UAAUJ,GAAV,EAAe;EAChD;EACA;EACA,IAAIR,cAAJ,EAAoB;IAChB;EACH;;EACDD,wBAAwB,CAACc,IAAzB,CAA8BL,GAA9B;AACH,CAPM;AAQP,OAAO,SAASM,UAAT,GAAsB;EACzBhB,cAAc,GAAGiB,SAAjB;AACH,C,CACD;AACA;AACA;AACA;AACA;AACA;;AACA,SAASN,YAAT,CAAsBO,SAAtB,EAAiCC,KAAjC,EAAwC;EACpC,IAAInB,cAAc,KAAKkB,SAAnB,IAAgC,CAAChB,cAArC,EAAqD;IACjDkB,UAAU,CAAC,YAAY;MACnBJ,UAAU;MACVd,cAAc,GAAG,IAAjB;MACAkB,UAAU,CAACd,eAAD,EAAkBD,qBAAlB,CAAV;IACH,CAJS,EAIPc,KAJO,CAAV;EAKH;AACJ"},"metadata":{},"sourceType":"module"}