{"ast":null,"code":"import _asyncToGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttempts) {\n    this.maxAttempts = maxAttempts;\n    this.mode = RETRY_MODES.STANDARD;\n    this.capacity = INITIAL_RETRY_TOKENS;\n    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n    this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : /*#__PURE__*/_asyncToGenerator(function* () {\n      return maxAttempts;\n    });\n  }\n\n  acquireInitialRetryToken(retryTokenScope) {\n    return _asyncToGenerator(function* () {\n      return createDefaultRetryToken({\n        retryDelay: DEFAULT_RETRY_DELAY_BASE,\n        retryCount: 0\n      });\n    })();\n  }\n\n  refreshRetryTokenForRetry(token, errorInfo) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const maxAttempts = yield _this.getMaxAttempts();\n\n      if (_this.shouldRetry(token, errorInfo, maxAttempts)) {\n        const errorType = errorInfo.errorType;\n\n        _this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n\n        const delayFromErrorType = _this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n\n        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;\n\n        const capacityCost = _this.getCapacityCost(errorType);\n\n        _this.capacity -= capacityCost;\n        return createDefaultRetryToken({\n          retryDelay,\n          retryCount: token.getRetryCount() + 1,\n          retryCost: capacityCost\n        });\n      }\n\n      throw new Error(\"No retry token available\");\n    })();\n  }\n\n  recordSuccess(token) {\n    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n  }\n\n  getCapacity() {\n    return this.capacity;\n  }\n\n  getMaxAttempts() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        return yield _this2.maxAttemptsProvider();\n      } catch (error) {\n        console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n        return DEFAULT_MAX_ATTEMPTS;\n      }\n    })();\n  }\n\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount();\n    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n\n  getCapacityCost(errorType) {\n    return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n  }\n\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","createDefaultRetryToken","StandardRetryStrategy","constructor","maxAttempts","mode","STANDARD","capacity","retryBackoffStrategy","maxAttemptsProvider","acquireInitialRetryToken","retryTokenScope","retryDelay","retryCount","refreshRetryTokenForRetry","token","errorInfo","getMaxAttempts","shouldRetry","errorType","setDelayBase","delayFromErrorType","computeNextBackoffDelay","getRetryCount","retryAfterHint","Math","max","getTime","Date","now","capacityCost","getCapacityCost","retryCost","Error","recordSuccess","getRetryCost","getCapacity","error","console","warn","tokenToRenew","attempts","isRetryableError"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nimport { createDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttempts) {\n        this.maxAttempts = maxAttempts;\n        this.mode = RETRY_MODES.STANDARD;\n        this.capacity = INITIAL_RETRY_TOKENS;\n        this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();\n        this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return createDefaultRetryToken({\n            retryDelay: DEFAULT_RETRY_DELAY_BASE,\n            retryCount: 0,\n        });\n    }\n    async refreshRetryTokenForRetry(token, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(token, errorInfo, maxAttempts)) {\n            const errorType = errorInfo.errorType;\n            this.retryBackoffStrategy.setDelayBase(errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);\n            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());\n            const retryDelay = errorInfo.retryAfterHint\n                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)\n                : delayFromErrorType;\n            const capacityCost = this.getCapacityCost(errorType);\n            this.capacity -= capacityCost;\n            return createDefaultRetryToken({\n                retryDelay,\n                retryCount: token.getRetryCount() + 1,\n                retryCost: capacityCost,\n            });\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));\n    }\n    getCapacity() {\n        return this.capacity;\n    }\n    async getMaxAttempts() {\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount();\n        return (attempts < maxAttempts &&\n            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    getCapacityCost(errorType) {\n        return errorType === \"TRANSIENT\" ? TIMEOUT_RETRY_COST : RETRY_COST;\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":";AAAA,SAASA,oBAAT,EAA+BC,WAA/B,QAAkD,UAAlD;AACA,SAASC,wBAAT,EAAmCC,oBAAnC,EAAyDC,kBAAzD,EAA6EC,UAA7E,EAAyFC,2BAAzF,EAAsHC,kBAAtH,QAAiJ,aAAjJ;AACA,SAASC,8BAAT,QAA+C,+BAA/C;AACA,SAASC,uBAAT,QAAwC,qBAAxC;AACA,OAAO,MAAMC,qBAAN,CAA4B;EAC/BC,WAAW,CAACC,WAAD,EAAc;IACrB,KAAKA,WAAL,GAAmBA,WAAnB;IACA,KAAKC,IAAL,GAAYZ,WAAW,CAACa,QAAxB;IACA,KAAKC,QAAL,GAAgBZ,oBAAhB;IACA,KAAKa,oBAAL,GAA4BR,8BAA8B,EAA1D;IACA,KAAKS,mBAAL,GAA2B,OAAOL,WAAP,KAAuB,UAAvB,GAAoCA,WAApC,kCAAkD;MAAA,OAAYA,WAAZ;IAAA,CAAlD,CAA3B;EACH;;EACKM,wBAAwB,CAACC,eAAD,EAAkB;IAAA;MAC5C,OAAOV,uBAAuB,CAAC;QAC3BW,UAAU,EAAElB,wBADe;QAE3BmB,UAAU,EAAE;MAFe,CAAD,CAA9B;IAD4C;EAK/C;;EACKC,yBAAyB,CAACC,KAAD,EAAQC,SAAR,EAAmB;IAAA;;IAAA;MAC9C,MAAMZ,WAAW,SAAS,KAAI,CAACa,cAAL,EAA1B;;MACA,IAAI,KAAI,CAACC,WAAL,CAAiBH,KAAjB,EAAwBC,SAAxB,EAAmCZ,WAAnC,CAAJ,EAAqD;QACjD,MAAMe,SAAS,GAAGH,SAAS,CAACG,SAA5B;;QACA,KAAI,CAACX,oBAAL,CAA0BY,YAA1B,CAAuCD,SAAS,KAAK,YAAd,GAA6BrB,2BAA7B,GAA2DJ,wBAAlG;;QACA,MAAM2B,kBAAkB,GAAG,KAAI,CAACb,oBAAL,CAA0Bc,uBAA1B,CAAkDP,KAAK,CAACQ,aAAN,EAAlD,CAA3B;;QACA,MAAMX,UAAU,GAAGI,SAAS,CAACQ,cAAV,GACbC,IAAI,CAACC,GAAL,CAASV,SAAS,CAACQ,cAAV,CAAyBG,OAAzB,KAAqCC,IAAI,CAACC,GAAL,EAArC,IAAmD,CAA5D,EAA+DR,kBAA/D,CADa,GAEbA,kBAFN;;QAGA,MAAMS,YAAY,GAAG,KAAI,CAACC,eAAL,CAAqBZ,SAArB,CAArB;;QACA,KAAI,CAACZ,QAAL,IAAiBuB,YAAjB;QACA,OAAO7B,uBAAuB,CAAC;UAC3BW,UAD2B;UAE3BC,UAAU,EAAEE,KAAK,CAACQ,aAAN,KAAwB,CAFT;UAG3BS,SAAS,EAAEF;QAHgB,CAAD,CAA9B;MAKH;;MACD,MAAM,IAAIG,KAAJ,CAAU,0BAAV,CAAN;IAjB8C;EAkBjD;;EACDC,aAAa,CAACnB,KAAD,EAAQ;IACjB,KAAKR,QAAL,GAAgBkB,IAAI,CAACC,GAAL,CAAS/B,oBAAT,EAA+B,KAAKY,QAAL,IAAiBQ,KAAK,CAACoB,YAAN,MAAwBvC,kBAAzC,CAA/B,CAAhB;EACH;;EACDwC,WAAW,GAAG;IACV,OAAO,KAAK7B,QAAZ;EACH;;EACKU,cAAc,GAAG;IAAA;;IAAA;MACnB,IAAI;QACA,aAAa,MAAI,CAACR,mBAAL,EAAb;MACH,CAFD,CAGA,OAAO4B,KAAP,EAAc;QACVC,OAAO,CAACC,IAAR,CAAc,6DAA4D/C,oBAAqB,EAA/F;QACA,OAAOA,oBAAP;MACH;IAPkB;EAQtB;;EACD0B,WAAW,CAACsB,YAAD,EAAexB,SAAf,EAA0BZ,WAA1B,EAAuC;IAC9C,MAAMqC,QAAQ,GAAGD,YAAY,CAACjB,aAAb,EAAjB;IACA,OAAQkB,QAAQ,GAAGrC,WAAX,IACJ,KAAKG,QAAL,IAAiB,KAAKwB,eAAL,CAAqBf,SAAS,CAACG,SAA/B,CADb,IAEJ,KAAKuB,gBAAL,CAAsB1B,SAAS,CAACG,SAAhC,CAFJ;EAGH;;EACDY,eAAe,CAACZ,SAAD,EAAY;IACvB,OAAOA,SAAS,KAAK,WAAd,GAA4BpB,kBAA5B,GAAiDF,UAAxD;EACH;;EACD6C,gBAAgB,CAACvB,SAAD,EAAY;IACxB,OAAOA,SAAS,KAAK,YAAd,IAA8BA,SAAS,KAAK,WAAnD;EACH;;AA3D8B"},"metadata":{},"sourceType":"module"}