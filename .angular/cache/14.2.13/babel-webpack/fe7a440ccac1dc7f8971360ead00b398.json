{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  const {\n    inputs,\n    attrs,\n    backend\n  } = args;\n  const {\n    image,\n    transforms\n  } = inputs;\n  const {\n    interpolation,\n    fillMode,\n    fillValue,\n    outputShape\n  } = attrs;\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape = [batch, outHeight, outWidth, numChannels];\n  const strides = util.computeStrides(image.shape);\n  const batchStride = strides[0];\n  const rowStride = strides[1];\n  const colStride = strides[2];\n  const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  const imageVals = backend.data.get(image.dataId).values;\n  const transformVals = backend.data.get(transforms.dataId).values; // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n\n  for (let b = 0; b < batch; ++b) {\n    const transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n\n    for (let outY = 0; outY < outHeight; ++outY) {\n      for (let outX = 0; outX < outWidth; ++outX) {\n        for (let channel = 0; channel < numChannels; ++channel) {\n          let val;\n          const projection = transform[6] * outX + transform[7] * outY + 1;\n\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n\n          const inX = (transform[0] * outX + transform[1] * outY + transform[2]) / projection;\n          const inY = (transform[3] * outX + transform[4] * outY + transform[5]) / projection;\n          const x = mapCoord(inX, imageWidth, fillMode);\n          const y = mapCoord(inY, imageHeight, fillMode);\n\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n              break;\n\n            default:\n              throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);\n          }\n\n          const ind = b * batchStride + outY * rowStride + outX * colStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n\n  const dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport const transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\n\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\n\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz2 = 2 * len;\n      inCoord -= sz2 * Math.trunc(inCoord / sz2);\n\n      if (inCoord >= len) {\n        inCoord = sz2 - inCoord - 1;\n      }\n    }\n  } // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  let inCoord = outCoord;\n\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      const sz = len - 1;\n      inCoord -= len * Math.trunc(inCoord / sz);\n    }\n  } // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n\n\n  return util.clamp(0, inCoord, len - 1);\n}\n\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\n\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\n\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\n\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const $y = Math.round(y);\n  const $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\n\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  const yFloor = Math.floor(y);\n  const xFloor = Math.floor(x);\n  const yCeil = yFloor + 1;\n  const xCeil = xFloor + 1; // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n\n  const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue); // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n\n  const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue); // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":{"version":3,"names":["Transform","util","transform","args","inputs","attrs","backend","image","transforms","interpolation","fillMode","fillValue","outputShape","batch","imageHeight","imageWidth","numChannels","shape","outHeight","outWidth","outShape","strides","computeStrides","batchStride","rowStride","colStride","outVals","getTypedArrayFromDType","dtype","sizeFromShape","fill","imageVals","data","get","dataId","values","transformVals","b","subarray","outY","outX","channel","val","projection","inX","inY","x","mapCoord","y","nearestInterpolation","bilinearInterpolation","Error","ind","makeTensorInfo","write","transformConfig","kernelName","backendName","kernelFunc","outCoord","len","mode","mapCoordReflect","mapCoordWrap","mapCoordNearest","mapCoordConstant","inCoord","sz2","Math","trunc","clamp","sz","readWithFillValue","$y","round","$x","yFloor","floor","xFloor","yCeil","xCeil","valueYFloor","valueYCeil"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transform.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n    const { inputs, attrs, backend } = args;\n    const { image, transforms } = inputs;\n    const { interpolation, fillMode, fillValue, outputShape } = attrs;\n    const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];\n    const outShape = [batch, outHeight, outWidth, numChannels];\n    const strides = util.computeStrides(image.shape);\n    const batchStride = strides[0];\n    const rowStride = strides[1];\n    const colStride = strides[2];\n    const outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n    outVals.fill(fillValue);\n    const imageVals = backend.data.get(image.dataId).values;\n    const transformVals = backend.data.get(transforms.dataId).values;\n    // Ref TF implementation:\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n    for (let b = 0; b < batch; ++b) {\n        const transform = transforms.shape[0] === 1 ?\n            transformVals :\n            transformVals.subarray(b * 8, b * 8 + 8);\n        for (let outY = 0; outY < outHeight; ++outY) {\n            for (let outX = 0; outX < outWidth; ++outX) {\n                for (let channel = 0; channel < numChannels; ++channel) {\n                    let val;\n                    const projection = transform[6] * outX + transform[7] * outY + 1;\n                    if (projection === 0) {\n                        // Return the fill value for infinite coordinates,\n                        // which are outside the input image\n                        continue;\n                    }\n                    const inX = (transform[0] * outX + transform[1] * outY + transform[2]) /\n                        projection;\n                    const inY = (transform[3] * outX + transform[4] * outY + transform[5]) /\n                        projection;\n                    const x = mapCoord(inX, imageWidth, fillMode);\n                    const y = mapCoord(inY, imageHeight, fillMode);\n                    switch (interpolation) {\n                        case 'nearest':\n                            val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n                            break;\n                        case 'bilinear':\n                            val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);\n                            break;\n                        default:\n                            throw new Error(`Error in Transform: Expect 'nearest' or ` +\n                                `'bilinear', but got ${interpolation}`);\n                    }\n                    const ind = b * batchStride + outY * rowStride + outX * colStride + channel;\n                    outVals[ind] = val;\n                }\n            }\n        }\n        return backend.makeTensorInfo(outShape, image.dtype, outVals);\n    }\n    const dataId = backend.write(outVals, outShape, image.dtype);\n    return { dataId, shape: image.shape, dtype: image.dtype };\n}\nexport const transformConfig = {\n    kernelName: Transform,\n    backendName: 'cpu',\n    kernelFunc: transform\n};\nfunction mapCoord(outCoord, len, mode) {\n    switch (mode) {\n        case 'reflect':\n            return mapCoordReflect(outCoord, len);\n        case 'wrap':\n            return mapCoordWrap(outCoord, len);\n        case 'nearest':\n            return mapCoordNearest(outCoord, len);\n        case 'constant':\n        default:\n            return mapCoordConstant(outCoord, len);\n    }\n}\nfunction mapCoordReflect(outCoord, len) {\n    // Reflect [abcd] to [dcba|abcd|dcba].\n    let inCoord = outCoord;\n    if (inCoord < 0) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz2 = 2 * len;\n            if (inCoord < sz2) {\n                inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n            }\n            inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n        }\n    }\n    else if (inCoord > len - 1) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz2 = 2 * len;\n            inCoord -= sz2 * Math.trunc(inCoord / sz2);\n            if (inCoord >= len) {\n                inCoord = sz2 - inCoord - 1;\n            }\n        }\n    }\n    // clamp is necessary because when outCoord = 3.5 and len = 4,\n    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n    return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordWrap(outCoord, len) {\n    // Wrap [abcd] to [abcd|abcd|abcd].\n    let inCoord = outCoord;\n    if (inCoord < 0) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz = len - 1;\n            inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n        }\n    }\n    else if (inCoord > len - 1) {\n        if (len <= 1) {\n            inCoord = 0;\n        }\n        else {\n            const sz = len - 1;\n            inCoord -= len * Math.trunc(inCoord / sz);\n        }\n    }\n    // clamp is necessary because when outCoord = -0.5 and len = 4,\n    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n    return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordConstant(outCoord, len) {\n    return outCoord;\n}\nfunction mapCoordNearest(outCoord, len) {\n    return util.clamp(0, outCoord, len - 1);\n}\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const ind = batch * batchStride + y * rowStride + x * colStride + channel;\n    if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n        return imageVals[ind];\n    }\n    else {\n        return fillValue;\n    }\n}\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const $y = Math.round(y);\n    const $x = Math.round(x);\n    return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n    const yFloor = Math.floor(y);\n    const xFloor = Math.floor(x);\n    const yCeil = yFloor + 1;\n    const xCeil = xFloor + 1;\n    // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n    //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n    const valueYFloor = (xCeil - x) *\n        readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) +\n        (x - xFloor) *\n            readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);\n    // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n    //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n    const valueYCeil = (xCeil - x) *\n        readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) +\n        (x - xFloor) *\n            readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);\n    // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n    //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n    return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}