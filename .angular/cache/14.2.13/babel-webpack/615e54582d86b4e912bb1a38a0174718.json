{"ast":null,"code":"import { __values } from \"tslib\";\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(Array.from(geometry.Polygon));\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\n\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // We categorize each block by running a forEach loop through them.\n\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  }); // remove trailing space of fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n\n      default:\n        blockMap[block.Id] = block;\n    }\n  }); // remove trailing space in fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1); // Post-process complex structures if they exist.\n\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      var entityTypes = Array.from(keyValue.EntityTypes);\n\n      if (entityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructTable(table, blockMap) {\n  var e_1, _a, e_2, _b;\n\n  var tableMatrix;\n  tableMatrix = [];\n\n  try {\n    // visit each of the cell associated with the table's relationship.\n    for (var _c = __values(table.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var tableRelation = _d.value;\n\n      try {\n        for (var _e = (e_2 = void 0, __values(tableRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var cellId = _f.value;\n          var cellBlock = blockMap[cellId];\n          var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\n          var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n          // extract data contained inside the cell.\n\n          var content = extractContentsFromBlock(cellBlock, blockMap);\n          var cell = {\n            text: content.text,\n            boundingBox: getBoundingBox(cellBlock.Geometry),\n            polygon: getPolygon(cellBlock.Geometry),\n            selected: content.selected,\n            rowSpan: cellBlock.RowSpan,\n            columnSpan: cellBlock.ColumnSpan\n          };\n          if (!tableMatrix[row]) tableMatrix[row] = [];\n          tableMatrix[row][col] = cell;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length; // Note that we leave spanned cells undefined for distinction\n\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructKeyValue(keyBlock, blockMap) {\n  var e_3, _a, e_4, _b;\n\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n\n  try {\n    for (var _c = __values(keyBlock.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var keyValueRelation = _d.value;\n\n      if (keyValueRelation.Type === 'CHILD') {\n        // relation refers to key\n        var contents = extractContentsFromBlock(keyBlock, blockMap);\n        keyText = contents.text;\n      } else if (keyValueRelation.Type === 'VALUE') {\n        try {\n          // relation refers to value\n          for (var _e = (e_4 = void 0, __values(keyValueRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var valueId = _f.value;\n            var valueBlock = blockMap[valueId];\n            var contents = extractContentsFromBlock(valueBlock, blockMap);\n            valueText = contents.text;\n            if (contents.selected != null) valueSelected = contents.selected;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function extractContentsFromBlock(block, blockMap) {\n  var e_5, _a, e_6, _b;\n\n  var words = '';\n  var isSelected;\n\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n\n  try {\n    for (var _c = __values(block.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var relation = _d.value;\n\n      try {\n        for (var _e = (e_6 = void 0, __values(relation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var contentId = _f.value;\n          var contentBlock = blockMap[contentId];\n\n          if (contentBlock.BlockType === 'WORD') {\n            words += contentBlock.Text + ' ';\n          } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n            isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n\n  words = words.substr(0, words.length - 1); // remove trailing space.\n\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"names":["__values","makeCamelCaseArray","makeCamelCase","getBoundingBox","geometry","undefined","BoundingBox","getPolygon","Array","from","Polygon","categorizeRekognitionBlocks","blocks","response","text","fullText","words","lines","linesDetailed","forEach","block","Type","push","DetectedText","polygon","Geometry","boundingBox","page","substr","length","categorizeTextractBlocks","tableBlocks","keyValueBlocks","blockMap","BlockType","Text","Page","Id","selectionStatus","SelectionStatus","selections","selected","tableResponse_1","table","constructTable","tables","keyValueResponse_1","keyValue","entityTypes","EntityTypes","indexOf","constructKeyValue","keyValues","e_1","_a","e_2","_b","tableMatrix","_c","Relationships","_d","next","done","tableRelation","value","_e","Ids","_f","cellId","cellBlock","row","RowIndex","col","ColumnIndex","content","extractContentsFromBlock","cell","rowSpan","RowSpan","columnSpan","ColumnSpan","e_2_1","error","return","call","e_1_1","rowSize","columnSize","size","rows","columns","keyBlock","e_3","e_4","keyText","valueText","valueSelected","keyValueRelation","contents","valueId","valueBlock","e_4_1","e_3_1","key","e_5","e_6","isSelected","relation","contentId","contentBlock","e_6_1","e_5_1"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/predictions/lib-esm/Providers/IdentifyTextUtils.js"],"sourcesContent":["import { __values } from \"tslib\";\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\nfunction getBoundingBox(geometry) {\n    if (!geometry)\n        return undefined;\n    return makeCamelCase(geometry.BoundingBox);\n}\nfunction getPolygon(geometry) {\n    if (!geometry)\n        return undefined;\n    return makeCamelCaseArray(Array.from(geometry.Polygon));\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(blocks) {\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n    var response = {\n        text: {\n            fullText: '',\n            words: [],\n            lines: [],\n            linesDetailed: [],\n        },\n    };\n    // We categorize each block by running a forEach loop through them.\n    blocks.forEach(function (block) {\n        switch (block.Type) {\n            case 'LINE':\n                response.text.lines.push(block.DetectedText);\n                response.text.linesDetailed.push({\n                    text: block.DetectedText,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                    page: null,\n                });\n                break;\n            case 'WORD':\n                response.text.fullText += block.DetectedText + ' ';\n                response.text.words.push({\n                    text: block.DetectedText,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                break;\n        }\n    });\n    // remove trailing space of fullText\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n    return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(blocks) {\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n    var response = {\n        text: {\n            fullText: '',\n            words: [],\n            lines: [],\n            linesDetailed: [],\n        },\n    };\n    // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n    if (blocks.length === 0)\n        return response;\n    /**\n     * We categorize each of the blocks by running a forEach loop through them.\n     *\n     * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n     * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n     * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n     *\n     * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n     * block except the Page block.\n     */\n    var tableBlocks = Array();\n    var keyValueBlocks = Array();\n    var blockMap = {};\n    blocks.forEach(function (block) {\n        switch (block.BlockType) {\n            case 'LINE':\n                response.text.lines.push(block.Text);\n                response.text.linesDetailed.push({\n                    text: block.Text,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                    page: block.Page,\n                });\n                break;\n            case 'WORD':\n                response.text.fullText += block.Text + ' ';\n                response.text.words.push({\n                    text: block.Text,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                blockMap[block.Id] = block;\n                break;\n            case 'SELECTION_ELEMENT':\n                var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n                if (!response.text.selections)\n                    response.text.selections = [];\n                response.text.selections.push({\n                    selected: selectionStatus,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                blockMap[block.Id] = block;\n                break;\n            case 'TABLE':\n                tableBlocks.push(block);\n                break;\n            case 'KEY_VALUE_SET':\n                keyValueBlocks.push(block);\n                blockMap[block.Id] = block;\n                break;\n            default:\n                blockMap[block.Id] = block;\n        }\n    });\n    // remove trailing space in fullText\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n    // Post-process complex structures if they exist.\n    if (tableBlocks.length !== 0) {\n        var tableResponse_1 = Array();\n        tableBlocks.forEach(function (table) {\n            tableResponse_1.push(constructTable(table, blockMap));\n        });\n        response.text.tables = tableResponse_1;\n    }\n    if (keyValueBlocks.length !== 0) {\n        var keyValueResponse_1 = Array();\n        keyValueBlocks.forEach(function (keyValue) {\n            // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n            var entityTypes = Array.from(keyValue.EntityTypes);\n            if (entityTypes.indexOf('KEY') !== -1) {\n                keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n            }\n        });\n        response.text.keyValues = keyValueResponse_1;\n    }\n    return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(table, blockMap) {\n    var e_1, _a, e_2, _b;\n    var tableMatrix;\n    tableMatrix = [];\n    try {\n        // visit each of the cell associated with the table's relationship.\n        for (var _c = __values(table.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var tableRelation = _d.value;\n            try {\n                for (var _e = (e_2 = void 0, __values(tableRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var cellId = _f.value;\n                    var cellBlock = blockMap[cellId];\n                    var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n                    var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n                    // extract data contained inside the cell.\n                    var content = extractContentsFromBlock(cellBlock, blockMap);\n                    var cell = {\n                        text: content.text,\n                        boundingBox: getBoundingBox(cellBlock.Geometry),\n                        polygon: getPolygon(cellBlock.Geometry),\n                        selected: content.selected,\n                        rowSpan: cellBlock.RowSpan,\n                        columnSpan: cellBlock.ColumnSpan,\n                    };\n                    if (!tableMatrix[row])\n                        tableMatrix[row] = [];\n                    tableMatrix[row][col] = cell;\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    var rowSize = tableMatrix.length;\n    var columnSize = tableMatrix[0].length;\n    // Note that we leave spanned cells undefined for distinction\n    return {\n        size: { rows: rowSize, columns: columnSize },\n        table: tableMatrix,\n        boundingBox: getBoundingBox(table.Geometry),\n        polygon: getPolygon(table.Geometry),\n    };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(keyBlock, blockMap) {\n    var e_3, _a, e_4, _b;\n    var keyText = '';\n    var valueText = '';\n    var valueSelected;\n    try {\n        for (var _c = __values(keyBlock.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var keyValueRelation = _d.value;\n            if (keyValueRelation.Type === 'CHILD') {\n                // relation refers to key\n                var contents = extractContentsFromBlock(keyBlock, blockMap);\n                keyText = contents.text;\n            }\n            else if (keyValueRelation.Type === 'VALUE') {\n                try {\n                    // relation refers to value\n                    for (var _e = (e_4 = void 0, __values(keyValueRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                        var valueId = _f.value;\n                        var valueBlock = blockMap[valueId];\n                        var contents = extractContentsFromBlock(valueBlock, blockMap);\n                        valueText = contents.text;\n                        if (contents.selected != null)\n                            valueSelected = contents.selected;\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            }\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return {\n        key: keyText,\n        value: { text: valueText, selected: valueSelected },\n        polygon: getPolygon(keyBlock.Geometry),\n        boundingBox: getBoundingBox(keyBlock.Geometry),\n    };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(block, blockMap) {\n    var e_5, _a, e_6, _b;\n    var words = '';\n    var isSelected;\n    if (!block.Relationships) {\n        // some block might have no content\n        return { text: '', selected: undefined };\n    }\n    try {\n        for (var _c = __values(block.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var relation = _d.value;\n            try {\n                for (var _e = (e_6 = void 0, __values(relation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var contentId = _f.value;\n                    var contentBlock = blockMap[contentId];\n                    if (contentBlock.BlockType === 'WORD') {\n                        words += contentBlock.Text + ' ';\n                    }\n                    else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n                        isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n                    }\n                }\n            }\n            catch (e_6_1) { e_6 = { error: e_6_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                }\n                finally { if (e_6) throw e_6.error; }\n            }\n        }\n    }\n    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_5) throw e_5.error; }\n    }\n    words = words.substr(0, words.length - 1); // remove trailing space.\n    return { text: words, selected: isSelected };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}