{"ast":null,"code":"import _asyncToGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './flags_wasm';\nimport { DataStorage, deprecationWarn, engine, env, KernelBackend, util } from '@tensorflow/tfjs-core';\nimport wasmFactoryThreadedSimd from '../wasm-out/tfjs-backend-wasm-threaded-simd.js'; // @ts-ignore\n\nimport { wasmWorkerContents } from '../wasm-out/tfjs-backend-wasm-threaded-simd.worker.js';\nimport wasmFactory from '../wasm-out/tfjs-backend-wasm.js';\nexport class BackendWasm extends KernelBackend {\n  constructor(wasm) {\n    super();\n    this.wasm = wasm; // 0 is reserved for null data ids.\n\n    this.dataIdNextNumber = 1;\n    this.wasm.tfjs.initWithThreadsCount(threadsCount);\n    actualThreadsCount = this.wasm.tfjs.getThreadsCount();\n    this.dataIdMap = new DataStorage(this, engine());\n  }\n\n  write(values, shape, dtype) {\n    const dataId = {\n      id: this.dataIdNextNumber++\n    };\n    this.move(dataId, values, shape, dtype, 1);\n    return dataId;\n  }\n\n  numDataIds() {\n    return this.dataIdMap.numDataIds();\n  }\n\n  time(f) {\n    return _asyncToGenerator(function* () {\n      const start = util.now();\n      f();\n      const kernelMs = util.now() - start;\n      return {\n        kernelMs\n      };\n    })();\n  }\n\n  move(dataId, values, shape, dtype, refCount) {\n    const id = this.dataIdNextNumber++;\n\n    if (dtype === 'string') {\n      const stringBytes = values;\n      this.dataIdMap.set(dataId, {\n        id,\n        stringBytes,\n        shape,\n        dtype,\n        memoryOffset: null,\n        refCount\n      });\n      return;\n    }\n\n    const size = util.sizeFromShape(shape);\n    const numBytes = size * util.bytesPerElement(dtype);\n\n    const memoryOffset = this.wasm._malloc(numBytes);\n\n    this.dataIdMap.set(dataId, {\n      id,\n      memoryOffset,\n      shape,\n      dtype,\n      refCount\n    });\n    this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n\n    if (values != null) {\n      this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);\n    }\n  }\n\n  read(dataId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.readSync(dataId);\n    })();\n  }\n\n  readSync(dataId) {\n    const {\n      memoryOffset,\n      dtype,\n      shape,\n      stringBytes\n    } = this.dataIdMap.get(dataId);\n\n    if (dtype === 'string') {\n      return stringBytes;\n    }\n\n    const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util.sizeFromShape(shape) * util.bytesPerElement(dtype));\n    return typedArrayFromBuffer(bytes.buffer, dtype);\n  }\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released, false otherwise.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n\n\n  disposeData(dataId, force = false) {\n    if (this.dataIdMap.has(dataId)) {\n      const data = this.dataIdMap.get(dataId);\n      data.refCount--;\n\n      if (!force && data.refCount > 0) {\n        return false;\n      }\n\n      this.wasm._free(data.memoryOffset);\n\n      this.wasm.tfjs.disposeData(data.id);\n      this.dataIdMap.delete(dataId);\n    }\n\n    return true;\n  }\n  /** Return refCount of a `TensorData`. */\n\n\n  refCount(dataId) {\n    if (this.dataIdMap.has(dataId)) {\n      const tensorData = this.dataIdMap.get(dataId);\n      return tensorData.refCount;\n    }\n\n    return 0;\n  }\n\n  incRef(dataId) {\n    const data = this.dataIdMap.get(dataId);\n\n    if (data != null) {\n      data.refCount++;\n    }\n  }\n\n  floatPrecision() {\n    return 32;\n  } // Returns the memory offset of a tensor. Useful for debugging and unit\n  // testing.\n\n\n  getMemoryOffset(dataId) {\n    return this.dataIdMap.get(dataId).memoryOffset;\n  }\n\n  dispose() {\n    this.wasm.tfjs.dispose();\n\n    if ('PThread' in this.wasm) {\n      this.wasm.PThread.terminateAllThreads();\n    }\n\n    this.wasm = null;\n  }\n\n  memory() {\n    return {\n      unreliable: false\n    };\n  }\n  /**\n   * Make a tensor info for the output of an op. If `memoryOffset` is not\n   * present, this method allocates memory on the WASM heap. If `memoryOffset`\n   * is present, the memory was allocated elsewhere (in c++) and we just record\n   * the pointer where that memory lives.\n   */\n\n\n  makeOutput(shape, dtype, memoryOffset) {\n    let dataId;\n\n    if (memoryOffset == null) {\n      dataId = this.write(null\n      /* values */\n      , shape, dtype);\n    } else {\n      const id = this.dataIdNextNumber++;\n      dataId = {\n        id\n      };\n      this.dataIdMap.set(dataId, {\n        id,\n        memoryOffset,\n        shape,\n        dtype,\n        refCount: 1\n      });\n      const size = util.sizeFromShape(shape);\n      this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n    }\n\n    return {\n      dataId,\n      shape,\n      dtype\n    };\n  }\n\n  typedArrayFromHeap({\n    shape,\n    dtype,\n    dataId\n  }) {\n    const buffer = this.wasm.HEAPU8.buffer;\n    const {\n      memoryOffset\n    } = this.dataIdMap.get(dataId);\n    const size = util.sizeFromShape(shape);\n\n    switch (dtype) {\n      case 'float32':\n        return new Float32Array(buffer, memoryOffset, size);\n\n      case 'int32':\n        return new Int32Array(buffer, memoryOffset, size);\n\n      case 'bool':\n        return new Uint8Array(buffer, memoryOffset, size);\n\n      default:\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n  }\n\n}\n\nfunction createInstantiateWasmFunc(path) {\n  // this will be replace by rollup plugin patchWechatWebAssembly in\n  // minprogram's output.\n  // tslint:disable-next-line:no-any\n  return (imports, callback) => {\n    util.fetch(path, {\n      credentials: 'same-origin'\n    }).then(response => {\n      if (!response['ok']) {\n        imports.env.a(`failed to load wasm binary file at '${path}'`);\n      }\n\n      response.arrayBuffer().then(binary => {\n        WebAssembly.instantiate(binary, imports).then(output => {\n          callback(output.instance, output.module);\n        });\n      });\n    });\n    return {};\n  };\n}\n/**\n * Returns the path of the WASM binary.\n * @param simdSupported whether SIMD is supported\n * @param threadsSupported whether multithreading is supported\n * @param wasmModuleFolder the directory containing the WASM binaries.\n */\n\n\nfunction getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {\n  if (wasmPath != null) {\n    // If wasmPath is defined, the user has supplied a full path to\n    // the vanilla .wasm binary.\n    return wasmPath;\n  }\n\n  let path = 'tfjs-backend-wasm.wasm';\n\n  if (simdSupported && threadsSupported) {\n    path = 'tfjs-backend-wasm-threaded-simd.wasm';\n  } else if (simdSupported) {\n    path = 'tfjs-backend-wasm-simd.wasm';\n  }\n\n  if (wasmFileMap != null) {\n    if (wasmFileMap[path] != null) {\n      return wasmFileMap[path];\n    }\n  }\n\n  return wasmModuleFolder + path;\n}\n/**\n * Initializes the wasm module and creates the js <--> wasm bridge.\n *\n * NOTE: We wrap the wasm module in a object with property 'wasm' instead of\n * returning Promise<BackendWasmModule> to avoid freezing Chrome (last tested\n * in Chrome 76).\n */\n\n\nexport function init() {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator(function* () {\n    const [simdSupported, threadsSupported] = yield Promise.all([env().getAsync('WASM_HAS_SIMD_SUPPORT'), env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')]);\n    return new Promise((resolve, reject) => {\n      const factoryConfig = {};\n      /**\n       * This function overrides the Emscripten module locateFile utility.\n       * @param path The relative path to the file that needs to be loaded.\n       * @param prefix The path to the main JavaScript file's directory.\n       */\n\n      factoryConfig.locateFile = (path, prefix) => {\n        if (path.endsWith('.worker.js')) {\n          const response = wasmWorkerContents;\n          const blob = new Blob([response], {\n            type: 'application/javascript'\n          });\n          return URL.createObjectURL(blob);\n        }\n\n        if (path.endsWith('.wasm')) {\n          return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);\n        }\n\n        return prefix + path;\n      }; // Use the instantiateWasm override when system fetch is not available.\n      // Reference:\n      // https://github.com/emscripten-core/emscripten/blob/2bca083cbbd5a4133db61fbd74d04f7feecfa907/tests/manual_wasm_instantiate.html#L170\n\n\n      if (customFetch) {\n        factoryConfig.instantiateWasm = createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ''));\n      }\n\n      let initialized = false;\n\n      factoryConfig.onAbort = () => {\n        if (initialized) {\n          // Emscripten already called console.warn so no need to double log.\n          return;\n        }\n\n        if (initAborted) {\n          // Emscripten calls `onAbort` twice, resulting in double error\n          // messages.\n          return;\n        }\n\n        initAborted = true;\n        const rejectMsg = 'Make sure the server can serve the `.wasm` file relative to the ' + 'bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers';\n        reject({\n          message: rejectMsg\n        });\n      };\n\n      let wasm; // If `wasmPath` has been defined we must initialize the vanilla module.\n\n      if (threadsSupported && simdSupported && wasmPath == null) {\n        factoryConfig.mainScriptUrlOrBlob = new Blob([`var WasmBackendModuleThreadedSimd = ` + wasmFactoryThreadedSimd.toString()], {\n          type: 'text/javascript'\n        });\n        wasm = wasmFactoryThreadedSimd(factoryConfig);\n      } else {\n        // The wasmFactory works for both vanilla and SIMD binaries.\n        wasm = wasmFactory(factoryConfig);\n      } // The WASM module has been successfully created by the factory.\n      // Any error will be caught by the onAbort callback defined above.\n\n\n      wasm.then(module => {\n        initialized = true;\n        initAborted = false;\n        const voidReturnType = null; // Using the tfjs namespace to avoid conflict with emscripten's API.\n\n        module.tfjs = {\n          init: module.cwrap('init', null, []),\n          initWithThreadsCount: module.cwrap('init_with_threads_count', null, ['number']),\n          getThreadsCount: module.cwrap('get_threads_count', 'number', []),\n          registerTensor: module.cwrap('register_tensor', null, ['number', 'number', 'number']),\n          disposeData: module.cwrap('dispose_data', voidReturnType, ['number']),\n          dispose: module.cwrap('dispose', voidReturnType, [])\n        };\n        resolve({\n          wasm: module\n        });\n      });\n    });\n  });\n  return _init.apply(this, arguments);\n}\n\nfunction typedArrayFromBuffer(buffer, dtype) {\n  switch (dtype) {\n    case 'float32':\n      return new Float32Array(buffer);\n\n    case 'int32':\n      return new Int32Array(buffer);\n\n    case 'bool':\n      return new Uint8Array(buffer);\n\n    default:\n      throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n\nconst wasmBinaryNames = ['tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm', 'tfjs-backend-wasm-threaded-simd.wasm'];\nlet wasmPath = null;\nlet wasmPathPrefix = null;\nlet wasmFileMap = {};\nlet initAborted = false;\nlet customFetch = false;\n/**\n * @deprecated Use `setWasmPaths` instead.\n * Sets the path to the `.wasm` file which will be fetched when the wasm\n * backend is initialized. See\n * https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\n * for more details.\n * @param path wasm file path or url\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\n\nexport function setWasmPath(path, usePlatformFetch = false) {\n  deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and' + ' will be removed in a future release.');\n\n  if (initAborted) {\n    throw new Error('The WASM backend was already initialized. Make sure you call ' + '`setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`');\n  }\n\n  wasmPath = path;\n  customFetch = usePlatformFetch;\n}\n/**\n * Configures the locations of the WASM binaries.\n *\n * ```js\n * setWasmPaths({\n *  'tfjs-backend-wasm.wasm': 'renamed.wasm',\n *  'tfjs-backend-wasm-simd.wasm': 'renamed-simd.wasm',\n *  'tfjs-backend-wasm-threaded-simd.wasm': 'renamed-threaded-simd.wasm'\n * });\n * tf.setBackend('wasm');\n * ```\n *\n * @param prefixOrFileMap This can be either a string or object:\n *  - (string) The path to the directory where the WASM binaries are located.\n *     Note that this prefix will be used to load each binary (vanilla,\n *     SIMD-enabled, threading-enabled, etc.).\n *  - (object) Mapping from names of WASM binaries to custom\n *     full paths specifying the locations of those binaries. This is useful if\n *     your WASM binaries are not all located in the same directory, or if your\n *     WASM binaries have been renamed.\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\n\nexport function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {\n  if (initAborted) {\n    throw new Error('The WASM backend was already initialized. Make sure you call ' + '`setWasmPaths()` before you call `tf.setBackend()` or ' + '`tf.ready()`');\n  }\n\n  if (typeof prefixOrFileMap === 'string') {\n    wasmPathPrefix = prefixOrFileMap;\n  } else {\n    wasmFileMap = prefixOrFileMap;\n    const missingPaths = wasmBinaryNames.filter(name => wasmFileMap[name] == null);\n\n    if (missingPaths.length > 0) {\n      throw new Error(`There were no entries found for the following binaries: ` + `${missingPaths.join(',')}. Please either call setWasmPaths with a ` + `map providing a path for each binary, or with a string indicating ` + `the directory where all the binaries can be found.`);\n    }\n  }\n\n  customFetch = usePlatformFetch;\n}\n/** Used in unit tests. */\n\nexport function resetWasmPath() {\n  wasmPath = null;\n  wasmPathPrefix = null;\n  wasmFileMap = {};\n  customFetch = false;\n  initAborted = false;\n}\nlet threadsCount = -1;\nlet actualThreadsCount = -1;\n/**\n * Sets the number of threads that will be used by XNNPACK to create\n * threadpool (default to the number of logical CPU cores).\n *\n * This must be called before calling `tf.setBackend('wasm')`.\n */\n\nexport function setThreadsCount(numThreads) {\n  threadsCount = numThreads;\n}\n/**\n * Gets the actual threads count that is used by XNNPACK.\n *\n * It is set after the backend is intialized.\n */\n\nexport function getThreadsCount() {\n  if (actualThreadsCount === -1) {\n    throw new Error(`WASM backend not initialized.`);\n  }\n\n  return actualThreadsCount;\n}","map":{"version":3,"names":["DataStorage","deprecationWarn","engine","env","KernelBackend","util","wasmFactoryThreadedSimd","wasmWorkerContents","wasmFactory","BackendWasm","constructor","wasm","dataIdNextNumber","tfjs","initWithThreadsCount","threadsCount","actualThreadsCount","getThreadsCount","dataIdMap","write","values","shape","dtype","dataId","id","move","numDataIds","time","f","start","now","kernelMs","refCount","stringBytes","set","memoryOffset","size","sizeFromShape","numBytes","bytesPerElement","_malloc","registerTensor","HEAPU8","Uint8Array","buffer","byteOffset","read","readSync","get","bytes","slice","typedArrayFromBuffer","disposeData","force","has","data","_free","delete","tensorData","incRef","floatPrecision","getMemoryOffset","dispose","PThread","terminateAllThreads","memory","unreliable","makeOutput","typedArrayFromHeap","Float32Array","Int32Array","Error","createInstantiateWasmFunc","path","imports","callback","fetch","credentials","then","response","a","arrayBuffer","binary","WebAssembly","instantiate","output","instance","module","getPathToWasmBinary","simdSupported","threadsSupported","wasmModuleFolder","wasmPath","wasmFileMap","init","Promise","all","getAsync","resolve","reject","factoryConfig","locateFile","prefix","endsWith","blob","Blob","type","URL","createObjectURL","wasmPathPrefix","customFetch","instantiateWasm","initialized","onAbort","initAborted","rejectMsg","message","mainScriptUrlOrBlob","toString","voidReturnType","cwrap","wasmBinaryNames","setWasmPath","usePlatformFetch","setWasmPaths","prefixOrFileMap","missingPaths","filter","name","length","join","resetWasmPath","setThreadsCount","numThreads"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-wasm/dist/backend_wasm.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './flags_wasm';\nimport { DataStorage, deprecationWarn, engine, env, KernelBackend, util } from '@tensorflow/tfjs-core';\nimport wasmFactoryThreadedSimd from '../wasm-out/tfjs-backend-wasm-threaded-simd.js';\n// @ts-ignore\nimport { wasmWorkerContents } from '../wasm-out/tfjs-backend-wasm-threaded-simd.worker.js';\nimport wasmFactory from '../wasm-out/tfjs-backend-wasm.js';\nexport class BackendWasm extends KernelBackend {\n    constructor(wasm) {\n        super();\n        this.wasm = wasm;\n        // 0 is reserved for null data ids.\n        this.dataIdNextNumber = 1;\n        this.wasm.tfjs.initWithThreadsCount(threadsCount);\n        actualThreadsCount = this.wasm.tfjs.getThreadsCount();\n        this.dataIdMap = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        const dataId = { id: this.dataIdNextNumber++ };\n        this.move(dataId, values, shape, dtype, 1);\n        return dataId;\n    }\n    numDataIds() {\n        return this.dataIdMap.numDataIds();\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        const id = this.dataIdNextNumber++;\n        if (dtype === 'string') {\n            const stringBytes = values;\n            this.dataIdMap.set(dataId, { id, stringBytes, shape, dtype, memoryOffset: null, refCount });\n            return;\n        }\n        const size = util.sizeFromShape(shape);\n        const numBytes = size * util.bytesPerElement(dtype);\n        const memoryOffset = this.wasm._malloc(numBytes);\n        this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount });\n        this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n        if (values != null) {\n            this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);\n        }\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { memoryOffset, dtype, shape, stringBytes } = this.dataIdMap.get(dataId);\n        if (dtype === 'string') {\n            return stringBytes;\n        }\n        const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util.sizeFromShape(shape) * util.bytesPerElement(dtype));\n        return typedArrayFromBuffer(bytes.buffer, dtype);\n    }\n    /**\n     * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n     * is released, false otherwise.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n    disposeData(dataId, force = false) {\n        if (this.dataIdMap.has(dataId)) {\n            const data = this.dataIdMap.get(dataId);\n            data.refCount--;\n            if (!force && data.refCount > 0) {\n                return false;\n            }\n            this.wasm._free(data.memoryOffset);\n            this.wasm.tfjs.disposeData(data.id);\n            this.dataIdMap.delete(dataId);\n        }\n        return true;\n    }\n    /** Return refCount of a `TensorData`. */\n    refCount(dataId) {\n        if (this.dataIdMap.has(dataId)) {\n            const tensorData = this.dataIdMap.get(dataId);\n            return tensorData.refCount;\n        }\n        return 0;\n    }\n    incRef(dataId) {\n        const data = this.dataIdMap.get(dataId);\n        if (data != null) {\n            data.refCount++;\n        }\n    }\n    floatPrecision() {\n        return 32;\n    }\n    // Returns the memory offset of a tensor. Useful for debugging and unit\n    // testing.\n    getMemoryOffset(dataId) {\n        return this.dataIdMap.get(dataId).memoryOffset;\n    }\n    dispose() {\n        this.wasm.tfjs.dispose();\n        if ('PThread' in this.wasm) {\n            this.wasm.PThread.terminateAllThreads();\n        }\n        this.wasm = null;\n    }\n    memory() {\n        return { unreliable: false };\n    }\n    /**\n     * Make a tensor info for the output of an op. If `memoryOffset` is not\n     * present, this method allocates memory on the WASM heap. If `memoryOffset`\n     * is present, the memory was allocated elsewhere (in c++) and we just record\n     * the pointer where that memory lives.\n     */\n    makeOutput(shape, dtype, memoryOffset) {\n        let dataId;\n        if (memoryOffset == null) {\n            dataId = this.write(null /* values */, shape, dtype);\n        }\n        else {\n            const id = this.dataIdNextNumber++;\n            dataId = { id };\n            this.dataIdMap.set(dataId, { id, memoryOffset, shape, dtype, refCount: 1 });\n            const size = util.sizeFromShape(shape);\n            this.wasm.tfjs.registerTensor(id, size, memoryOffset);\n        }\n        return { dataId, shape, dtype };\n    }\n    typedArrayFromHeap({ shape, dtype, dataId }) {\n        const buffer = this.wasm.HEAPU8.buffer;\n        const { memoryOffset } = this.dataIdMap.get(dataId);\n        const size = util.sizeFromShape(shape);\n        switch (dtype) {\n            case 'float32':\n                return new Float32Array(buffer, memoryOffset, size);\n            case 'int32':\n                return new Int32Array(buffer, memoryOffset, size);\n            case 'bool':\n                return new Uint8Array(buffer, memoryOffset, size);\n            default:\n                throw new Error(`Unknown dtype ${dtype}`);\n        }\n    }\n}\nfunction createInstantiateWasmFunc(path) {\n    // this will be replace by rollup plugin patchWechatWebAssembly in\n    // minprogram's output.\n    // tslint:disable-next-line:no-any\n    return (imports, callback) => {\n        util.fetch(path, { credentials: 'same-origin' }).then((response) => {\n            if (!response['ok']) {\n                imports.env.a(`failed to load wasm binary file at '${path}'`);\n            }\n            response.arrayBuffer().then(binary => {\n                WebAssembly.instantiate(binary, imports).then(output => {\n                    callback(output.instance, output.module);\n                });\n            });\n        });\n        return {};\n    };\n}\n/**\n * Returns the path of the WASM binary.\n * @param simdSupported whether SIMD is supported\n * @param threadsSupported whether multithreading is supported\n * @param wasmModuleFolder the directory containing the WASM binaries.\n */\nfunction getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {\n    if (wasmPath != null) {\n        // If wasmPath is defined, the user has supplied a full path to\n        // the vanilla .wasm binary.\n        return wasmPath;\n    }\n    let path = 'tfjs-backend-wasm.wasm';\n    if (simdSupported && threadsSupported) {\n        path = 'tfjs-backend-wasm-threaded-simd.wasm';\n    }\n    else if (simdSupported) {\n        path = 'tfjs-backend-wasm-simd.wasm';\n    }\n    if (wasmFileMap != null) {\n        if (wasmFileMap[path] != null) {\n            return wasmFileMap[path];\n        }\n    }\n    return wasmModuleFolder + path;\n}\n/**\n * Initializes the wasm module and creates the js <--> wasm bridge.\n *\n * NOTE: We wrap the wasm module in a object with property 'wasm' instead of\n * returning Promise<BackendWasmModule> to avoid freezing Chrome (last tested\n * in Chrome 76).\n */\nexport async function init() {\n    const [simdSupported, threadsSupported] = await Promise.all([\n        env().getAsync('WASM_HAS_SIMD_SUPPORT'),\n        env().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')\n    ]);\n    return new Promise((resolve, reject) => {\n        const factoryConfig = {};\n        /**\n         * This function overrides the Emscripten module locateFile utility.\n         * @param path The relative path to the file that needs to be loaded.\n         * @param prefix The path to the main JavaScript file's directory.\n         */\n        factoryConfig.locateFile = (path, prefix) => {\n            if (path.endsWith('.worker.js')) {\n                const response = wasmWorkerContents;\n                const blob = new Blob([response], { type: 'application/javascript' });\n                return URL.createObjectURL(blob);\n            }\n            if (path.endsWith('.wasm')) {\n                return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);\n            }\n            return prefix + path;\n        };\n        // Use the instantiateWasm override when system fetch is not available.\n        // Reference:\n        // https://github.com/emscripten-core/emscripten/blob/2bca083cbbd5a4133db61fbd74d04f7feecfa907/tests/manual_wasm_instantiate.html#L170\n        if (customFetch) {\n            factoryConfig.instantiateWasm =\n                createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ''));\n        }\n        let initialized = false;\n        factoryConfig.onAbort = () => {\n            if (initialized) {\n                // Emscripten already called console.warn so no need to double log.\n                return;\n            }\n            if (initAborted) {\n                // Emscripten calls `onAbort` twice, resulting in double error\n                // messages.\n                return;\n            }\n            initAborted = true;\n            const rejectMsg = 'Make sure the server can serve the `.wasm` file relative to the ' +\n                'bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers';\n            reject({ message: rejectMsg });\n        };\n        let wasm;\n        // If `wasmPath` has been defined we must initialize the vanilla module.\n        if (threadsSupported && simdSupported && wasmPath == null) {\n            factoryConfig.mainScriptUrlOrBlob = new Blob([`var WasmBackendModuleThreadedSimd = ` +\n                    wasmFactoryThreadedSimd.toString()], { type: 'text/javascript' });\n            wasm = wasmFactoryThreadedSimd(factoryConfig);\n        }\n        else {\n            // The wasmFactory works for both vanilla and SIMD binaries.\n            wasm = wasmFactory(factoryConfig);\n        }\n        // The WASM module has been successfully created by the factory.\n        // Any error will be caught by the onAbort callback defined above.\n        wasm.then((module) => {\n            initialized = true;\n            initAborted = false;\n            const voidReturnType = null;\n            // Using the tfjs namespace to avoid conflict with emscripten's API.\n            module.tfjs = {\n                init: module.cwrap('init', null, []),\n                initWithThreadsCount: module.cwrap('init_with_threads_count', null, ['number']),\n                getThreadsCount: module.cwrap('get_threads_count', 'number', []),\n                registerTensor: module.cwrap('register_tensor', null, [\n                    'number',\n                    'number',\n                    'number',\n                ]),\n                disposeData: module.cwrap('dispose_data', voidReturnType, ['number']),\n                dispose: module.cwrap('dispose', voidReturnType, []),\n            };\n            resolve({ wasm: module });\n        });\n    });\n}\nfunction typedArrayFromBuffer(buffer, dtype) {\n    switch (dtype) {\n        case 'float32':\n            return new Float32Array(buffer);\n        case 'int32':\n            return new Int32Array(buffer);\n        case 'bool':\n            return new Uint8Array(buffer);\n        default:\n            throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\nconst wasmBinaryNames = [\n    'tfjs-backend-wasm.wasm', 'tfjs-backend-wasm-simd.wasm',\n    'tfjs-backend-wasm-threaded-simd.wasm'\n];\nlet wasmPath = null;\nlet wasmPathPrefix = null;\nlet wasmFileMap = {};\nlet initAborted = false;\nlet customFetch = false;\n/**\n * @deprecated Use `setWasmPaths` instead.\n * Sets the path to the `.wasm` file which will be fetched when the wasm\n * backend is initialized. See\n * https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\n * for more details.\n * @param path wasm file path or url\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\nexport function setWasmPath(path, usePlatformFetch = false) {\n    deprecationWarn('setWasmPath has been deprecated in favor of setWasmPaths and' +\n        ' will be removed in a future release.');\n    if (initAborted) {\n        throw new Error('The WASM backend was already initialized. Make sure you call ' +\n            '`setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`');\n    }\n    wasmPath = path;\n    customFetch = usePlatformFetch;\n}\n/**\n * Configures the locations of the WASM binaries.\n *\n * ```js\n * setWasmPaths({\n *  'tfjs-backend-wasm.wasm': 'renamed.wasm',\n *  'tfjs-backend-wasm-simd.wasm': 'renamed-simd.wasm',\n *  'tfjs-backend-wasm-threaded-simd.wasm': 'renamed-threaded-simd.wasm'\n * });\n * tf.setBackend('wasm');\n * ```\n *\n * @param prefixOrFileMap This can be either a string or object:\n *  - (string) The path to the directory where the WASM binaries are located.\n *     Note that this prefix will be used to load each binary (vanilla,\n *     SIMD-enabled, threading-enabled, etc.).\n *  - (object) Mapping from names of WASM binaries to custom\n *     full paths specifying the locations of those binaries. This is useful if\n *     your WASM binaries are not all located in the same directory, or if your\n *     WASM binaries have been renamed.\n * @param usePlatformFetch optional boolean to use platform fetch to download\n *     the wasm file, default to false.\n *\n * @doc {heading: 'Environment', namespace: 'wasm'}\n */\nexport function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {\n    if (initAborted) {\n        throw new Error('The WASM backend was already initialized. Make sure you call ' +\n            '`setWasmPaths()` before you call `tf.setBackend()` or ' +\n            '`tf.ready()`');\n    }\n    if (typeof prefixOrFileMap === 'string') {\n        wasmPathPrefix = prefixOrFileMap;\n    }\n    else {\n        wasmFileMap = prefixOrFileMap;\n        const missingPaths = wasmBinaryNames.filter(name => wasmFileMap[name] == null);\n        if (missingPaths.length > 0) {\n            throw new Error(`There were no entries found for the following binaries: ` +\n                `${missingPaths.join(',')}. Please either call setWasmPaths with a ` +\n                `map providing a path for each binary, or with a string indicating ` +\n                `the directory where all the binaries can be found.`);\n        }\n    }\n    customFetch = usePlatformFetch;\n}\n/** Used in unit tests. */\nexport function resetWasmPath() {\n    wasmPath = null;\n    wasmPathPrefix = null;\n    wasmFileMap = {};\n    customFetch = false;\n    initAborted = false;\n}\nlet threadsCount = -1;\nlet actualThreadsCount = -1;\n/**\n * Sets the number of threads that will be used by XNNPACK to create\n * threadpool (default to the number of logical CPU cores).\n *\n * This must be called before calling `tf.setBackend('wasm')`.\n */\nexport function setThreadsCount(numThreads) {\n    threadsCount = numThreads;\n}\n/**\n * Gets the actual threads count that is used by XNNPACK.\n *\n * It is set after the backend is intialized.\n */\nexport function getThreadsCount() {\n    if (actualThreadsCount === -1) {\n        throw new Error(`WASM backend not initialized.`);\n    }\n    return actualThreadsCount;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}