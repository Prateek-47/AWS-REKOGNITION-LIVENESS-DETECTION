{"ast":null,"code":"import { __assign, __read } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu; // Check if geofenceId is valid\n\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : ''; // Validate LinearRing size, must be at least 4 points\n\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  } // Validate all coordinates are valid, error with which ones are bad\n\n\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  } // Validate first and last coordinates are the same\n\n\n  var _a = __read(linearRing[0], 2),\n      lngA = _a[0],\n      latA = _a[1];\n\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n      lngB = _b[0],\n      latB = _b[1];\n\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId); // Validate geofenceId is unique\n\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    } // Validate geometry exists\n\n\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n\n    var geometry = geofence.geometry; // Validate polygon exists\n\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n\n    var polygon = geometry.polygon; // Validate polygon length and structure\n\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    } // Validate LinearRing length, structure, and coordinates\n\n\n    var _a = __read(polygon, 1),\n        linearRing = _a[0];\n\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n  var locationServiceModifiedInput = __assign({}, locationServiceInput);\n\n  locationServiceModifiedInput.FilterCountries = options.countries;\n  locationServiceModifiedInput.MaxResults = options.maxResults;\n\n  if (options.searchIndexName) {\n    locationServiceModifiedInput.IndexName = options.searchIndexName;\n  }\n\n  if (options['biasPosition'] && options['searchAreaConstraints']) {\n    throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n  }\n\n  if (options['biasPosition']) {\n    locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n  }\n\n  if (options['searchAreaConstraints']) {\n    locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n  }\n\n  return locationServiceModifiedInput;\n}","map":{"version":3,"names":["__assign","__read","booleanClockwise","validateCoordinates","lng","lat","Number","isFinite","Error","validateGeofenceId","geofenceId","geofenceIdRegex","test","validateLinearRing","linearRing","errorPrefix","length","badCoordinates","forEach","coordinates","error","push","message","JSON","stringify","_a","lngA","latA","_b","lngB","latB","validatePolygon","polygon","Array","isArray","verticesCount","reduce","prev","validateGeofencesInput","geofences","geofenceIds","geofence","geometry","includes","mapSearchOptions","options","locationServiceInput","locationServiceModifiedInput","FilterCountries","countries","MaxResults","maxResults","searchIndexName","IndexName","BiasPosition","FilterBBox"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/geo/lib-esm/util.js"],"sourcesContent":["import { __assign, __read } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n    if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n        throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n    }\n    if (lat < -90 || 90 < lat) {\n        throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n    }\n    else if (lng < -180 || 180 < lng) {\n        throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n    }\n}\nexport function validateGeofenceId(geofenceId) {\n    var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n    // Check if geofenceId is valid\n    if (!geofenceIdRegex.test(geofenceId)) {\n        throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n    }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    // Validate LinearRing size, must be at least 4 points\n    if (linearRing.length < 4) {\n        throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n    }\n    // Validate all coordinates are valid, error with which ones are bad\n    var badCoordinates = [];\n    linearRing.forEach(function (coordinates) {\n        try {\n            validateCoordinates(coordinates[0], coordinates[1]);\n        }\n        catch (error) {\n            badCoordinates.push({ coordinates: coordinates, error: error.message });\n        }\n    });\n    if (badCoordinates.length > 0) {\n        throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n    }\n    // Validate first and last coordinates are the same\n    var _a = __read(linearRing[0], 2), lngA = _a[0], latA = _a[1];\n    var _b = __read(linearRing[linearRing.length - 1], 2), lngB = _b[0], latB = _b[1];\n    if (lngA !== lngB || latA !== latB) {\n        throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n    }\n    if (booleanClockwise(linearRing)) {\n        throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n    }\n}\nexport function validatePolygon(polygon, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    if (!Array.isArray(polygon)) {\n        throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n    }\n    if (polygon.length < 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n    }\n    if (polygon.length > 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n    }\n    var verticesCount = polygon.reduce(function (prev, linearRing) { return prev + linearRing.length; }, 0);\n    if (verticesCount > 1000) {\n        throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n    }\n    polygon.forEach(function (linearRing) {\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function validateGeofencesInput(geofences) {\n    var geofenceIds = {};\n    geofences.forEach(function (geofence) {\n        // verify all required properties are present\n        // Validate geofenceId exists\n        if (!geofence.geofenceId) {\n            throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n        }\n        var geofenceId = geofence.geofenceId;\n        validateGeofenceId(geofenceId);\n        // Validate geofenceId is unique\n        if (geofenceIds[geofenceId]) {\n            throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n        }\n        else {\n            geofenceIds[geofenceId] = true;\n        }\n        // Validate geometry exists\n        if (!geofence.geometry) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n        }\n        var geometry = geofence.geometry;\n        // Validate polygon exists\n        if (!geometry.polygon) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n        }\n        var polygon = geometry.polygon;\n        // Validate polygon length and structure\n        try {\n            validatePolygon(polygon, geofenceId);\n        }\n        catch (error) {\n            if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n                throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n            }\n        }\n        // Validate LinearRing length, structure, and coordinates\n        var _a = __read(polygon, 1), linearRing = _a[0];\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n    var locationServiceModifiedInput = __assign({}, locationServiceInput);\n    locationServiceModifiedInput.FilterCountries = options.countries;\n    locationServiceModifiedInput.MaxResults = options.maxResults;\n    if (options.searchIndexName) {\n        locationServiceModifiedInput.IndexName = options.searchIndexName;\n    }\n    if (options['biasPosition'] && options['searchAreaConstraints']) {\n        throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n    }\n    if (options['biasPosition']) {\n        locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n    }\n    if (options['searchAreaConstraints']) {\n        locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n    }\n    return locationServiceModifiedInput;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}