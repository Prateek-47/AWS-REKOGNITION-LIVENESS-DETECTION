{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n  const numIndices = indices.length;\n\n  if (numIndices !== segmentIds.length) {\n    throw new Error(`segmentIds and indices should have same size.`);\n  } // Flatten the array to two dimensions\n\n\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1]; // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1); // Output array is initialized with the value 0 by default.\n\n  const output = util.getArrayFromDType(inputDType, outputLength); // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  let start = 0,\n      end = 1; // Index from which the output is not initialized.\n\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      } // We have a new segment here.  Verify that the segment ids are growing.\n\n\n      if (outIndex >= nextIndex) {\n        throw new Error(`segment ids are not increasing`);\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);\n    } // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n\n\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${inputFlat[0]})`);\n      }\n\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n\n    if (end > numIndices) {\n      break;\n    }\n  } // Fill the gap at the end with the default value.\n\n\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}","map":{"version":3,"names":["util","sparseSegmentReductionImpl","input","inputShape","inputDType","indices","segmentIds","isMean","defaultValue","numIndices","length","Error","inputFlat","numCol","lastSegmentIdPlusOne","outputRows","outputShape","slice","outputLength","reduce","product","value","output","getArrayFromDType","fill","start","end","uninitializedIndex","outIndex","nextIndex","i","index","j"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n    const numIndices = indices.length;\n    if (numIndices !== segmentIds.length) {\n        throw new Error(`segmentIds and indices should have same size.`);\n    }\n    // Flatten the array to two dimensions\n    const inputFlat = [inputShape[0], input.length / inputShape[0]];\n    const numCol = inputFlat[1];\n    // Note that the current implementation assumes that segmentIds values are\n    // sorted.\n    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n    const outputRows = lastSegmentIdPlusOne;\n    if (outputRows < 0) {\n        throw new Error(`segment ids must be >= 0`);\n    }\n    const outputShape = inputShape.slice();\n    outputShape[0] = outputRows;\n    const outputLength = outputShape.reduce((product, value) => product * value, 1);\n    // Output array is initialized with the value 0 by default.\n    const output = util.getArrayFromDType(inputDType, outputLength);\n    // Note that we do not initialize the output buffer with a default value, so\n    // we need to explicitly set missing indices to the default value.\n    if (numIndices === 0) {\n        if (outputRows > 0) {\n            output.fill(defaultValue);\n        }\n        return [output, outputShape];\n    }\n    if (outputRows <= 0) {\n        throw new Error(`segment ids must be >= 0`);\n    }\n    let start = 0, end = 1;\n    // Index from which the output is not initialized.\n    let uninitializedIndex = 0;\n    let outIndex = segmentIds[start];\n    while (true) {\n        // We initialize nextIndex to 0 to avoid may be uninitialized warning\n        let nextIndex = 0;\n        if (end < numIndices) {\n            nextIndex = segmentIds[end];\n            if (outIndex === nextIndex) {\n                ++end;\n                continue;\n            }\n            // We have a new segment here.  Verify that the segment ids are growing.\n            if (outIndex >= nextIndex) {\n                throw new Error(`segment ids are not increasing`);\n            }\n        }\n        if (outIndex < 0 || outIndex >= outputRows) {\n            throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);\n        }\n        // If there is a gap between two indices, we need to set that gap to the\n        // default value.\n        if (outIndex > uninitializedIndex) {\n            output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n        }\n        for (let i = start; i < end; ++i) {\n            const index = indices[i];\n            if (index < 0 || index >= inputFlat[0]) {\n                throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${inputFlat[0]})`);\n            }\n            for (let j = 0; j < numCol; j++) {\n                output[outIndex * numCol + j] += input[index * numCol + j];\n            }\n        }\n        if (isMean) {\n            for (let j = 0; j < numCol; j++) {\n                output[outIndex * numCol + j] /= end - start;\n            }\n        }\n        start = end;\n        ++end;\n        uninitializedIndex = outIndex + 1;\n        outIndex = nextIndex;\n        if (end > numIndices) {\n            break;\n        }\n    }\n    // Fill the gap at the end with the default value.\n    if (uninitializedIndex < outputRows) {\n        output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n    }\n    return [output, outputShape];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}