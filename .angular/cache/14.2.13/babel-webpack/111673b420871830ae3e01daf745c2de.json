{"ast":null,"code":"export function map(arg0, arg1, arg2) {\n  let target;\n  let filter;\n  let instructions;\n\n  if (typeof arg1 === \"undefined\" && typeof arg2 === \"undefined\") {\n    target = {};\n    instructions = arg0;\n  } else {\n    target = arg0;\n\n    if (typeof arg1 === \"function\") {\n      filter = arg1;\n      instructions = arg2;\n      return mapWithFilter(target, filter, instructions);\n    } else {\n      instructions = arg1;\n    }\n  }\n\n  for (const key of Object.keys(instructions)) {\n    if (!Array.isArray(instructions[key])) {\n      target[key] = instructions[key];\n      continue;\n    }\n\n    applyInstruction(target, null, instructions, key);\n  }\n\n  return target;\n}\nexport const convertMap = target => {\n  const output = {};\n\n  for (const [k, v] of Object.entries(target || {})) {\n    output[k] = [, v];\n  }\n\n  return output;\n};\nexport const take = (source, instructions) => {\n  const out = {};\n\n  for (const key in instructions) {\n    applyInstruction(out, source, instructions, key);\n  }\n\n  return out;\n};\n\nconst mapWithFilter = (target, filter, instructions) => {\n  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {\n    if (Array.isArray(value)) {\n      _instructions[key] = value;\n    } else {\n      if (typeof value === \"function\") {\n        _instructions[key] = [filter, value()];\n      } else {\n        _instructions[key] = [filter, value];\n      }\n    }\n\n    return _instructions;\n  }, {}));\n};\n\nconst applyInstruction = (target, source, instructions, targetKey) => {\n  if (source !== null) {\n    let instruction = instructions[targetKey];\n\n    if (typeof instruction === \"function\") {\n      instruction = [, instruction];\n    }\n\n    const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;\n\n    if (typeof filter === \"function\" && filter(source[sourceKey]) || typeof filter !== \"function\" && !!filter) {\n      target[targetKey] = valueFn(source[sourceKey]);\n    }\n\n    return;\n  }\n\n  let [filter, value] = instructions[targetKey];\n\n  if (typeof value === \"function\") {\n    let _value;\n\n    const defaultFilterPassed = filter === undefined && (_value = value()) != null;\n    const customFilterPassed = typeof filter === \"function\" && !!filter(void 0) || typeof filter !== \"function\" && !!filter;\n\n    if (defaultFilterPassed) {\n      target[targetKey] = _value;\n    } else if (customFilterPassed) {\n      target[targetKey] = value();\n    }\n  } else {\n    const defaultFilterPassed = filter === undefined && value != null;\n    const customFilterPassed = typeof filter === \"function\" && !!filter(value) || typeof filter !== \"function\" && !!filter;\n\n    if (defaultFilterPassed || customFilterPassed) {\n      target[targetKey] = value;\n    }\n  }\n};\n\nconst nonNullish = _ => _ != null;\n\nconst pass = _ => _;","map":{"version":3,"names":["map","arg0","arg1","arg2","target","filter","instructions","mapWithFilter","key","Object","keys","Array","isArray","applyInstruction","convertMap","output","k","v","entries","take","source","out","reduce","_instructions","value","targetKey","instruction","nonNullish","valueFn","pass","sourceKey","_value","defaultFilterPassed","undefined","customFilterPassed","_"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/smithy-client/dist-es/object-mapping.js"],"sourcesContent":["export function map(arg0, arg1, arg2) {\n    let target;\n    let filter;\n    let instructions;\n    if (typeof arg1 === \"undefined\" && typeof arg2 === \"undefined\") {\n        target = {};\n        instructions = arg0;\n    }\n    else {\n        target = arg0;\n        if (typeof arg1 === \"function\") {\n            filter = arg1;\n            instructions = arg2;\n            return mapWithFilter(target, filter, instructions);\n        }\n        else {\n            instructions = arg1;\n        }\n    }\n    for (const key of Object.keys(instructions)) {\n        if (!Array.isArray(instructions[key])) {\n            target[key] = instructions[key];\n            continue;\n        }\n        applyInstruction(target, null, instructions, key);\n    }\n    return target;\n}\nexport const convertMap = (target) => {\n    const output = {};\n    for (const [k, v] of Object.entries(target || {})) {\n        output[k] = [, v];\n    }\n    return output;\n};\nexport const take = (source, instructions) => {\n    const out = {};\n    for (const key in instructions) {\n        applyInstruction(out, source, instructions, key);\n    }\n    return out;\n};\nconst mapWithFilter = (target, filter, instructions) => {\n    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {\n        if (Array.isArray(value)) {\n            _instructions[key] = value;\n        }\n        else {\n            if (typeof value === \"function\") {\n                _instructions[key] = [filter, value()];\n            }\n            else {\n                _instructions[key] = [filter, value];\n            }\n        }\n        return _instructions;\n    }, {}));\n};\nconst applyInstruction = (target, source, instructions, targetKey) => {\n    if (source !== null) {\n        let instruction = instructions[targetKey];\n        if (typeof instruction === \"function\") {\n            instruction = [, instruction];\n        }\n        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;\n        if ((typeof filter === \"function\" && filter(source[sourceKey])) || (typeof filter !== \"function\" && !!filter)) {\n            target[targetKey] = valueFn(source[sourceKey]);\n        }\n        return;\n    }\n    let [filter, value] = instructions[targetKey];\n    if (typeof value === \"function\") {\n        let _value;\n        const defaultFilterPassed = filter === undefined && (_value = value()) != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(void 0)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed) {\n            target[targetKey] = _value;\n        }\n        else if (customFilterPassed) {\n            target[targetKey] = value();\n        }\n    }\n    else {\n        const defaultFilterPassed = filter === undefined && value != null;\n        const customFilterPassed = (typeof filter === \"function\" && !!filter(value)) || (typeof filter !== \"function\" && !!filter);\n        if (defaultFilterPassed || customFilterPassed) {\n            target[targetKey] = value;\n        }\n    }\n};\nconst nonNullish = (_) => _ != null;\nconst pass = (_) => _;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}