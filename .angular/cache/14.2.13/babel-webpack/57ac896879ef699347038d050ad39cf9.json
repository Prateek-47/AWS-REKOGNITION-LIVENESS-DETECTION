{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __read } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Observable from 'zen-observable-ts';\nimport { GraphQLError } from 'graphql';\nimport * as url from 'url';\nimport { v4 as uuid } from 'uuid';\nimport { Buffer } from 'buffer';\nimport { Logger, Credentials, Signer, Hub, USER_AGENT_HEADER, jitteredExponentialRetry, NonRetryableError, isNonRetryableError, getAmplifyUserAgent } from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport { Auth } from '@aws-amplify/auth';\nimport { AbstractPubSubProvider } from '../PubSubProvider';\nimport { CONTROL_MSG, ConnectionState } from '../../types/PubSub';\nimport { AMPLIFY_SYMBOL, AWS_APPSYNC_REALTIME_HEADERS, CONNECTION_INIT_TIMEOUT, DEFAULT_KEEP_ALIVE_TIMEOUT, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, MAX_DELAY_MS, MESSAGE_TYPES, NON_RETRYABLE_CODES, SOCKET_STATUS, START_ACK_TIMEOUT, SUBSCRIPTION_STATUS, CONNECTION_STATE_CHANGE } from '../constants';\nimport { ConnectionStateMonitor, CONNECTION_CHANGE } from '../../utils/ConnectionStateMonitor';\nimport { ReconnectEvent, ReconnectionMonitor } from '../../utils/ReconnectionMonitor';\nvar logger = new Logger('AWSAppSyncRealTimeProvider');\n\nvar dispatchApiEvent = function (event, data, message) {\n  Hub.dispatch('api', {\n    event: event,\n    data: data,\n    message: message\n  }, 'PubSub', AMPLIFY_SYMBOL);\n};\n\nvar standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync\\-api\\.\\w{2}(?:(?:\\-\\w{2,})+)\\-\\d\\.amazonaws.com(?:\\.cn)?\\/graphql$/i;\nvar customDomainPath = '/realtime';\n\nvar AWSAppSyncRealTimeProvider =\n/** @class */\nfunction (_super) {\n  __extends(AWSAppSyncRealTimeProvider, _super);\n\n  function AWSAppSyncRealTimeProvider(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, options) || this;\n\n    _this.socketStatus = SOCKET_STATUS.CLOSED;\n    _this.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n    _this.subscriptionObserverMap = new Map();\n    _this.promiseArray = [];\n    _this.connectionStateMonitor = new ConnectionStateMonitor();\n    _this.reconnectionMonitor = new ReconnectionMonitor(); // Monitor the connection state and pass changes along to Hub\n\n    _this.connectionStateMonitorSubscription = _this.connectionStateMonitor.connectionStateObservable.subscribe(function (connectionState) {\n      dispatchApiEvent(CONNECTION_STATE_CHANGE, {\n        provider: _this,\n        connectionState: connectionState\n      }, \"Connection state is \" + connectionState);\n      _this.connectionState = connectionState; // Trigger START_RECONNECT when the connection is disrupted\n\n      if (connectionState === ConnectionState.ConnectionDisrupted) {\n        _this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n      } // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n      //   ConnectionDisrupted or Connecting\n\n\n      if ([ConnectionState.Connected, ConnectionState.ConnectedPendingDisconnect, ConnectionState.ConnectedPendingKeepAlive, ConnectionState.ConnectedPendingNetwork, ConnectionState.ConnectionDisruptedPendingNetwork, ConnectionState.Disconnected].includes(connectionState)) {\n        _this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n      }\n    });\n    return _this;\n  }\n  /**\n   * Mark the socket closed and release all active listeners\n   */\n\n\n  AWSAppSyncRealTimeProvider.prototype.close = function () {\n    // Mark the socket closed both in status and the connection monitor\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED); // Turn off the subscription monitor Hub publishing\n\n    this.connectionStateMonitorSubscription.unsubscribe(); // Complete all reconnect observers\n\n    this.reconnectionMonitor.close();\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.getNewWebSocket = function (url, protocol) {\n    return new WebSocket(url, protocol);\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.getProviderName = function () {\n    return 'AWSAppSyncRealTimeProvider';\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.newClient = function () {\n    throw new Error('Not used here');\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.publish = function (_topics, _msg, _options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        throw new Error('Operation not supported');\n      });\n    });\n  }; // Check if url matches standard domain pattern\n\n\n  AWSAppSyncRealTimeProvider.prototype.isCustomDomain = function (url) {\n    return url.match(standardDomainPattern) === null;\n  };\n\n  AWSAppSyncRealTimeProvider.prototype.subscribe = function (_topics, options, customUserAgentDetails) {\n    var _this = this;\n\n    var appSyncGraphqlEndpoint = options === null || options === void 0 ? void 0 : options.appSyncGraphqlEndpoint;\n    return new Observable(function (observer) {\n      if (!options || !appSyncGraphqlEndpoint) {\n        observer.error({\n          errors: [__assign({}, new GraphQLError(\"Subscribe only available for AWS AppSync endpoint\"))]\n        });\n        observer.complete();\n      } else {\n        var subscriptionStartActive_1 = false;\n        var subscriptionId_1 = uuid();\n\n        var startSubscription_1 = function () {\n          if (!subscriptionStartActive_1) {\n            subscriptionStartActive_1 = true;\n\n            var startSubscriptionPromise = _this._startSubscriptionWithAWSAppSyncRealTime({\n              options: options,\n              observer: observer,\n              subscriptionId: subscriptionId_1,\n              customUserAgentDetails: customUserAgentDetails\n            }).catch(function (err) {\n              logger.debug(CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR + \": \" + err);\n\n              _this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            });\n\n            startSubscriptionPromise.finally(function () {\n              subscriptionStartActive_1 = false;\n            });\n          }\n        };\n\n        var reconnectSubscription_1; // Add an observable to the reconnection list to manage reconnection for this subscription\n\n        reconnectSubscription_1 = new Observable(function (observer) {\n          _this.reconnectionMonitor.addObserver(observer);\n        }).subscribe(function () {\n          startSubscription_1();\n        });\n        startSubscription_1();\n        return function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var subscriptionState, err_1;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  // Cleanup reconnection subscription\n                  reconnectSubscription_1 === null || reconnectSubscription_1 === void 0 ? void 0 : reconnectSubscription_1.unsubscribe();\n                  _a.label = 1;\n\n                case 1:\n                  _a.trys.push([1, 3, 4, 5]); // Waiting that subscription has been connected before trying to unsubscribe\n\n\n                  return [4\n                  /*yield*/\n                  , this._waitForSubscriptionToBeConnected(subscriptionId_1)];\n\n                case 2:\n                  // Waiting that subscription has been connected before trying to unsubscribe\n                  _a.sent();\n\n                  subscriptionState = (this.subscriptionObserverMap.get(subscriptionId_1) || {}).subscriptionState;\n\n                  if (!subscriptionState) {\n                    // subscription already unsubscribed\n                    return [2\n                    /*return*/\n                    ];\n                  }\n\n                  if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n                    this._sendUnsubscriptionMessage(subscriptionId_1);\n                  } else {\n                    throw new Error('Subscription never connected');\n                  }\n\n                  return [3\n                  /*break*/\n                  , 5];\n\n                case 3:\n                  err_1 = _a.sent();\n                  logger.debug(\"Error while unsubscribing \" + err_1);\n                  return [3\n                  /*break*/\n                  , 5];\n\n                case 4:\n                  this._removeSubscriptionObserver(subscriptionId_1);\n\n                  return [7\n                  /*endfinally*/\n                  ];\n\n                case 5:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        };\n      }\n    });\n  };\n\n  Object.defineProperty(AWSAppSyncRealTimeProvider.prototype, \"isSSLEnabled\", {\n    get: function () {\n      return !this.options['aws_appsync_dangerously_connect_to_http_endpoint_for_testing'];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSAppSyncRealTimeProvider.prototype._startSubscriptionWithAWSAppSyncRealTime = function (_a) {\n    var options = _a.options,\n        observer = _a.observer,\n        subscriptionId = _a.subscriptionId,\n        customUserAgentDetails = _a.customUserAgentDetails;\n\n    var _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var appSyncGraphqlEndpoint, authenticationType, query, variables, apiKey, region, _c, graphql_headers, _d, additionalHeaders, subscriptionState, data, dataString, headerObj, _e, _f, subscriptionMessage, stringToAWSRealTime, err_2, _g, subscriptionFailedCallback, subscriptionReadyCallback;\n\n      var _h;\n\n      var _this = this;\n\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            appSyncGraphqlEndpoint = options.appSyncGraphqlEndpoint, authenticationType = options.authenticationType, query = options.query, variables = options.variables, apiKey = options.apiKey, region = options.region, _c = options.graphql_headers, graphql_headers = _c === void 0 ? function () {\n              return {};\n            } : _c, _d = options.additionalHeaders, additionalHeaders = _d === void 0 ? {} : _d;\n            subscriptionState = SUBSCRIPTION_STATUS.PENDING;\n            data = {\n              query: query,\n              variables: variables\n            }; // Having a subscription id map will make it simple to forward messages received\n\n            this.subscriptionObserverMap.set(subscriptionId, {\n              observer: observer,\n              query: query !== null && query !== void 0 ? query : '',\n              variables: variables !== null && variables !== void 0 ? variables : {},\n              subscriptionState: subscriptionState,\n              startAckTimeoutId: undefined\n            });\n            dataString = JSON.stringify(data);\n            _e = [{}];\n            return [4\n            /*yield*/\n            , this._awsRealTimeHeaderBasedAuth({\n              apiKey: apiKey,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              authenticationType: authenticationType,\n              payload: dataString,\n              canonicalUri: '',\n              region: region,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 1:\n            _f = [__assign.apply(void 0, _e.concat([_j.sent()]))];\n            return [4\n            /*yield*/\n            , graphql_headers()];\n\n          case 2:\n            headerObj = __assign.apply(void 0, [__assign.apply(void 0, [__assign.apply(void 0, _f.concat([_j.sent()])), additionalHeaders]), (_h = {}, _h[USER_AGENT_HEADER] = getAmplifyUserAgent(customUserAgentDetails), _h)]);\n            subscriptionMessage = {\n              id: subscriptionId,\n              payload: {\n                data: dataString,\n                extensions: {\n                  authorization: __assign({}, headerObj)\n                }\n              },\n              type: MESSAGE_TYPES.GQL_START\n            };\n            stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n            _j.label = 3;\n\n          case 3:\n            _j.trys.push([3, 5,, 6]);\n\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n            return [4\n            /*yield*/\n            , this._initializeWebSocketConnection({\n              apiKey: apiKey,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              authenticationType: authenticationType,\n              region: region,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 4:\n            _j.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_2 = _j.sent();\n\n            this._logStartSubscriptionError(subscriptionId, observer, err_2);\n\n            return [2\n            /*return*/\n            ];\n\n          case 6:\n            _g = (_b = this.subscriptionObserverMap.get(subscriptionId)) !== null && _b !== void 0 ? _b : {}, subscriptionFailedCallback = _g.subscriptionFailedCallback, subscriptionReadyCallback = _g.subscriptionReadyCallback; // This must be done before sending the message in order to be listening immediately\n\n            this.subscriptionObserverMap.set(subscriptionId, {\n              observer: observer,\n              subscriptionState: subscriptionState,\n              query: query !== null && query !== void 0 ? query : '',\n              variables: variables !== null && variables !== void 0 ? variables : {},\n              subscriptionReadyCallback: subscriptionReadyCallback,\n              subscriptionFailedCallback: subscriptionFailedCallback,\n              startAckTimeoutId: setTimeout(function () {\n                _this._timeoutStartSubscriptionAck.call(_this, subscriptionId);\n              }, START_ACK_TIMEOUT)\n            });\n\n            if (this.awsRealTimeSocket) {\n              this.awsRealTimeSocket.send(stringToAWSRealTime);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Log logic for start subscription failures\n\n\n  AWSAppSyncRealTimeProvider.prototype._logStartSubscriptionError = function (subscriptionId, observer, err) {\n    var _a;\n\n    logger.debug({\n      err: err\n    });\n    var message = String((_a = err.message) !== null && _a !== void 0 ? _a : ''); // Resolving to give the state observer time to propogate the update\n\n    Promise.resolve(this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED)); // Capture the error only when the network didn't cause disruption\n\n    if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n      // When the error is non-retriable, error out the observable\n      if (isNonRetryableError(err)) {\n        observer.error({\n          errors: [__assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + message))]\n        });\n      } else {\n        logger.debug(CONTROL_MSG.CONNECTION_FAILED + \": \" + message);\n      }\n\n      var subscriptionFailedCallback = (this.subscriptionObserverMap.get(subscriptionId) || {}).subscriptionFailedCallback; // Notify concurrent unsubscription\n\n      if (typeof subscriptionFailedCallback === 'function') {\n        subscriptionFailedCallback();\n      }\n    }\n  }; // Waiting that subscription has been connected before trying to unsubscribe\n\n\n  AWSAppSyncRealTimeProvider.prototype._waitForSubscriptionToBeConnected = function (subscriptionId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var subscriptionObserver, subscriptionState;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n\n        if (subscriptionObserver) {\n          subscriptionState = subscriptionObserver.subscriptionState; // This in case unsubscribe is invoked before sending start subscription message\n\n          if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n            return [2\n            /*return*/\n            , new Promise(function (res, rej) {\n              var observer = subscriptionObserver.observer,\n                  subscriptionState = subscriptionObserver.subscriptionState,\n                  variables = subscriptionObserver.variables,\n                  query = subscriptionObserver.query;\n\n              _this.subscriptionObserverMap.set(subscriptionId, {\n                observer: observer,\n                subscriptionState: subscriptionState,\n                variables: variables,\n                query: query,\n                subscriptionReadyCallback: res,\n                subscriptionFailedCallback: rej\n              });\n            })];\n          }\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._sendUnsubscriptionMessage = function (subscriptionId) {\n    try {\n      if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN && this.socketStatus === SOCKET_STATUS.READY) {\n        // Preparing unsubscribe message to stop receiving messages for that subscription\n        var unsubscribeMessage = {\n          id: subscriptionId,\n          type: MESSAGE_TYPES.GQL_STOP\n        };\n        var stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n        this.awsRealTimeSocket.send(stringToAWSRealTime);\n      }\n    } catch (err) {\n      // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n      logger.debug({\n        err: err\n      });\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._removeSubscriptionObserver = function (subscriptionId) {\n    this.subscriptionObserverMap.delete(subscriptionId); // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n\n    setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._closeSocketIfRequired = function () {\n    if (this.subscriptionObserverMap.size > 0) {\n      // Active subscriptions on the WebSocket\n      return;\n    }\n\n    if (!this.awsRealTimeSocket) {\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      return;\n    }\n\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n\n    if (this.awsRealTimeSocket.bufferedAmount > 0) {\n      // Still data on the WebSocket\n      setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    } else {\n      logger.debug('closing WebSocket...');\n\n      if (this.keepAliveTimeoutId) {\n        clearTimeout(this.keepAliveTimeoutId);\n      }\n\n      if (this.keepAliveAlertTimeoutId) {\n        clearTimeout(this.keepAliveAlertTimeoutId);\n      }\n\n      var tempSocket = this.awsRealTimeSocket; // Cleaning callbacks to avoid race condition, socket still exists\n\n      tempSocket.onclose = null;\n      tempSocket.onerror = null;\n      tempSocket.close(1000);\n      this.awsRealTimeSocket = undefined;\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._handleIncomingSubscriptionMessage = function (message) {\n    var _this = this;\n\n    if (typeof message.data !== 'string') {\n      return;\n    }\n\n    logger.debug(\"subscription message from AWS AppSync RealTime: \" + message.data);\n\n    var _a = JSON.parse(String(message.data)),\n        _b = _a.id,\n        id = _b === void 0 ? '' : _b,\n        payload = _a.payload,\n        type = _a.type;\n\n    var _c = this.subscriptionObserverMap.get(id) || {},\n        _d = _c.observer,\n        observer = _d === void 0 ? null : _d,\n        _e = _c.query,\n        query = _e === void 0 ? '' : _e,\n        _f = _c.variables,\n        variables = _f === void 0 ? {} : _f,\n        startAckTimeoutId = _c.startAckTimeoutId,\n        subscriptionReadyCallback = _c.subscriptionReadyCallback,\n        subscriptionFailedCallback = _c.subscriptionFailedCallback;\n\n    logger.debug({\n      id: id,\n      observer: observer,\n      query: query,\n      variables: variables\n    });\n\n    if (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n      if (observer) {\n        observer.next(payload);\n      } else {\n        logger.debug(\"observer not found for id: \" + id);\n      }\n\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_START_ACK) {\n      logger.debug(\"subscription ready for \" + JSON.stringify({\n        query: query,\n        variables: variables\n      }));\n\n      if (typeof subscriptionReadyCallback === 'function') {\n        subscriptionReadyCallback();\n      }\n\n      if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n      dispatchApiEvent(CONTROL_MSG.SUBSCRIPTION_ACK, {\n        query: query,\n        variables: variables\n      }, 'Connection established for subscription');\n      var subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer: observer,\n          query: query,\n          variables: variables,\n          startAckTimeoutId: undefined,\n          subscriptionState: subscriptionState,\n          subscriptionReadyCallback: subscriptionReadyCallback,\n          subscriptionFailedCallback: subscriptionFailedCallback\n        });\n      }\n\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n      if (this.keepAliveTimeoutId) clearTimeout(this.keepAliveTimeoutId);\n      if (this.keepAliveAlertTimeoutId) clearTimeout(this.keepAliveAlertTimeoutId);\n      this.keepAliveTimeoutId = setTimeout(function () {\n        return _this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT);\n      }, this.keepAliveTimeout);\n      this.keepAliveAlertTimeoutId = setTimeout(function () {\n        _this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n      }, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT);\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n      return;\n    }\n\n    if (type === MESSAGE_TYPES.GQL_ERROR) {\n      var subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer: observer,\n          query: query,\n          variables: variables,\n          startAckTimeoutId: startAckTimeoutId,\n          subscriptionReadyCallback: subscriptionReadyCallback,\n          subscriptionFailedCallback: subscriptionFailedCallback,\n          subscriptionState: subscriptionState\n        });\n        logger.debug(CONTROL_MSG.CONNECTION_FAILED + \": \" + JSON.stringify(payload));\n        observer.error({\n          errors: [__assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + JSON.stringify(payload)))]\n        });\n        if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n\n        if (typeof subscriptionFailedCallback === 'function') {\n          subscriptionFailedCallback();\n        }\n      }\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._errorDisconnect = function (msg) {\n    logger.debug(\"Disconnect error: \" + msg);\n\n    if (this.awsRealTimeSocket) {\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n      this.awsRealTimeSocket.close();\n    }\n\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._timeoutStartSubscriptionAck = function (subscriptionId) {\n    var subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n\n    if (subscriptionObserver) {\n      var observer = subscriptionObserver.observer,\n          query = subscriptionObserver.query,\n          variables = subscriptionObserver.variables;\n\n      if (!observer) {\n        return;\n      }\n\n      this.subscriptionObserverMap.set(subscriptionId, {\n        observer: observer,\n        query: query,\n        variables: variables,\n        subscriptionState: SUBSCRIPTION_STATUS.FAILED\n      });\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n      logger.debug('timeoutStartSubscription', JSON.stringify({\n        query: query,\n        variables: variables\n      }));\n    }\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeWebSocketConnection = function (_a) {\n    var _this = this;\n\n    var appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        authenticationType = _a.authenticationType,\n        apiKey = _a.apiKey,\n        region = _a.region,\n        additionalHeaders = _a.additionalHeaders;\n\n    if (this.socketStatus === SOCKET_STATUS.READY) {\n      return;\n    }\n\n    return new Promise(function (res, rej) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var payloadString, authHeader, headerString, headerQs, payloadQs, discoverableEndpoint, protocol, awsRealTimeUrl, err_3;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              this.promiseArray.push({\n                res: res,\n                rej: rej\n              });\n              if (!(this.socketStatus === SOCKET_STATUS.CLOSED)) return [3\n              /*break*/\n              , 5];\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 4,, 5]);\n\n              this.socketStatus = SOCKET_STATUS.CONNECTING;\n              payloadString = '{}';\n              return [4\n              /*yield*/\n              , this._awsRealTimeHeaderBasedAuth({\n                authenticationType: authenticationType,\n                payload: payloadString,\n                canonicalUri: '/connect',\n                apiKey: apiKey,\n                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                region: region,\n                additionalHeaders: additionalHeaders\n              })];\n\n            case 2:\n              authHeader = _a.sent();\n              headerString = authHeader ? JSON.stringify(authHeader) : '';\n              headerQs = Buffer.from(headerString).toString('base64');\n              payloadQs = Buffer.from(payloadString).toString('base64');\n              discoverableEndpoint = appSyncGraphqlEndpoint !== null && appSyncGraphqlEndpoint !== void 0 ? appSyncGraphqlEndpoint : '';\n\n              if (this.isCustomDomain(discoverableEndpoint)) {\n                discoverableEndpoint = discoverableEndpoint.concat(customDomainPath);\n              } else {\n                discoverableEndpoint = discoverableEndpoint.replace('appsync-api', 'appsync-realtime-api').replace('gogi-beta', 'grt-beta');\n              }\n\n              protocol = this.isSSLEnabled ? 'wss://' : 'ws://';\n              discoverableEndpoint = discoverableEndpoint.replace('https://', protocol).replace('http://', protocol);\n              awsRealTimeUrl = discoverableEndpoint + \"?header=\" + headerQs + \"&payload=\" + payloadQs;\n              return [4\n              /*yield*/\n              , this._initializeRetryableHandshake(awsRealTimeUrl)];\n\n            case 3:\n              _a.sent();\n\n              this.promiseArray.forEach(function (_a) {\n                var res = _a.res;\n                logger.debug('Notifying connection successful');\n                res();\n              });\n              this.socketStatus = SOCKET_STATUS.READY;\n              this.promiseArray = [];\n              return [3\n              /*break*/\n              , 5];\n\n            case 4:\n              err_3 = _a.sent();\n              logger.debug('Connection exited with', err_3);\n              this.promiseArray.forEach(function (_a) {\n                var rej = _a.rej;\n                return rej(err_3);\n              });\n              this.promiseArray = [];\n\n              if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n                this.awsRealTimeSocket.close(3001);\n              }\n\n              this.awsRealTimeSocket = undefined;\n              this.socketStatus = SOCKET_STATUS.CLOSED;\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeRetryableHandshake = function (awsRealTimeUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.debug(\"Initializaling retryable Handshake\");\n            return [4\n            /*yield*/\n            , jitteredExponentialRetry(this._initializeHandshake.bind(this), [awsRealTimeUrl], MAX_DELAY_MS)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._initializeHandshake = function (awsRealTimeUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4, _a, errorType, errorCode;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            logger.debug(\"Initializing handshake \" + awsRealTimeUrl);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , function () {\n              return new Promise(function (res, rej) {\n                var newSocket = _this.getNewWebSocket(awsRealTimeUrl, 'graphql-ws');\n\n                newSocket.onerror = function () {\n                  logger.debug(\"WebSocket connection error\");\n                };\n\n                newSocket.onclose = function () {\n                  rej(new Error('Connection handshake error'));\n                };\n\n                newSocket.onopen = function () {\n                  _this.awsRealTimeSocket = newSocket;\n                  return res();\n                };\n              });\n            }()];\n\n          case 2:\n            _b.sent(); // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n\n\n            return [4\n            /*yield*/\n            , function () {\n              return new Promise(function (res, rej) {\n                if (_this.awsRealTimeSocket) {\n                  var ackOk_1 = false;\n\n                  _this.awsRealTimeSocket.onerror = function (error) {\n                    logger.debug(\"WebSocket error \" + JSON.stringify(error));\n                  };\n\n                  _this.awsRealTimeSocket.onclose = function (event) {\n                    logger.debug(\"WebSocket closed \" + event.reason);\n                    rej(new Error(JSON.stringify(event)));\n                  };\n\n                  _this.awsRealTimeSocket.onmessage = function (message) {\n                    if (typeof message.data !== 'string') {\n                      return;\n                    }\n\n                    logger.debug(\"subscription message from AWS AppSyncRealTime: \" + message.data + \" \");\n                    var data = JSON.parse(message.data);\n                    var type = data.type,\n                        _a = data.payload,\n                        _b = (_a === void 0 ? {} : _a).connectionTimeoutMs,\n                        connectionTimeoutMs = _b === void 0 ? DEFAULT_KEEP_ALIVE_TIMEOUT : _b;\n\n                    if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                      ackOk_1 = true;\n\n                      if (_this.awsRealTimeSocket) {\n                        _this.keepAliveTimeout = connectionTimeoutMs;\n                        _this.awsRealTimeSocket.onmessage = _this._handleIncomingSubscriptionMessage.bind(_this);\n\n                        _this.awsRealTimeSocket.onerror = function (err) {\n                          logger.debug(err);\n\n                          _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                        };\n\n                        _this.awsRealTimeSocket.onclose = function (event) {\n                          logger.debug(\"WebSocket closed \" + event.reason);\n\n                          _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                        };\n                      }\n\n                      res('Cool, connected to AWS AppSyncRealTime');\n                      return;\n                    }\n\n                    if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                      var _c = data.payload,\n                          _d = (_c === void 0 ? {} : _c).errors,\n                          _e = __read(_d === void 0 ? [] : _d, 1),\n                          _f = _e[0],\n                          _g = _f === void 0 ? {} : _f,\n                          _h = _g.errorType,\n                          errorType = _h === void 0 ? '' : _h,\n                          _j = _g.errorCode,\n                          errorCode = _j === void 0 ? 0 : _j;\n\n                      rej({\n                        errorType: errorType,\n                        errorCode: errorCode\n                      });\n                    }\n                  };\n\n                  var gqlInit = {\n                    type: MESSAGE_TYPES.GQL_CONNECTION_INIT\n                  };\n\n                  _this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n\n                  var checkAckOk_1 = function (ackOk) {\n                    if (!ackOk) {\n                      _this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n\n                      rej(new Error(\"Connection timeout: ack from AWSAppSyncRealTime was not received after \" + CONNECTION_INIT_TIMEOUT + \" ms\"));\n                    }\n                  };\n\n                  setTimeout(function () {\n                    return checkAckOk_1(ackOk_1);\n                  }, CONNECTION_INIT_TIMEOUT);\n                }\n              });\n            }()];\n\n          case 3:\n            // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            err_4 = _b.sent();\n            _a = err_4, errorType = _a.errorType, errorCode = _a.errorCode;\n\n            if (NON_RETRYABLE_CODES.includes(errorCode)) {\n              throw new NonRetryableError(errorType);\n            } else if (errorType) {\n              throw new Error(errorType);\n            } else {\n              throw err_4;\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeHeaderBasedAuth = function (_a) {\n    var authenticationType = _a.authenticationType,\n        payload = _a.payload,\n        canonicalUri = _a.canonicalUri,\n        appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        apiKey = _a.apiKey,\n        region = _a.region,\n        additionalHeaders = _a.additionalHeaders;\n    return __awaiter(this, void 0, void 0, function () {\n      var headerHandler, handler, host, result;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            headerHandler = {\n              API_KEY: this._awsRealTimeApiKeyHeader.bind(this),\n              AWS_IAM: this._awsRealTimeIAMHeader.bind(this),\n              OPENID_CONNECT: this._awsRealTimeOPENIDHeader.bind(this),\n              AMAZON_COGNITO_USER_POOLS: this._awsRealTimeCUPHeader.bind(this),\n              AWS_LAMBDA: this._customAuthHeader\n            };\n            if (!(!authenticationType || !headerHandler[authenticationType])) return [3\n            /*break*/\n            , 1];\n            logger.debug(\"Authentication type \" + authenticationType + \" not supported\");\n            return [2\n            /*return*/\n            , undefined];\n\n          case 1:\n            handler = headerHandler[authenticationType];\n            host = url.parse(appSyncGraphqlEndpoint !== null && appSyncGraphqlEndpoint !== void 0 ? appSyncGraphqlEndpoint : '').host;\n            logger.debug(\"Authenticating with \" + authenticationType);\n            return [4\n            /*yield*/\n            , handler({\n              payload: payload,\n              canonicalUri: canonicalUri,\n              appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n              apiKey: apiKey,\n              region: region,\n              host: host,\n              additionalHeaders: additionalHeaders\n            })];\n\n          case 2:\n            result = _b.sent();\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeCUPHeader = function (_a) {\n    var host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var session;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Auth.currentSession()];\n\n          case 1:\n            session = _b.sent();\n            return [2\n            /*return*/\n            , {\n              Authorization: session.getAccessToken().getJwtToken(),\n              host: host\n            }];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeOPENIDHeader = function (_a) {\n    var host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var token, federatedInfo, currentUser;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Cache.getItem('federatedInfo')];\n\n          case 1:\n            federatedInfo = _b.sent();\n            if (!federatedInfo) return [3\n            /*break*/\n            , 2];\n            token = federatedInfo.token;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , Auth.currentAuthenticatedUser()];\n\n          case 3:\n            currentUser = _b.sent();\n\n            if (currentUser) {\n              token = currentUser.token;\n            }\n\n            _b.label = 4;\n\n          case 4:\n            if (!token) {\n              throw new Error('No federated jwt');\n            }\n\n            return [2\n            /*return*/\n            , {\n              Authorization: token,\n              host: host\n            }];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeApiKeyHeader = function (_a) {\n    var apiKey = _a.apiKey,\n        host = _a.host;\n    return __awaiter(this, void 0, void 0, function () {\n      var dt, dtStr;\n      return __generator(this, function (_b) {\n        dt = new Date();\n        dtStr = dt.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\n        return [2\n        /*return*/\n        , {\n          host: host,\n          'x-amz-date': dtStr,\n          'x-api-key': apiKey\n        }];\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._awsRealTimeIAMHeader = function (_a) {\n    var payload = _a.payload,\n        canonicalUri = _a.canonicalUri,\n        appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint,\n        region = _a.region;\n    return __awaiter(this, void 0, void 0, function () {\n      var endpointInfo, credentialsOK, creds, request, signed_params;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            endpointInfo = {\n              region: region,\n              service: 'appsync'\n            };\n            return [4\n            /*yield*/\n            , this._ensureCredentials()];\n\n          case 1:\n            credentialsOK = _b.sent();\n\n            if (!credentialsOK) {\n              throw new Error('No credentials');\n            }\n\n            return [4\n            /*yield*/\n            , Credentials.get().then(function (credentials) {\n              var _a = credentials,\n                  secretAccessKey = _a.secretAccessKey,\n                  accessKeyId = _a.accessKeyId,\n                  sessionToken = _a.sessionToken;\n              return {\n                secret_key: secretAccessKey,\n                access_key: accessKeyId,\n                session_token: sessionToken\n              };\n            })];\n\n          case 2:\n            creds = _b.sent();\n            request = {\n              url: \"\" + appSyncGraphqlEndpoint + canonicalUri,\n              data: payload,\n              method: 'POST',\n              headers: __assign({}, AWS_APPSYNC_REALTIME_HEADERS)\n            };\n            signed_params = Signer.sign(request, creds, endpointInfo);\n            return [2\n            /*return*/\n            , signed_params.headers];\n        }\n      });\n    });\n  };\n\n  AWSAppSyncRealTimeProvider.prototype._customAuthHeader = function (_a) {\n    var host = _a.host,\n        additionalHeaders = _a.additionalHeaders;\n\n    if (!additionalHeaders || !additionalHeaders['Authorization']) {\n      throw new Error('No auth token specified');\n    }\n\n    return {\n      Authorization: additionalHeaders.Authorization,\n      host: host\n    };\n  };\n  /**\n   * @private\n   */\n\n\n  AWSAppSyncRealTimeProvider.prototype._ensureCredentials = function () {\n    return Credentials.get().then(function (credentials) {\n      if (!credentials) return false;\n      var cred = Credentials.shear(credentials);\n      logger.debug('set credentials for AWSAppSyncRealTimeProvider', cred);\n      return true;\n    }).catch(function (err) {\n      logger.warn('ensure credentials error', err);\n      return false;\n    });\n  };\n\n  return AWSAppSyncRealTimeProvider;\n}(AbstractPubSubProvider);\n\nexport { AWSAppSyncRealTimeProvider };","map":{"version":3,"names":["__assign","__awaiter","__extends","__generator","__read","Observable","GraphQLError","url","v4","uuid","Buffer","Logger","Credentials","Signer","Hub","USER_AGENT_HEADER","jitteredExponentialRetry","NonRetryableError","isNonRetryableError","getAmplifyUserAgent","Cache","Auth","AbstractPubSubProvider","CONTROL_MSG","ConnectionState","AMPLIFY_SYMBOL","AWS_APPSYNC_REALTIME_HEADERS","CONNECTION_INIT_TIMEOUT","DEFAULT_KEEP_ALIVE_TIMEOUT","DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT","MAX_DELAY_MS","MESSAGE_TYPES","NON_RETRYABLE_CODES","SOCKET_STATUS","START_ACK_TIMEOUT","SUBSCRIPTION_STATUS","CONNECTION_STATE_CHANGE","ConnectionStateMonitor","CONNECTION_CHANGE","ReconnectEvent","ReconnectionMonitor","logger","dispatchApiEvent","event","data","message","dispatch","standardDomainPattern","customDomainPath","AWSAppSyncRealTimeProvider","_super","options","_this","call","socketStatus","CLOSED","keepAliveTimeout","subscriptionObserverMap","Map","promiseArray","connectionStateMonitor","reconnectionMonitor","connectionStateMonitorSubscription","connectionStateObservable","subscribe","connectionState","provider","ConnectionDisrupted","record","START_RECONNECT","Connected","ConnectedPendingDisconnect","ConnectedPendingKeepAlive","ConnectedPendingNetwork","ConnectionDisruptedPendingNetwork","Disconnected","includes","HALT_RECONNECT","prototype","close","CONNECTION_FAILED","unsubscribe","getNewWebSocket","protocol","WebSocket","getProviderName","newClient","Error","publish","_topics","_msg","_options","_a","isCustomDomain","match","customUserAgentDetails","appSyncGraphqlEndpoint","observer","error","errors","complete","subscriptionStartActive_1","subscriptionId_1","startSubscription_1","startSubscriptionPromise","_startSubscriptionWithAWSAppSyncRealTime","subscriptionId","catch","err","debug","REALTIME_SUBSCRIPTION_INIT_ERROR","finally","reconnectSubscription_1","addObserver","subscriptionState","err_1","label","trys","push","_waitForSubscriptionToBeConnected","sent","get","CONNECTED","_sendUnsubscriptionMessage","_removeSubscriptionObserver","Object","defineProperty","enumerable","configurable","_b","authenticationType","query","variables","apiKey","region","_c","graphql_headers","_d","additionalHeaders","dataString","headerObj","_e","_f","subscriptionMessage","stringToAWSRealTime","err_2","_g","subscriptionFailedCallback","subscriptionReadyCallback","_h","_j","PENDING","set","startAckTimeoutId","undefined","JSON","stringify","_awsRealTimeHeaderBasedAuth","payload","canonicalUri","apply","concat","id","extensions","authorization","type","GQL_START","OPENING_CONNECTION","_initializeWebSocketConnection","_logStartSubscriptionError","setTimeout","_timeoutStartSubscriptionAck","awsRealTimeSocket","send","String","Promise","resolve","subscriptionObserver","res","rej","readyState","OPEN","READY","unsubscribeMessage","GQL_STOP","delete","_closeSocketIfRequired","bind","size","CLOSING_CONNECTION","bufferedAmount","keepAliveTimeoutId","clearTimeout","keepAliveAlertTimeoutId","tempSocket","onclose","onerror","_handleIncomingSubscriptionMessage","parse","GQL_DATA","next","GQL_START_ACK","SUBSCRIPTION_ACK","CONNECTION_ESTABLISHED","GQL_CONNECTION_KEEP_ALIVE","_errorDisconnect","TIMEOUT_DISCONNECT","KEEP_ALIVE_MISSED","KEEP_ALIVE","GQL_ERROR","FAILED","msg","payloadString","authHeader","headerString","headerQs","payloadQs","discoverableEndpoint","awsRealTimeUrl","err_3","CONNECTING","from","toString","replace","isSSLEnabled","_initializeRetryableHandshake","forEach","_initializeHandshake","err_4","errorType","errorCode","newSocket","onopen","ackOk_1","reason","onmessage","connectionTimeoutMs","GQL_CONNECTION_ACK","CONNECTION_CLOSED","GQL_CONNECTION_ERROR","gqlInit","GQL_CONNECTION_INIT","checkAckOk_1","ackOk","headerHandler","handler","host","result","API_KEY","_awsRealTimeApiKeyHeader","AWS_IAM","_awsRealTimeIAMHeader","OPENID_CONNECT","_awsRealTimeOPENIDHeader","AMAZON_COGNITO_USER_POOLS","_awsRealTimeCUPHeader","AWS_LAMBDA","_customAuthHeader","session","currentSession","Authorization","getAccessToken","getJwtToken","token","federatedInfo","currentUser","getItem","currentAuthenticatedUser","dt","dtStr","Date","toISOString","endpointInfo","credentialsOK","creds","request","signed_params","service","_ensureCredentials","then","credentials","secretAccessKey","accessKeyId","sessionToken","secret_key","access_key","session_token","method","headers","sign","cred","shear","warn"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/pubsub/lib-esm/Providers/AWSAppSyncRealTimeProvider/index.js"],"sourcesContent":["import { __assign, __awaiter, __extends, __generator, __read } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport Observable from 'zen-observable-ts';\nimport { GraphQLError } from 'graphql';\nimport * as url from 'url';\nimport { v4 as uuid } from 'uuid';\nimport { Buffer } from 'buffer';\nimport { Logger, Credentials, Signer, Hub, USER_AGENT_HEADER, jitteredExponentialRetry, NonRetryableError, isNonRetryableError, getAmplifyUserAgent, } from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport { Auth } from '@aws-amplify/auth';\nimport { AbstractPubSubProvider } from '../PubSubProvider';\nimport { CONTROL_MSG, ConnectionState, } from '../../types/PubSub';\nimport { AMPLIFY_SYMBOL, AWS_APPSYNC_REALTIME_HEADERS, CONNECTION_INIT_TIMEOUT, DEFAULT_KEEP_ALIVE_TIMEOUT, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, MAX_DELAY_MS, MESSAGE_TYPES, NON_RETRYABLE_CODES, SOCKET_STATUS, START_ACK_TIMEOUT, SUBSCRIPTION_STATUS, CONNECTION_STATE_CHANGE, } from '../constants';\nimport { ConnectionStateMonitor, CONNECTION_CHANGE, } from '../../utils/ConnectionStateMonitor';\nimport { ReconnectEvent, ReconnectionMonitor, } from '../../utils/ReconnectionMonitor';\nvar logger = new Logger('AWSAppSyncRealTimeProvider');\nvar dispatchApiEvent = function (event, data, message) {\n    Hub.dispatch('api', { event: event, data: data, message: message }, 'PubSub', AMPLIFY_SYMBOL);\n};\nvar standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync\\-api\\.\\w{2}(?:(?:\\-\\w{2,})+)\\-\\d\\.amazonaws.com(?:\\.cn)?\\/graphql$/i;\nvar customDomainPath = '/realtime';\nvar AWSAppSyncRealTimeProvider = /** @class */ (function (_super) {\n    __extends(AWSAppSyncRealTimeProvider, _super);\n    function AWSAppSyncRealTimeProvider(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, options) || this;\n        _this.socketStatus = SOCKET_STATUS.CLOSED;\n        _this.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n        _this.subscriptionObserverMap = new Map();\n        _this.promiseArray = [];\n        _this.connectionStateMonitor = new ConnectionStateMonitor();\n        _this.reconnectionMonitor = new ReconnectionMonitor();\n        // Monitor the connection state and pass changes along to Hub\n        _this.connectionStateMonitorSubscription =\n            _this.connectionStateMonitor.connectionStateObservable.subscribe(function (connectionState) {\n                dispatchApiEvent(CONNECTION_STATE_CHANGE, {\n                    provider: _this,\n                    connectionState: connectionState,\n                }, \"Connection state is \" + connectionState);\n                _this.connectionState = connectionState;\n                // Trigger START_RECONNECT when the connection is disrupted\n                if (connectionState === ConnectionState.ConnectionDisrupted) {\n                    _this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n                }\n                // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n                //   ConnectionDisrupted or Connecting\n                if ([\n                    ConnectionState.Connected,\n                    ConnectionState.ConnectedPendingDisconnect,\n                    ConnectionState.ConnectedPendingKeepAlive,\n                    ConnectionState.ConnectedPendingNetwork,\n                    ConnectionState.ConnectionDisruptedPendingNetwork,\n                    ConnectionState.Disconnected,\n                ].includes(connectionState)) {\n                    _this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n                }\n            });\n        return _this;\n    }\n    /**\n     * Mark the socket closed and release all active listeners\n     */\n    AWSAppSyncRealTimeProvider.prototype.close = function () {\n        // Mark the socket closed both in status and the connection monitor\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n        // Turn off the subscription monitor Hub publishing\n        this.connectionStateMonitorSubscription.unsubscribe();\n        // Complete all reconnect observers\n        this.reconnectionMonitor.close();\n    };\n    AWSAppSyncRealTimeProvider.prototype.getNewWebSocket = function (url, protocol) {\n        return new WebSocket(url, protocol);\n    };\n    AWSAppSyncRealTimeProvider.prototype.getProviderName = function () {\n        return 'AWSAppSyncRealTimeProvider';\n    };\n    AWSAppSyncRealTimeProvider.prototype.newClient = function () {\n        throw new Error('Not used here');\n    };\n    AWSAppSyncRealTimeProvider.prototype.publish = function (_topics, _msg, _options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Operation not supported');\n            });\n        });\n    };\n    // Check if url matches standard domain pattern\n    AWSAppSyncRealTimeProvider.prototype.isCustomDomain = function (url) {\n        return url.match(standardDomainPattern) === null;\n    };\n    AWSAppSyncRealTimeProvider.prototype.subscribe = function (_topics, options, customUserAgentDetails) {\n        var _this = this;\n        var appSyncGraphqlEndpoint = options === null || options === void 0 ? void 0 : options.appSyncGraphqlEndpoint;\n        return new Observable(function (observer) {\n            if (!options || !appSyncGraphqlEndpoint) {\n                observer.error({\n                    errors: [\n                        __assign({}, new GraphQLError(\"Subscribe only available for AWS AppSync endpoint\")),\n                    ],\n                });\n                observer.complete();\n            }\n            else {\n                var subscriptionStartActive_1 = false;\n                var subscriptionId_1 = uuid();\n                var startSubscription_1 = function () {\n                    if (!subscriptionStartActive_1) {\n                        subscriptionStartActive_1 = true;\n                        var startSubscriptionPromise = _this._startSubscriptionWithAWSAppSyncRealTime({\n                            options: options,\n                            observer: observer,\n                            subscriptionId: subscriptionId_1,\n                            customUserAgentDetails: customUserAgentDetails,\n                        }).catch(function (err) {\n                            logger.debug(CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR + \": \" + err);\n                            _this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n                        });\n                        startSubscriptionPromise.finally(function () {\n                            subscriptionStartActive_1 = false;\n                        });\n                    }\n                };\n                var reconnectSubscription_1;\n                // Add an observable to the reconnection list to manage reconnection for this subscription\n                reconnectSubscription_1 = new Observable(function (observer) {\n                    _this.reconnectionMonitor.addObserver(observer);\n                }).subscribe(function () {\n                    startSubscription_1();\n                });\n                startSubscription_1();\n                return function () { return __awaiter(_this, void 0, void 0, function () {\n                    var subscriptionState, err_1;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                // Cleanup reconnection subscription\n                                reconnectSubscription_1 === null || reconnectSubscription_1 === void 0 ? void 0 : reconnectSubscription_1.unsubscribe();\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 3, 4, 5]);\n                                // Waiting that subscription has been connected before trying to unsubscribe\n                                return [4 /*yield*/, this._waitForSubscriptionToBeConnected(subscriptionId_1)];\n                            case 2:\n                                // Waiting that subscription has been connected before trying to unsubscribe\n                                _a.sent();\n                                subscriptionState = (this.subscriptionObserverMap.get(subscriptionId_1) || {}).subscriptionState;\n                                if (!subscriptionState) {\n                                    // subscription already unsubscribed\n                                    return [2 /*return*/];\n                                }\n                                if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n                                    this._sendUnsubscriptionMessage(subscriptionId_1);\n                                }\n                                else {\n                                    throw new Error('Subscription never connected');\n                                }\n                                return [3 /*break*/, 5];\n                            case 3:\n                                err_1 = _a.sent();\n                                logger.debug(\"Error while unsubscribing \" + err_1);\n                                return [3 /*break*/, 5];\n                            case 4:\n                                this._removeSubscriptionObserver(subscriptionId_1);\n                                return [7 /*endfinally*/];\n                            case 5: return [2 /*return*/];\n                        }\n                    });\n                }); };\n            }\n        });\n    };\n    Object.defineProperty(AWSAppSyncRealTimeProvider.prototype, \"isSSLEnabled\", {\n        get: function () {\n            return !this.options['aws_appsync_dangerously_connect_to_http_endpoint_for_testing'];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AWSAppSyncRealTimeProvider.prototype._startSubscriptionWithAWSAppSyncRealTime = function (_a) {\n        var options = _a.options, observer = _a.observer, subscriptionId = _a.subscriptionId, customUserAgentDetails = _a.customUserAgentDetails;\n        var _b;\n        return __awaiter(this, void 0, void 0, function () {\n            var appSyncGraphqlEndpoint, authenticationType, query, variables, apiKey, region, _c, graphql_headers, _d, additionalHeaders, subscriptionState, data, dataString, headerObj, _e, _f, subscriptionMessage, stringToAWSRealTime, err_2, _g, subscriptionFailedCallback, subscriptionReadyCallback;\n            var _h;\n            var _this = this;\n            return __generator(this, function (_j) {\n                switch (_j.label) {\n                    case 0:\n                        appSyncGraphqlEndpoint = options.appSyncGraphqlEndpoint, authenticationType = options.authenticationType, query = options.query, variables = options.variables, apiKey = options.apiKey, region = options.region, _c = options.graphql_headers, graphql_headers = _c === void 0 ? function () { return ({}); } : _c, _d = options.additionalHeaders, additionalHeaders = _d === void 0 ? {} : _d;\n                        subscriptionState = SUBSCRIPTION_STATUS.PENDING;\n                        data = {\n                            query: query,\n                            variables: variables,\n                        };\n                        // Having a subscription id map will make it simple to forward messages received\n                        this.subscriptionObserverMap.set(subscriptionId, {\n                            observer: observer,\n                            query: query !== null && query !== void 0 ? query : '',\n                            variables: variables !== null && variables !== void 0 ? variables : {},\n                            subscriptionState: subscriptionState,\n                            startAckTimeoutId: undefined,\n                        });\n                        dataString = JSON.stringify(data);\n                        _e = [{}];\n                        return [4 /*yield*/, this._awsRealTimeHeaderBasedAuth({\n                                apiKey: apiKey,\n                                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                                authenticationType: authenticationType,\n                                payload: dataString,\n                                canonicalUri: '',\n                                region: region,\n                                additionalHeaders: additionalHeaders,\n                            })];\n                    case 1:\n                        _f = [__assign.apply(void 0, _e.concat([(_j.sent())]))];\n                        return [4 /*yield*/, graphql_headers()];\n                    case 2:\n                        headerObj = __assign.apply(void 0, [__assign.apply(void 0, [__assign.apply(void 0, _f.concat([(_j.sent())])), additionalHeaders]), (_h = {}, _h[USER_AGENT_HEADER] = getAmplifyUserAgent(customUserAgentDetails), _h)]);\n                        subscriptionMessage = {\n                            id: subscriptionId,\n                            payload: {\n                                data: dataString,\n                                extensions: {\n                                    authorization: __assign({}, headerObj),\n                                },\n                            },\n                            type: MESSAGE_TYPES.GQL_START,\n                        };\n                        stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n                        _j.label = 3;\n                    case 3:\n                        _j.trys.push([3, 5, , 6]);\n                        this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n                        return [4 /*yield*/, this._initializeWebSocketConnection({\n                                apiKey: apiKey,\n                                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                                authenticationType: authenticationType,\n                                region: region,\n                                additionalHeaders: additionalHeaders,\n                            })];\n                    case 4:\n                        _j.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        err_2 = _j.sent();\n                        this._logStartSubscriptionError(subscriptionId, observer, err_2);\n                        return [2 /*return*/];\n                    case 6:\n                        _g = (_b = this.subscriptionObserverMap.get(subscriptionId)) !== null && _b !== void 0 ? _b : {}, subscriptionFailedCallback = _g.subscriptionFailedCallback, subscriptionReadyCallback = _g.subscriptionReadyCallback;\n                        // This must be done before sending the message in order to be listening immediately\n                        this.subscriptionObserverMap.set(subscriptionId, {\n                            observer: observer,\n                            subscriptionState: subscriptionState,\n                            query: query !== null && query !== void 0 ? query : '',\n                            variables: variables !== null && variables !== void 0 ? variables : {},\n                            subscriptionReadyCallback: subscriptionReadyCallback,\n                            subscriptionFailedCallback: subscriptionFailedCallback,\n                            startAckTimeoutId: setTimeout(function () {\n                                _this._timeoutStartSubscriptionAck.call(_this, subscriptionId);\n                            }, START_ACK_TIMEOUT),\n                        });\n                        if (this.awsRealTimeSocket) {\n                            this.awsRealTimeSocket.send(stringToAWSRealTime);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Log logic for start subscription failures\n    AWSAppSyncRealTimeProvider.prototype._logStartSubscriptionError = function (subscriptionId, observer, err) {\n        var _a;\n        logger.debug({ err: err });\n        var message = String((_a = err.message) !== null && _a !== void 0 ? _a : '');\n        // Resolving to give the state observer time to propogate the update\n        Promise.resolve(this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED));\n        // Capture the error only when the network didn't cause disruption\n        if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n            // When the error is non-retriable, error out the observable\n            if (isNonRetryableError(err)) {\n                observer.error({\n                    errors: [\n                        __assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + message)),\n                    ],\n                });\n            }\n            else {\n                logger.debug(CONTROL_MSG.CONNECTION_FAILED + \": \" + message);\n            }\n            var subscriptionFailedCallback = (this.subscriptionObserverMap.get(subscriptionId) || {}).subscriptionFailedCallback;\n            // Notify concurrent unsubscription\n            if (typeof subscriptionFailedCallback === 'function') {\n                subscriptionFailedCallback();\n            }\n        }\n    };\n    // Waiting that subscription has been connected before trying to unsubscribe\n    AWSAppSyncRealTimeProvider.prototype._waitForSubscriptionToBeConnected = function (subscriptionId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var subscriptionObserver, subscriptionState;\n            var _this = this;\n            return __generator(this, function (_a) {\n                subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n                if (subscriptionObserver) {\n                    subscriptionState = subscriptionObserver.subscriptionState;\n                    // This in case unsubscribe is invoked before sending start subscription message\n                    if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n                        return [2 /*return*/, new Promise(function (res, rej) {\n                                var observer = subscriptionObserver.observer, subscriptionState = subscriptionObserver.subscriptionState, variables = subscriptionObserver.variables, query = subscriptionObserver.query;\n                                _this.subscriptionObserverMap.set(subscriptionId, {\n                                    observer: observer,\n                                    subscriptionState: subscriptionState,\n                                    variables: variables,\n                                    query: query,\n                                    subscriptionReadyCallback: res,\n                                    subscriptionFailedCallback: rej,\n                                });\n                            })];\n                    }\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._sendUnsubscriptionMessage = function (subscriptionId) {\n        try {\n            if (this.awsRealTimeSocket &&\n                this.awsRealTimeSocket.readyState === WebSocket.OPEN &&\n                this.socketStatus === SOCKET_STATUS.READY) {\n                // Preparing unsubscribe message to stop receiving messages for that subscription\n                var unsubscribeMessage = {\n                    id: subscriptionId,\n                    type: MESSAGE_TYPES.GQL_STOP,\n                };\n                var stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n                this.awsRealTimeSocket.send(stringToAWSRealTime);\n            }\n        }\n        catch (err) {\n            // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n            logger.debug({ err: err });\n        }\n    };\n    AWSAppSyncRealTimeProvider.prototype._removeSubscriptionObserver = function (subscriptionId) {\n        this.subscriptionObserverMap.delete(subscriptionId);\n        // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n        setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    };\n    AWSAppSyncRealTimeProvider.prototype._closeSocketIfRequired = function () {\n        if (this.subscriptionObserverMap.size > 0) {\n            // Active subscriptions on the WebSocket\n            return;\n        }\n        if (!this.awsRealTimeSocket) {\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            return;\n        }\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n        if (this.awsRealTimeSocket.bufferedAmount > 0) {\n            // Still data on the WebSocket\n            setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n        }\n        else {\n            logger.debug('closing WebSocket...');\n            if (this.keepAliveTimeoutId) {\n                clearTimeout(this.keepAliveTimeoutId);\n            }\n            if (this.keepAliveAlertTimeoutId) {\n                clearTimeout(this.keepAliveAlertTimeoutId);\n            }\n            var tempSocket = this.awsRealTimeSocket;\n            // Cleaning callbacks to avoid race condition, socket still exists\n            tempSocket.onclose = null;\n            tempSocket.onerror = null;\n            tempSocket.close(1000);\n            this.awsRealTimeSocket = undefined;\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n        }\n    };\n    AWSAppSyncRealTimeProvider.prototype._handleIncomingSubscriptionMessage = function (message) {\n        var _this = this;\n        if (typeof message.data !== 'string') {\n            return;\n        }\n        logger.debug(\"subscription message from AWS AppSync RealTime: \" + message.data);\n        var _a = JSON.parse(String(message.data)), _b = _a.id, id = _b === void 0 ? '' : _b, payload = _a.payload, type = _a.type;\n        var _c = this.subscriptionObserverMap.get(id) || {}, _d = _c.observer, observer = _d === void 0 ? null : _d, _e = _c.query, query = _e === void 0 ? '' : _e, _f = _c.variables, variables = _f === void 0 ? {} : _f, startAckTimeoutId = _c.startAckTimeoutId, subscriptionReadyCallback = _c.subscriptionReadyCallback, subscriptionFailedCallback = _c.subscriptionFailedCallback;\n        logger.debug({ id: id, observer: observer, query: query, variables: variables });\n        if (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n            if (observer) {\n                observer.next(payload);\n            }\n            else {\n                logger.debug(\"observer not found for id: \" + id);\n            }\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_START_ACK) {\n            logger.debug(\"subscription ready for \" + JSON.stringify({ query: query, variables: variables }));\n            if (typeof subscriptionReadyCallback === 'function') {\n                subscriptionReadyCallback();\n            }\n            if (startAckTimeoutId)\n                clearTimeout(startAckTimeoutId);\n            dispatchApiEvent(CONTROL_MSG.SUBSCRIPTION_ACK, { query: query, variables: variables }, 'Connection established for subscription');\n            var subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer: observer,\n                    query: query,\n                    variables: variables,\n                    startAckTimeoutId: undefined,\n                    subscriptionState: subscriptionState,\n                    subscriptionReadyCallback: subscriptionReadyCallback,\n                    subscriptionFailedCallback: subscriptionFailedCallback,\n                });\n            }\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n            if (this.keepAliveTimeoutId)\n                clearTimeout(this.keepAliveTimeoutId);\n            if (this.keepAliveAlertTimeoutId)\n                clearTimeout(this.keepAliveAlertTimeoutId);\n            this.keepAliveTimeoutId = setTimeout(function () { return _this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT); }, this.keepAliveTimeout);\n            this.keepAliveAlertTimeoutId = setTimeout(function () {\n                _this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n            }, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT);\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_ERROR) {\n            var subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer: observer,\n                    query: query,\n                    variables: variables,\n                    startAckTimeoutId: startAckTimeoutId,\n                    subscriptionReadyCallback: subscriptionReadyCallback,\n                    subscriptionFailedCallback: subscriptionFailedCallback,\n                    subscriptionState: subscriptionState,\n                });\n                logger.debug(CONTROL_MSG.CONNECTION_FAILED + \": \" + JSON.stringify(payload));\n                observer.error({\n                    errors: [\n                        __assign({}, new GraphQLError(CONTROL_MSG.CONNECTION_FAILED + \": \" + JSON.stringify(payload))),\n                    ],\n                });\n                if (startAckTimeoutId)\n                    clearTimeout(startAckTimeoutId);\n                if (typeof subscriptionFailedCallback === 'function') {\n                    subscriptionFailedCallback();\n                }\n            }\n        }\n    };\n    AWSAppSyncRealTimeProvider.prototype._errorDisconnect = function (msg) {\n        logger.debug(\"Disconnect error: \" + msg);\n        if (this.awsRealTimeSocket) {\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            this.awsRealTimeSocket.close();\n        }\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n    };\n    AWSAppSyncRealTimeProvider.prototype._timeoutStartSubscriptionAck = function (subscriptionId) {\n        var subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n        if (subscriptionObserver) {\n            var observer = subscriptionObserver.observer, query = subscriptionObserver.query, variables = subscriptionObserver.variables;\n            if (!observer) {\n                return;\n            }\n            this.subscriptionObserverMap.set(subscriptionId, {\n                observer: observer,\n                query: query,\n                variables: variables,\n                subscriptionState: SUBSCRIPTION_STATUS.FAILED,\n            });\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            logger.debug('timeoutStartSubscription', JSON.stringify({ query: query, variables: variables }));\n        }\n    };\n    AWSAppSyncRealTimeProvider.prototype._initializeWebSocketConnection = function (_a) {\n        var _this = this;\n        var appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, authenticationType = _a.authenticationType, apiKey = _a.apiKey, region = _a.region, additionalHeaders = _a.additionalHeaders;\n        if (this.socketStatus === SOCKET_STATUS.READY) {\n            return;\n        }\n        return new Promise(function (res, rej) { return __awaiter(_this, void 0, void 0, function () {\n            var payloadString, authHeader, headerString, headerQs, payloadQs, discoverableEndpoint, protocol, awsRealTimeUrl, err_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.promiseArray.push({ res: res, rej: rej });\n                        if (!(this.socketStatus === SOCKET_STATUS.CLOSED)) return [3 /*break*/, 5];\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        this.socketStatus = SOCKET_STATUS.CONNECTING;\n                        payloadString = '{}';\n                        return [4 /*yield*/, this._awsRealTimeHeaderBasedAuth({\n                                authenticationType: authenticationType,\n                                payload: payloadString,\n                                canonicalUri: '/connect',\n                                apiKey: apiKey,\n                                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                                region: region,\n                                additionalHeaders: additionalHeaders,\n                            })];\n                    case 2:\n                        authHeader = _a.sent();\n                        headerString = authHeader ? JSON.stringify(authHeader) : '';\n                        headerQs = Buffer.from(headerString).toString('base64');\n                        payloadQs = Buffer.from(payloadString).toString('base64');\n                        discoverableEndpoint = appSyncGraphqlEndpoint !== null && appSyncGraphqlEndpoint !== void 0 ? appSyncGraphqlEndpoint : '';\n                        if (this.isCustomDomain(discoverableEndpoint)) {\n                            discoverableEndpoint =\n                                discoverableEndpoint.concat(customDomainPath);\n                        }\n                        else {\n                            discoverableEndpoint = discoverableEndpoint\n                                .replace('appsync-api', 'appsync-realtime-api')\n                                .replace('gogi-beta', 'grt-beta');\n                        }\n                        protocol = this.isSSLEnabled ? 'wss://' : 'ws://';\n                        discoverableEndpoint = discoverableEndpoint\n                            .replace('https://', protocol)\n                            .replace('http://', protocol);\n                        awsRealTimeUrl = discoverableEndpoint + \"?header=\" + headerQs + \"&payload=\" + payloadQs;\n                        return [4 /*yield*/, this._initializeRetryableHandshake(awsRealTimeUrl)];\n                    case 3:\n                        _a.sent();\n                        this.promiseArray.forEach(function (_a) {\n                            var res = _a.res;\n                            logger.debug('Notifying connection successful');\n                            res();\n                        });\n                        this.socketStatus = SOCKET_STATUS.READY;\n                        this.promiseArray = [];\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_3 = _a.sent();\n                        logger.debug('Connection exited with', err_3);\n                        this.promiseArray.forEach(function (_a) {\n                            var rej = _a.rej;\n                            return rej(err_3);\n                        });\n                        this.promiseArray = [];\n                        if (this.awsRealTimeSocket &&\n                            this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n                            this.awsRealTimeSocket.close(3001);\n                        }\n                        this.awsRealTimeSocket = undefined;\n                        this.socketStatus = SOCKET_STATUS.CLOSED;\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        }); });\n    };\n    AWSAppSyncRealTimeProvider.prototype._initializeRetryableHandshake = function (awsRealTimeUrl) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug(\"Initializaling retryable Handshake\");\n                        return [4 /*yield*/, jitteredExponentialRetry(this._initializeHandshake.bind(this), [awsRealTimeUrl], MAX_DELAY_MS)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._initializeHandshake = function (awsRealTimeUrl) {\n        return __awaiter(this, void 0, void 0, function () {\n            var err_4, _a, errorType, errorCode;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        logger.debug(\"Initializing handshake \" + awsRealTimeUrl);\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, (function () {\n                                return new Promise(function (res, rej) {\n                                    var newSocket = _this.getNewWebSocket(awsRealTimeUrl, 'graphql-ws');\n                                    newSocket.onerror = function () {\n                                        logger.debug(\"WebSocket connection error\");\n                                    };\n                                    newSocket.onclose = function () {\n                                        rej(new Error('Connection handshake error'));\n                                    };\n                                    newSocket.onopen = function () {\n                                        _this.awsRealTimeSocket = newSocket;\n                                        return res();\n                                    };\n                                });\n                            })()];\n                    case 2:\n                        _b.sent();\n                        // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n                        return [4 /*yield*/, (function () {\n                                return new Promise(function (res, rej) {\n                                    if (_this.awsRealTimeSocket) {\n                                        var ackOk_1 = false;\n                                        _this.awsRealTimeSocket.onerror = function (error) {\n                                            logger.debug(\"WebSocket error \" + JSON.stringify(error));\n                                        };\n                                        _this.awsRealTimeSocket.onclose = function (event) {\n                                            logger.debug(\"WebSocket closed \" + event.reason);\n                                            rej(new Error(JSON.stringify(event)));\n                                        };\n                                        _this.awsRealTimeSocket.onmessage = function (message) {\n                                            if (typeof message.data !== 'string') {\n                                                return;\n                                            }\n                                            logger.debug(\"subscription message from AWS AppSyncRealTime: \" + message.data + \" \");\n                                            var data = JSON.parse(message.data);\n                                            var type = data.type, _a = data.payload, _b = (_a === void 0 ? {} : _a).connectionTimeoutMs, connectionTimeoutMs = _b === void 0 ? DEFAULT_KEEP_ALIVE_TIMEOUT : _b;\n                                            if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                                                ackOk_1 = true;\n                                                if (_this.awsRealTimeSocket) {\n                                                    _this.keepAliveTimeout = connectionTimeoutMs;\n                                                    _this.awsRealTimeSocket.onmessage =\n                                                        _this._handleIncomingSubscriptionMessage.bind(_this);\n                                                    _this.awsRealTimeSocket.onerror = function (err) {\n                                                        logger.debug(err);\n                                                        _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                                                    };\n                                                    _this.awsRealTimeSocket.onclose = function (event) {\n                                                        logger.debug(\"WebSocket closed \" + event.reason);\n                                                        _this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                                                    };\n                                                }\n                                                res('Cool, connected to AWS AppSyncRealTime');\n                                                return;\n                                            }\n                                            if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                                                var _c = data.payload, _d = (_c === void 0 ? {} : _c).errors, _e = __read(_d === void 0 ? [] : _d, 1), _f = _e[0], _g = _f === void 0 ? {} : _f, _h = _g.errorType, errorType = _h === void 0 ? '' : _h, _j = _g.errorCode, errorCode = _j === void 0 ? 0 : _j;\n                                                rej({ errorType: errorType, errorCode: errorCode });\n                                            }\n                                        };\n                                        var gqlInit = {\n                                            type: MESSAGE_TYPES.GQL_CONNECTION_INIT,\n                                        };\n                                        _this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n                                        var checkAckOk_1 = function (ackOk) {\n                                            if (!ackOk) {\n                                                _this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n                                                rej(new Error(\"Connection timeout: ack from AWSAppSyncRealTime was not received after \" + CONNECTION_INIT_TIMEOUT + \" ms\"));\n                                            }\n                                        };\n                                        setTimeout(function () { return checkAckOk_1(ackOk_1); }, CONNECTION_INIT_TIMEOUT);\n                                    }\n                                });\n                            })()];\n                    case 3:\n                        // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n                        _b.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_4 = _b.sent();\n                        _a = err_4, errorType = _a.errorType, errorCode = _a.errorCode;\n                        if (NON_RETRYABLE_CODES.includes(errorCode)) {\n                            throw new NonRetryableError(errorType);\n                        }\n                        else if (errorType) {\n                            throw new Error(errorType);\n                        }\n                        else {\n                            throw err_4;\n                        }\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._awsRealTimeHeaderBasedAuth = function (_a) {\n        var authenticationType = _a.authenticationType, payload = _a.payload, canonicalUri = _a.canonicalUri, appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, apiKey = _a.apiKey, region = _a.region, additionalHeaders = _a.additionalHeaders;\n        return __awaiter(this, void 0, void 0, function () {\n            var headerHandler, handler, host, result;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        headerHandler = {\n                            API_KEY: this._awsRealTimeApiKeyHeader.bind(this),\n                            AWS_IAM: this._awsRealTimeIAMHeader.bind(this),\n                            OPENID_CONNECT: this._awsRealTimeOPENIDHeader.bind(this),\n                            AMAZON_COGNITO_USER_POOLS: this._awsRealTimeCUPHeader.bind(this),\n                            AWS_LAMBDA: this._customAuthHeader,\n                        };\n                        if (!(!authenticationType || !headerHandler[authenticationType])) return [3 /*break*/, 1];\n                        logger.debug(\"Authentication type \" + authenticationType + \" not supported\");\n                        return [2 /*return*/, undefined];\n                    case 1:\n                        handler = headerHandler[authenticationType];\n                        host = url.parse(appSyncGraphqlEndpoint !== null && appSyncGraphqlEndpoint !== void 0 ? appSyncGraphqlEndpoint : '').host;\n                        logger.debug(\"Authenticating with \" + authenticationType);\n                        return [4 /*yield*/, handler({\n                                payload: payload,\n                                canonicalUri: canonicalUri,\n                                appSyncGraphqlEndpoint: appSyncGraphqlEndpoint,\n                                apiKey: apiKey,\n                                region: region,\n                                host: host,\n                                additionalHeaders: additionalHeaders,\n                            })];\n                    case 2:\n                        result = _b.sent();\n                        return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._awsRealTimeCUPHeader = function (_a) {\n        var host = _a.host;\n        return __awaiter(this, void 0, void 0, function () {\n            var session;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Auth.currentSession()];\n                    case 1:\n                        session = _b.sent();\n                        return [2 /*return*/, {\n                                Authorization: session.getAccessToken().getJwtToken(),\n                                host: host,\n                            }];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._awsRealTimeOPENIDHeader = function (_a) {\n        var host = _a.host;\n        return __awaiter(this, void 0, void 0, function () {\n            var token, federatedInfo, currentUser;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, Cache.getItem('federatedInfo')];\n                    case 1:\n                        federatedInfo = _b.sent();\n                        if (!federatedInfo) return [3 /*break*/, 2];\n                        token = federatedInfo.token;\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, Auth.currentAuthenticatedUser()];\n                    case 3:\n                        currentUser = _b.sent();\n                        if (currentUser) {\n                            token = currentUser.token;\n                        }\n                        _b.label = 4;\n                    case 4:\n                        if (!token) {\n                            throw new Error('No federated jwt');\n                        }\n                        return [2 /*return*/, {\n                                Authorization: token,\n                                host: host,\n                            }];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._awsRealTimeApiKeyHeader = function (_a) {\n        var apiKey = _a.apiKey, host = _a.host;\n        return __awaiter(this, void 0, void 0, function () {\n            var dt, dtStr;\n            return __generator(this, function (_b) {\n                dt = new Date();\n                dtStr = dt.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\n                return [2 /*return*/, {\n                        host: host,\n                        'x-amz-date': dtStr,\n                        'x-api-key': apiKey,\n                    }];\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._awsRealTimeIAMHeader = function (_a) {\n        var payload = _a.payload, canonicalUri = _a.canonicalUri, appSyncGraphqlEndpoint = _a.appSyncGraphqlEndpoint, region = _a.region;\n        return __awaiter(this, void 0, void 0, function () {\n            var endpointInfo, credentialsOK, creds, request, signed_params;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        endpointInfo = {\n                            region: region,\n                            service: 'appsync',\n                        };\n                        return [4 /*yield*/, this._ensureCredentials()];\n                    case 1:\n                        credentialsOK = _b.sent();\n                        if (!credentialsOK) {\n                            throw new Error('No credentials');\n                        }\n                        return [4 /*yield*/, Credentials.get().then(function (credentials) {\n                                var _a = credentials, secretAccessKey = _a.secretAccessKey, accessKeyId = _a.accessKeyId, sessionToken = _a.sessionToken;\n                                return {\n                                    secret_key: secretAccessKey,\n                                    access_key: accessKeyId,\n                                    session_token: sessionToken,\n                                };\n                            })];\n                    case 2:\n                        creds = _b.sent();\n                        request = {\n                            url: \"\" + appSyncGraphqlEndpoint + canonicalUri,\n                            data: payload,\n                            method: 'POST',\n                            headers: __assign({}, AWS_APPSYNC_REALTIME_HEADERS),\n                        };\n                        signed_params = Signer.sign(request, creds, endpointInfo);\n                        return [2 /*return*/, signed_params.headers];\n                }\n            });\n        });\n    };\n    AWSAppSyncRealTimeProvider.prototype._customAuthHeader = function (_a) {\n        var host = _a.host, additionalHeaders = _a.additionalHeaders;\n        if (!additionalHeaders || !additionalHeaders['Authorization']) {\n            throw new Error('No auth token specified');\n        }\n        return {\n            Authorization: additionalHeaders.Authorization,\n            host: host,\n        };\n    };\n    /**\n     * @private\n     */\n    AWSAppSyncRealTimeProvider.prototype._ensureCredentials = function () {\n        return Credentials.get()\n            .then(function (credentials) {\n            if (!credentials)\n                return false;\n            var cred = Credentials.shear(credentials);\n            logger.debug('set credentials for AWSAppSyncRealTimeProvider', cred);\n            return true;\n        })\n            .catch(function (err) {\n            logger.warn('ensure credentials error', err);\n            return false;\n        });\n    };\n    return AWSAppSyncRealTimeProvider;\n}(AbstractPubSubProvider));\nexport { AWSAppSyncRealTimeProvider };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}