{"ast":null,"code":"import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement } from \"react\";\nimport { useComposedRefs as $45QHv$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as $45QHv$Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef as $45QHv$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/$45QHv$forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $45QHv$useState(null);\n  const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $45QHv$useRef(null);\n  const composedRefs = $45QHv$useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $45QHv$useRef({\n    paused: false,\n\n    pause() {\n      this.paused = true;\n    },\n\n    resume() {\n      this.paused = false;\n    }\n\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n\n  $45QHv$useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $45QHv$useEffect(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          }); // we need to remove the listener after we `dispatchEvent`\n\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n\n  const handleKeyDown = $45QHv$useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\n\nObject.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n  displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n* Attempts focusing the first element in a list of candidates.\n* Stops when focus has actually moved.\n*/\n\nfunction $d3863c46a17e8a28$var$focusFirst(candidates, {\n  select = false\n} = {}) {\n  const previouslyFocusedElement = document.activeElement;\n\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\n\n\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\n\n\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n\n\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\n\n\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\n\nfunction $d3863c46a17e8a28$var$isHidden(node, {\n  upTo: upTo\n}) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction $d3863c46a17e8a28$var$focus(element, {\n  select = false\n} = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\n\nconst $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\n\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause(); // remove in case it already exists (because we'll re-add it at the top of the stack)\n\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope) {\n      var _stack$;\n\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n\n  };\n}\n\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\n\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\n\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\nexport { $d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root };","map":{"version":3,"names":["$45QHv$babelruntimehelpersesmextends","forwardRef","$45QHv$forwardRef","useState","$45QHv$useState","useRef","$45QHv$useRef","useEffect","$45QHv$useEffect","useCallback","$45QHv$useCallback","createElement","$45QHv$createElement","useComposedRefs","$45QHv$useComposedRefs","Primitive","$45QHv$Primitive","useCallbackRef","$45QHv$useCallbackRef","$d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT","$d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT","$d3863c46a17e8a28$var$EVENT_OPTIONS","bubbles","cancelable","$d3863c46a17e8a28$var$FOCUS_SCOPE_NAME","$d3863c46a17e8a28$export$20e40289641fbbb6","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container1","setContainer","lastFocusedElementRef","composedRefs","node","focusScope","paused","pause","resume","current","handleFocusIn","event","target","contains","$d3863c46a17e8a28$var$focus","select","handleFocusOut","relatedTarget","document","addEventListener","removeEventListener","$d3863c46a17e8a28$var$focusScopesStack","add","previouslyFocusedElement","activeElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","$d3863c46a17e8a28$var$focusFirst","$d3863c46a17e8a28$var$removeLinks","$d3863c46a17e8a28$var$getTabbableCandidates","setTimeout","unmountEvent","body","remove","handleKeyDown","isTabKey","key","altKey","ctrlKey","metaKey","focusedElement","container","currentTarget","first","last","$d3863c46a17e8a28$var$getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","div","tabIndex","ref","onKeyDown","Object","assign","displayName","candidates","candidate","$d3863c46a17e8a28$var$findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","$d3863c46a17e8a28$var$isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","$d3863c46a17e8a28$var$isSelectableInput","HTMLInputElement","focus","preventScroll","$d3863c46a17e8a28$var$createFocusScopesStack","stack","activeFocusScope","$d3863c46a17e8a28$var$arrayRemove","unshift","_stack$","array","item","updatedArray","index","indexOf","splice","items","filter","$d3863c46a17e8a28$export$be92b6f5f03c0fe9","FocusScope","Root"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@radix-ui/react-focus-scope/dist/index.module.js"],"sourcesContent":["import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport {forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement} from \"react\";\nimport {useComposedRefs as $45QHv$useComposedRefs} from \"@radix-ui/react-compose-refs\";\nimport {Primitive as $45QHv$Primitive} from \"@radix-ui/react-primitive\";\nimport {useCallbackRef as $45QHv$useCallbackRef} from \"@radix-ui/react-use-callback-ref\";\n\n\n\n\n\n\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n    bubbles: false,\n    cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/ const $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/ $45QHv$forwardRef((props, forwardedRef)=>{\n    const { loop: loop = false , trapped: trapped = false , onMountAutoFocus: onMountAutoFocusProp , onUnmountAutoFocus: onUnmountAutoFocusProp , ...scopeProps } = props;\n    const [container1, setContainer] = $45QHv$useState(null);\n    const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n    const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n    const lastFocusedElementRef = $45QHv$useRef(null);\n    const composedRefs = $45QHv$useComposedRefs(forwardedRef, (node)=>setContainer(node)\n    );\n    const focusScope = $45QHv$useRef({\n        paused: false,\n        pause () {\n            this.paused = true;\n        },\n        resume () {\n            this.paused = false;\n        }\n    }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n    $45QHv$useEffect(()=>{\n        if (trapped) {\n            function handleFocusIn(event) {\n                if (focusScope.paused || !container1) return;\n                const target = event.target;\n                if (container1.contains(target)) lastFocusedElementRef.current = target;\n                else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n                    select: true\n                });\n            }\n            function handleFocusOut(event) {\n                if (focusScope.paused || !container1) return;\n                if (!container1.contains(event.relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n                    select: true\n                });\n            }\n            document.addEventListener('focusin', handleFocusIn);\n            document.addEventListener('focusout', handleFocusOut);\n            return ()=>{\n                document.removeEventListener('focusin', handleFocusIn);\n                document.removeEventListener('focusout', handleFocusOut);\n            };\n        }\n    }, [\n        trapped,\n        container1,\n        focusScope.paused\n    ]);\n    $45QHv$useEffect(()=>{\n        if (container1) {\n            $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n            const previouslyFocusedElement = document.activeElement;\n            const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n            if (!hasFocusedCandidate) {\n                const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n                container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n                container1.dispatchEvent(mountEvent);\n                if (!mountEvent.defaultPrevented) {\n                    $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n                        select: true\n                    });\n                    if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n                }\n            }\n            return ()=>{\n                container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n                // We need to delay the focus a little to get around it for now.\n                // See: https://github.com/facebook/react/issues/17894\n                setTimeout(()=>{\n                    const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n                    container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n                    container1.dispatchEvent(unmountEvent);\n                    if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n                        select: true\n                    });\n                     // we need to remove the listener after we `dispatchEvent`\n                    container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n                    $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n                }, 0);\n            };\n        }\n    }, [\n        container1,\n        onMountAutoFocus,\n        onUnmountAutoFocus,\n        focusScope\n    ]); // Takes care of looping focus (when tabbing whilst at the edges)\n    const handleKeyDown = $45QHv$useCallback((event)=>{\n        if (!loop && !trapped) return;\n        if (focusScope.paused) return;\n        const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n        const focusedElement = document.activeElement;\n        if (isTabKey && focusedElement) {\n            const container = event.currentTarget;\n            const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n            const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n            if (!hasTabbableElementsInside) {\n                if (focusedElement === container) event.preventDefault();\n            } else {\n                if (!event.shiftKey && focusedElement === last) {\n                    event.preventDefault();\n                    if (loop) $d3863c46a17e8a28$var$focus(first, {\n                        select: true\n                    });\n                } else if (event.shiftKey && focusedElement === first) {\n                    event.preventDefault();\n                    if (loop) $d3863c46a17e8a28$var$focus(last, {\n                        select: true\n                    });\n                }\n            }\n        }\n    }, [\n        loop,\n        trapped,\n        focusScope.paused\n    ]);\n    return /*#__PURE__*/ $45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n        tabIndex: -1\n    }, scopeProps, {\n        ref: composedRefs,\n        onKeyDown: handleKeyDown\n    }));\n});\n/*#__PURE__*/ Object.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n    displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */ function $d3863c46a17e8a28$var$focusFirst(candidates, { select: select = false  } = {}) {\n    const previouslyFocusedElement = document.activeElement;\n    for (const candidate of candidates){\n        $d3863c46a17e8a28$var$focus(candidate, {\n            select: select\n        });\n        if (document.activeElement !== previouslyFocusedElement) return;\n    }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */ function $d3863c46a17e8a28$var$getTabbableEdges(container) {\n    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n    const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n    const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n    return [\n        first,\n        last\n    ];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */ function $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n    const nodes = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: (node)=>{\n            const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n            if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n            // runtime's understanding of tabbability, so this automatically accounts\n            // for any kind of element that could be tabbed to.\n            return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n        }\n    });\n    while(walker.nextNode())nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n    // hinders accessibility to have tab order different from visual order.\n    return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */ function $d3863c46a17e8a28$var$findVisible(elements, container) {\n    for (const element of elements){\n        // we stop checking if it's hidden at the `container` level (excluding)\n        if (!$d3863c46a17e8a28$var$isHidden(element, {\n            upTo: container\n        })) return element;\n    }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, { upTo: upTo  }) {\n    if (getComputedStyle(node).visibility === 'hidden') return true;\n    while(node){\n        // we stop at `upTo` (excluding it)\n        if (upTo !== undefined && node === upTo) return false;\n        if (getComputedStyle(node).display === 'none') return true;\n        node = node.parentElement;\n    }\n    return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n    return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element, { select: select = false  } = {}) {\n    // only focus if that element is focusable\n    if (element && element.focus) {\n        const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n        element.focus({\n            preventScroll: true\n        }); // only select if its not the same element, it supports selection and we need to select\n        if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n    }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/ const $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n    /** A stack of focus scopes, with the active one at the top */ let stack = [];\n    return {\n        add (focusScope) {\n            // pause the currently active focus scope (at the top of the stack)\n            const activeFocusScope = stack[0];\n            if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n             // remove in case it already exists (because we'll re-add it at the top of the stack)\n            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n            stack.unshift(focusScope);\n        },\n        remove (focusScope) {\n            var _stack$;\n            stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n            (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n        }\n    };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n    const updatedArray = [\n        ...array\n    ];\n    const index = updatedArray.indexOf(item);\n    if (index !== -1) updatedArray.splice(index, 1);\n    return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n    return items.filter((item)=>item.tagName !== 'A'\n    );\n}\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\n\n\n\n\nexport {$d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}