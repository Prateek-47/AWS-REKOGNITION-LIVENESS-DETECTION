{"ast":null,"code":"import _asyncToGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n  constructor(options) {\n    if (typeof options === \"function\") {\n      this.configProvider = options().then(opts => opts || {});\n    } else {\n      this.config = options ?? {};\n      this.configProvider = Promise.resolve(this.config);\n    }\n  }\n\n  destroy() {}\n\n  handle(request, {\n    abortSignal\n  } = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this.config) {\n        _this.config = yield _this.configProvider;\n      }\n\n      const requestTimeoutInMs = _this.config.requestTimeout;\n\n      if (abortSignal?.aborted) {\n        const abortError = new Error(\"Request aborted\");\n        abortError.name = \"AbortError\";\n        return Promise.reject(abortError);\n      }\n\n      let path = request.path;\n      const queryString = buildQueryString(request.query || {});\n\n      if (queryString) {\n        path += `?${queryString}`;\n      }\n\n      if (request.fragment) {\n        path += `#${request.fragment}`;\n      }\n\n      let auth = \"\";\n\n      if (request.username != null || request.password != null) {\n        const username = request.username ?? \"\";\n        const password = request.password ?? \"\";\n        auth = `${username}:${password}@`;\n      }\n\n      const {\n        port,\n        method\n      } = request;\n      const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n      const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n      const requestOptions = {\n        body,\n        headers: new Headers(request.headers),\n        method: method\n      };\n\n      if (typeof AbortController !== \"undefined\") {\n        requestOptions[\"signal\"] = abortSignal;\n      }\n\n      const fetchRequest = new Request(url, requestOptions);\n      const raceOfPromises = [fetch(fetchRequest).then(response => {\n        const fetchHeaders = response.headers;\n        const transformedHeaders = {};\n\n        for (const pair of fetchHeaders.entries()) {\n          transformedHeaders[pair[0]] = pair[1];\n        }\n\n        const hasReadableStream = response.body != undefined;\n\n        if (!hasReadableStream) {\n          return response.blob().then(body => ({\n            response: new HttpResponse({\n              headers: transformedHeaders,\n              reason: response.statusText,\n              statusCode: response.status,\n              body\n            })\n          }));\n        }\n\n        return {\n          response: new HttpResponse({\n            headers: transformedHeaders,\n            reason: response.statusText,\n            statusCode: response.status,\n            body: response.body\n          })\n        };\n      }), requestTimeout(requestTimeoutInMs)];\n\n      if (abortSignal) {\n        raceOfPromises.push(new Promise((resolve, reject) => {\n          abortSignal.onabort = () => {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            reject(abortError);\n          };\n        }));\n      }\n\n      return Promise.race(raceOfPromises);\n    })();\n  }\n\n}","map":{"version":3,"names":["HttpResponse","buildQueryString","requestTimeout","FetchHttpHandler","constructor","options","configProvider","then","opts","config","Promise","resolve","destroy","handle","request","abortSignal","requestTimeoutInMs","aborted","abortError","Error","name","reject","path","queryString","query","fragment","auth","username","password","port","method","url","protocol","hostname","body","undefined","requestOptions","headers","Headers","AbortController","fetchRequest","Request","raceOfPromises","fetch","response","fetchHeaders","transformedHeaders","pair","entries","hasReadableStream","blob","reason","statusText","statusCode","status","push","onabort","race"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/fetch-http-handler/dist-es/fetch-http-handler.js"],"sourcesContent":["import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n    constructor(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then((opts) => opts || {});\n        }\n        else {\n            this.config = options ?? {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n    }\n    destroy() {\n    }\n    async handle(request, { abortSignal } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        const requestTimeoutInMs = this.config.requestTimeout;\n        if (abortSignal?.aborted) {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        let path = request.path;\n        const queryString = buildQueryString(request.query || {});\n        if (queryString) {\n            path += `?${queryString}`;\n        }\n        if (request.fragment) {\n            path += `#${request.fragment}`;\n        }\n        let auth = \"\";\n        if (request.username != null || request.password != null) {\n            const username = request.username ?? \"\";\n            const password = request.password ?? \"\";\n            auth = `${username}:${password}@`;\n        }\n        const { port, method } = request;\n        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n        const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n        const requestOptions = {\n            body,\n            headers: new Headers(request.headers),\n            method: method,\n        };\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions[\"signal\"] = abortSignal;\n        }\n        const fetchRequest = new Request(url, requestOptions);\n        const raceOfPromises = [\n            fetch(fetchRequest).then((response) => {\n                const fetchHeaders = response.headers;\n                const transformedHeaders = {};\n                for (const pair of fetchHeaders.entries()) {\n                    transformedHeaders[pair[0]] = pair[1];\n                }\n                const hasReadableStream = response.body != undefined;\n                if (!hasReadableStream) {\n                    return response.blob().then((body) => ({\n                        response: new HttpResponse({\n                            headers: transformedHeaders,\n                            reason: response.statusText,\n                            statusCode: response.status,\n                            body,\n                        }),\n                    }));\n                }\n                return {\n                    response: new HttpResponse({\n                        headers: transformedHeaders,\n                        reason: response.statusText,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise((resolve, reject) => {\n                abortSignal.onabort = () => {\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n            }));\n        }\n        return Promise.race(raceOfPromises);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}