{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PredicateInternalsKey } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\n\n\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\n\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\n\n\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\n\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\n\nvar FieldCondition =\n/** @class */\nfunction () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n\n\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n  /**\n   * Produces a tree structure similar to a graphql condition. The returned\n   * structure is \"dumb\" and is intended for another query/condition\n   * generation mechanism to interpret, such as the cloud or storage query\n   * builders.\n   *\n   * E.g.,\n   *\n   * ```json\n   * {\n   * \t\"name\": {\n   * \t\t\"eq\": \"robert\"\n   * \t}\n   * }\n   * ```\n   */\n\n\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n   * matches the opposite of this condition.\n   *\n   * Intended to be used when applying De Morgan's Law, which can be done to\n   * produce more efficient queries against the storage layer if a negation\n   * appears in the query tree.\n   *\n   * For example:\n   *\n   * 1. `name.eq('robert')` becomes `name.ne('robert')`\n   * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n   *\n   * @param model The model meta to use when construction a new `GroupCondition`\n   * for cases where the negation requires multiple `FieldCondition`'s.\n   */\n\n\n  FieldCondition.prototype.negated = function (model) {\n    if (this.operator === 'between') {\n      return new GroupCondition(model, undefined, undefined, 'or', [new FieldCondition(this.field, 'lt', [this.operands[0]]), new FieldCondition(this.field, 'gt', [this.operands[1]])]);\n    } else if (this.operator === 'beginsWith') {\n      // beginsWith negation doesn't have a good, safe optimation right now.\n      // just re-wrap it in negation. The adapter will have to scan-and-filter,\n      // as is likely optimal for negated beginsWith conditions *anyway*.\n      return new GroupCondition(model, undefined, undefined, 'not', [new FieldCondition(this.field, 'beginsWith', [this.operands[0]])]);\n    } else {\n      return new FieldCondition(this.field, negations[this.operator], this.operands);\n    }\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n\n\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n\n\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation, result;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        v = item[this.field];\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return (v === null || v === void 0 ? void 0 : v.indexOf(_this.operands[0])) > -1;\n          },\n          notContains: function () {\n            return !v ? true : v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v === null || v === void 0 ? void 0 : v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n\n        if (operation) {\n          result = operation();\n          return [2\n          /*return*/\n          , result];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n\n\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n\n\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    }; // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n\n\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n\n  return FieldCondition;\n}();\n\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\n\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\n\n\nvar GroupCondition =\n/** @class */\nfunction () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands,\n  /**\n   * Whether this GroupCondition is the result of an optimize call.\n   *\n   * This is used to guard against infinitely fetch -> optimize -> fetch\n   * recursion.\n   */\n  isOptimized) {\n    if (isOptimized === void 0) {\n      isOptimized = false;\n    }\n\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    this.isOptimized = isOptimized; // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n\n\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n          operandCopy = _a[0],\n          extractedFromOperand = _a[1];\n\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Creates a new `GroupCondition` that contains only the local field conditions,\n   * omitting related model conditions. That resulting `GroupCondition` can be\n   * used to produce predicates that are compatible with the storage adapters and\n   * Cloud storage.\n   *\n   * @param negate Whether the condition tree should be negated according\n   * to De Morgan's law.\n   */\n\n\n  GroupCondition.prototype.withFieldConditionsOnly = function (negate) {\n    var _this = this;\n\n    var negateChildren = negate !== (this.operator === 'not');\n    return new GroupCondition(this.model, undefined, undefined, negate ? negations[this.operator] : this.operator, this.operands.filter(function (o) {\n      return o instanceof FieldCondition;\n    }).map(function (o) {\n      return negateChildren ? o.negated(_this.model) : o;\n    }));\n  };\n  /**\n   * Returns a version of the predicate tree with unnecessary logical groups\n   * condensed and merged together. This is intended to create a dense tree\n   * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n   * as possible for the most efficient fetching possible -- it allows `fetch()`.\n   *\n   * E.g. a grouping like this:\n   *\n   * ```yaml\n   * and:\n   * \tand:\n   * \t\tid:\n   * \t\t\teq: \"abc\"\n   * \tand:\n   * \t\tname:\n   * \t\t\teq: \"xyz\"\n   * ```\n   *\n   * Will become this:\n   *\n   * ```yaml\n   * and:\n   * \tid:\n   * \t\teq: \"abc\"\n   * \tname:\n   * \t\teq: \"xyz\"\n   * ```\n   *\n   * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n   * together, which can then decide what index to use based on both fields together.\n   *\n   * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n   * it during optimization. Used internally to preserve the root node and children of\n   * `not` groups. `not` groups will always have a single child, so there's nothing to\n   * optimize below a `not` (for now), and it makes the query logic simpler later.\n   */\n\n\n  GroupCondition.prototype.optimized = function (preserveNode) {\n    var _this = this;\n\n    if (preserveNode === void 0) {\n      preserveNode = true;\n    }\n\n    var operands = this.operands.map(function (o) {\n      return o instanceof GroupCondition ? o.optimized(_this.operator === 'not') : o;\n    }); // we're only collapsing and/or groups that contains a single child for now,\n    // because they're much more common and much more trivial to collapse. basically,\n    // an `and`/`or` that contains a single child doesn't require the layer of\n    // logical grouping.\n\n    if (!preserveNode && ['and', 'or'].includes(this.operator) && !this.field && operands.length === 1) {\n      var operand = operands[0];\n\n      if (operand instanceof FieldCondition) {\n        // between conditions should NOT be passed up the chain. if they\n        // need to be *negated* later, it is important that they be properly\n        // contained in an AND group. when de morgan's law is applied, the\n        // conditions are reversed and the AND group flips to an OR. this\n        // doesn't work right if the a `between` doesn't live in an AND group.\n        if (operand.operator !== 'between') {\n          return operand;\n        }\n      } else {\n        return operand;\n      }\n    }\n\n    return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n\n\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n\n    if (negate === void 0) {\n      negate = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, allJoinConditions, relatives_1, relatives_1_1, relative, relativeConditions, i, predicate, _a, _b, e_1_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n\n      var e_1, _j, e_2, _k, _l, e_3, _m, e_4, _o, e_5, _p, e_6, _q;\n\n      var _this = this;\n\n      return __generator(this, function (_r) {\n        switch (_r.label) {\n          case 0:\n            if (!this.isOptimized) {\n              return [2\n              /*return*/\n              , this.optimized().fetch(storage)];\n            }\n\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _r.label = 1;\n\n          case 1:\n            _r.trys.push([1, 10, 11, 12]);\n\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _r.label = 2;\n\n          case 2:\n            if (!!groups_1_1.done) return [3\n            /*break*/\n            , 9];\n            g = groups_1_1.value;\n            return [4\n            /*yield*/\n            , g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n\n          case 3:\n            relatives = _r.sent(); // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2\n                /*return*/\n                , []];\n              } // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n\n\n              resultGroups.push([]);\n              return [3\n              /*break*/\n              , 8];\n            }\n\n            if (!g.field) return [3\n            /*break*/\n            , 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3\n            /*break*/\n            , 5];\n            allJoinConditions = [];\n\n            try {\n              for (relatives_1 = (e_2 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n                relativeConditions = [];\n\n                for (i = 0; i < relationship.localJoinFields.length; i++) {\n                  relativeConditions.push((_l = {}, _l[relationship.localJoinFields[i]] = {\n                    eq: relative[relationship.remoteJoinFields[i]]\n                  }, _l));\n                }\n\n                allJoinConditions.push({\n                  and: relativeConditions\n                });\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n\n            predicate = FlatModelPredicateCreator.createFromAST(this.model.schema, {\n              or: allJoinConditions\n            });\n            _b = (_a = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder, predicate)];\n\n          case 4:\n            _b.apply(_a, [_r.sent()]);\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            throw new Error('Missing field metadata.');\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _r.label = 8;\n\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3\n            /*break*/\n            , 2];\n\n          case 9:\n            return [3\n            /*break*/\n            , 12];\n\n          case 10:\n            e_1_1 = _r.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3\n            /*break*/\n            , 12];\n\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 12:\n            if (!(conditions.length > 0)) return [3\n            /*break*/\n            , 14];\n            predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n            _d = (_c = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder, predicate)];\n\n          case 13:\n            _d.apply(_c, [_r.sent()]);\n\n            return [3\n            /*break*/\n            , 16];\n\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3\n            /*break*/\n            , 16];\n            _f = (_e = resultGroups).push;\n            return [4\n            /*yield*/\n            , storage.query(this.model.builder)];\n\n          case 15:\n            _f.apply(_e, [_r.sent()]);\n\n            _r.label = 16;\n\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2\n                /*return*/\n                , []];\n              }\n\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n\n                    try {\n                      for (_g = (e_4 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_4_1) {\n                      e_4 = {\n                        error: e_4_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_o = _g.return)) _o.call(_g);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_m = resultGroups_1.return)) _m.call(resultGroups_1);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n\n                  try {\n                    for (group_1 = (e_6 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_6_1) {\n                    e_6 = {\n                      error: e_6_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_q = group_1.return)) _q.call(group_1);\n                    } finally {\n                      if (e_6) throw e_6.error;\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_p = resultGroups_2.return)) _p.call(resultGroups_2);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            }\n\n            return [2\n            /*return*/\n            , Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n\n\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n\n    var e_7, _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_7_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , item[this.field]];\n\n          case 1:\n            _b = _c.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            _b = item;\n            _c.label = 3;\n\n          case 3:\n            itemToCheck = _b; // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n\n            if (!itemToCheck) {\n              return [2\n              /*return*/\n              , false];\n            }\n\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3\n            /*break*/\n            , 17];\n            _c.label = 4;\n\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n\n          case 5:\n            return [4\n            /*yield*/\n            , itemToCheck_1.next()];\n\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3\n            /*break*/\n            , 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4\n            /*yield*/\n            , this.matches(singleItem, true)];\n\n          case 7:\n            if (_c.sent()) {\n              return [2\n              /*return*/\n              , true];\n            }\n\n            _c.label = 8;\n\n          case 8:\n            return [3\n            /*break*/\n            , 5];\n\n          case 9:\n            return [3\n            /*break*/\n            , 16];\n\n          case 10:\n            e_7_1 = _c.sent();\n            e_7 = {\n              error: e_7_1\n            };\n            return [3\n            /*break*/\n            , 16];\n\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3\n            /*break*/\n            , 13];\n            return [4\n            /*yield*/\n            , _a.call(itemToCheck_1)];\n\n          case 12:\n            _c.sent();\n\n            _c.label = 13;\n\n          case 13:\n            return [3\n            /*break*/\n            , 15];\n\n          case 14:\n            if (e_7) throw e_7.error;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 15:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 16:\n            return [2\n            /*return*/\n            , false];\n\n          case 17:\n            if (!(this.operator === 'or')) return [3\n            /*break*/\n            , 18];\n            return [2\n            /*return*/\n            , asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n\n          case 18:\n            if (!(this.operator === 'and')) return [3\n            /*break*/\n            , 19];\n            return [2\n            /*return*/\n            , asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n\n          case 19:\n            if (!(this.operator === 'not')) return [3\n            /*break*/\n            , 21];\n\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n\n            return [4\n            /*yield*/\n            , this.operands[0].matches(itemToCheck)];\n\n          case 20:\n            return [2\n            /*return*/\n            , !_c.sent()];\n\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n\n\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n  /**\n   * Turn this predicate group into something a storage adapter\n   * understands how to use.\n   */\n\n\n  GroupCondition.prototype.toStoragePredicate = function () {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n  /**\n   * A JSON representation that's good for debugging.\n   */\n\n\n  GroupCondition.prototype.toJSON = function () {\n    return __assign(__assign({}, this), {\n      model: this.model.schema.name\n    });\n  };\n\n  return GroupCondition;\n}();\n\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\n\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  } // to be used if we don't have a base query or tail to build onto\n\n\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter; // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n\n  var link = {}; // so it can be looked up later with in the internals when processing conditions.\n\n  registerPredicateInternals(baseCondition, link);\n\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n        query = _a[0],\n        newTail = _a[1];\n\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  }; // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n\n\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n          query = _a.query,\n          newTail = _a.newTail;\n\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      } // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n\n\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      }))); // FinalPredicate\n\n      return registerPredicateInternals(query);\n    };\n  }); // TODO: If revisiting this code, consider proxy.\n\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail; // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n\n\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))])); // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n\n    return registerPredicateInternals(query);\n  };\n\n  var _loop_1 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.allFields[fieldName];\n\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              } // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n\n\n              var _a = copyLink(),\n                  query = _a.query,\n                  newTail = _a.newTail; // normalize operands. if any of the values are `undefiend`, use\n              // `null` instead, because that's what will be stored cross-platform.\n\n\n              var normalizedOperands = operands.map(function (o) {\n                return o === undefined ? null : o;\n              }); // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, normalizedOperands)); // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            } // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n\n\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n                newquery = _a[0],\n                oldtail = _a[1];\n\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []); // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  }; // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n\n\n  for (var fieldName in ModelType.schema.allFields) {\n    _loop_1(fieldName);\n  }\n\n  return link;\n}\nexport function predicateFor(ModelType) {\n  // the cast here is just a cheap way to reduce the surface area from\n  // the recursive type.\n  return recursivePredicateFor(ModelType, false);\n}","map":{"version":3,"names":["__assign","__asyncValues","__awaiter","__generator","__read","__spread","__values","PredicateInternalsKey","ModelPredicateCreator","FlatModelPredicateCreator","comparisonKeys","ModelRelationship","asyncSome","asyncEvery","ops","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","FieldCondition","field","operator","operands","validate","prototype","copy","extract","undefined","toAST","_a","_b","negated","model","GroupCondition","fetch","storage","Promise","reject","matches","item","v","operations","operation","result","_this","indexOf","beginsWith","startsWith","between","argumentCount","count","argsClause","length","validations","e","getGroupId","seed","relationshipType","isOptimized","groupId","copied","extractedCopy","forEach","o","operandCopy","extractedFromOperand","push","withFieldConditionsOnly","negate","negateChildren","filter","map","optimized","preserveNode","includes","operand","breadcrumb","resultGroups","groups","conditions","groups_1","groups_1_1","g","relatives","relationship","allJoinConditions","relatives_1","relatives_1_1","relative","relativeConditions","i","predicate","e_1_1","_c","_d","_e","_f","getPKValue","resultIndex","resultGroups_1","resultGroups_1_1","group","intersectWith","_g","_h","k","resultGroups_2","resultGroups_2_1","group_1","group_1_1","e_1","_j","e_2","_k","_l","e_3","_m","e_4","_o","e_5","_p","e_6","_q","_r","label","op","trys","next","done","value","sent","from","localJoinFields","remoteJoinFields","e_2_1","error","return","call","createFromAST","schema","query","builder","apply","toStoragePredicate","JSON","stringify","pkField","name","keys","delete","e_4_1","e_3_1","e_6_1","e_5_1","Array","values","ignoreFieldName","e_7","itemToCheck","itemToCheck_1","itemToCheck_1_1","singleItem","e_7_1","Symbol","asyncIterator","c","toJSON","recursivePredicateFor","ModelType","allowRecursion","tail","starter","baseCondition","tailCondition","link","copyLink","newTail","newLink","childConditions","isArray","_loop_1","fieldName","Object","defineProperty","enumerable","def","allFields","association","reduce","fieldMatcher","_i","arguments","normalizedOperands","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/datastore/lib-esm/predicates/next.js"],"sourcesContent":["import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PredicateInternalsKey, } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys, } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nvar registerPredicateInternals = function (condition, key) {\n    var finalKey = key || new PredicateInternalsKey();\n    predicateInternalsMap.set(finalKey, condition);\n    return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport var internals = function (key) {\n    if (!predicateInternalsMap.has(key)) {\n        throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n    }\n    return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nvar negations = {\n    and: 'or',\n    or: 'and',\n    not: 'and',\n    eq: 'ne',\n    ne: 'eq',\n    gt: 'le',\n    ge: 'lt',\n    lt: 'ge',\n    le: 'gt',\n    contains: 'notContains',\n    notContains: 'contains',\n};\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nvar FieldCondition = /** @class */ (function () {\n    function FieldCondition(field, operator, operands) {\n        this.field = field;\n        this.operator = operator;\n        this.operands = operands;\n        this.validate();\n    }\n    /**\n     * Creates a copy of self.\n     * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n     * @returns A new, identitical `FieldCondition`.\n     */\n    FieldCondition.prototype.copy = function (extract) {\n        return [\n            new FieldCondition(this.field, this.operator, __spread(this.operands)),\n            undefined,\n        ];\n    };\n    /**\n     * Produces a tree structure similar to a graphql condition. The returned\n     * structure is \"dumb\" and is intended for another query/condition\n     * generation mechanism to interpret, such as the cloud or storage query\n     * builders.\n     *\n     * E.g.,\n     *\n     * ```json\n     * {\n     * \t\"name\": {\n     * \t\t\"eq\": \"robert\"\n     * \t}\n     * }\n     * ```\n     */\n    FieldCondition.prototype.toAST = function () {\n        var _a, _b;\n        return _a = {},\n            _a[this.field] = (_b = {},\n                _b[this.operator] = this.operator === 'between'\n                    ? [this.operands[0], this.operands[1]]\n                    : this.operands[0],\n                _b),\n            _a;\n    };\n    /**\n     * Produces a new condition (`FieldCondition` or `GroupCondition`) that\n     * matches the opposite of this condition.\n     *\n     * Intended to be used when applying De Morgan's Law, which can be done to\n     * produce more efficient queries against the storage layer if a negation\n     * appears in the query tree.\n     *\n     * For example:\n     *\n     * 1. `name.eq('robert')` becomes `name.ne('robert')`\n     * 2. `price.between(100, 200)` becomes `m => m.or(m => [m.price.lt(100), m.price.gt(200)])`\n     *\n     * @param model The model meta to use when construction a new `GroupCondition`\n     * for cases where the negation requires multiple `FieldCondition`'s.\n     */\n    FieldCondition.prototype.negated = function (model) {\n        if (this.operator === 'between') {\n            return new GroupCondition(model, undefined, undefined, 'or', [\n                new FieldCondition(this.field, 'lt', [this.operands[0]]),\n                new FieldCondition(this.field, 'gt', [this.operands[1]]),\n            ]);\n        }\n        else if (this.operator === 'beginsWith') {\n            // beginsWith negation doesn't have a good, safe optimation right now.\n            // just re-wrap it in negation. The adapter will have to scan-and-filter,\n            // as is likely optimal for negated beginsWith conditions *anyway*.\n            return new GroupCondition(model, undefined, undefined, 'not', [\n                new FieldCondition(this.field, 'beginsWith', [this.operands[0]]),\n            ]);\n        }\n        else {\n            return new FieldCondition(this.field, negations[this.operator], this.operands);\n        }\n    };\n    /**\n     * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n     * transforms them into legacy predicates. (*For now.*)\n     * @param storage N/A. If ever implemented, the storage adapter to query.\n     * @returns N/A. If ever implemented, return items from `storage` that match.\n     */\n    FieldCondition.prototype.fetch = function (storage) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, Promise.reject('No implementation needed [yet].')];\n            });\n        });\n    };\n    /**\n     * Determins whether a given item matches the expressed condition.\n     * @param item The item to test.\n     * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n     */\n    FieldCondition.prototype.matches = function (item) {\n        return __awaiter(this, void 0, void 0, function () {\n            var v, operations, operation, result;\n            var _this = this;\n            return __generator(this, function (_a) {\n                v = item[this.field];\n                operations = {\n                    eq: function () { return v === _this.operands[0]; },\n                    ne: function () { return v !== _this.operands[0]; },\n                    gt: function () { return v > _this.operands[0]; },\n                    ge: function () { return v >= _this.operands[0]; },\n                    lt: function () { return v < _this.operands[0]; },\n                    le: function () { return v <= _this.operands[0]; },\n                    contains: function () { return (v === null || v === void 0 ? void 0 : v.indexOf(_this.operands[0])) > -1; },\n                    notContains: function () { return (!v ? true : v.indexOf(_this.operands[0]) === -1); },\n                    beginsWith: function () { return v === null || v === void 0 ? void 0 : v.startsWith(_this.operands[0]); },\n                    between: function () { return v >= _this.operands[0] && v <= _this.operands[1]; },\n                };\n                operation = operations[this.operator];\n                if (operation) {\n                    result = operation();\n                    return [2 /*return*/, result];\n                }\n                else {\n                    throw new Error(\"Invalid operator given: \" + this.operator);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Checks `this.operands` for compatibility with `this.operator`.\n     */\n    FieldCondition.prototype.validate = function () {\n        var _this = this;\n        /**\n         * Creates a validator that checks for a particular `operands` count.\n         * Throws an exception if the `count` disagrees with `operands.length`.\n         * @param count The number of `operands` expected.\n         */\n        var argumentCount = function (count) {\n            var argsClause = count === 1 ? 'argument is' : 'arguments are';\n            return function () {\n                if (_this.operands.length !== count) {\n                    return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n                }\n            };\n        };\n        // NOTE: validations should return a message on failure.\n        // hence, they should be \"joined\" together with logical OR's\n        // as seen in the `between:` entry.\n        var validations = {\n            eq: argumentCount(1),\n            ne: argumentCount(1),\n            gt: argumentCount(1),\n            ge: argumentCount(1),\n            lt: argumentCount(1),\n            le: argumentCount(1),\n            contains: argumentCount(1),\n            notContains: argumentCount(1),\n            beginsWith: argumentCount(1),\n            between: function () {\n                return argumentCount(2)() ||\n                    (_this.operands[0] > _this.operands[1]\n                        ? 'The first argument must be less than or equal to the second argument.'\n                        : null);\n            },\n        };\n        var validate = validations[this.operator];\n        if (validate) {\n            var e = validate();\n            if (typeof e === 'string')\n                throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n        }\n        else {\n            throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n        }\n    };\n    return FieldCondition;\n}());\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nvar getGroupId = (function () {\n    var seed = 1;\n    return function () { return \"group_\" + seed++; };\n})();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nvar GroupCondition = /** @class */ (function () {\n    function GroupCondition(\n    /**\n     * The `ModelMeta` of the model to query and/or filter against.\n     * Expected to contain:\n     *\n     * ```js\n     * {\n     * \tbuilder: ModelConstructor,\n     * \tschema: SchemaModel,\n     * \tpkField: string[]\n     * }\n     * ```\n     */\n    model, \n    /**\n     * If populated, this group specifices a condition on a relationship.\n     *\n     * If `field` does *not* point to a related model, that's an error. It\n     * could indicate that the `GroupCondition` was instantiated with bad\n     * data, or that the model metadata is incorrect.\n     */\n    field, \n    /**\n     * If a `field` is given, whether the relationship is a `HAS_ONE`,\n     * 'HAS_MANY`, or `BELONGS_TO`.\n     *\n     * TODO: Remove this and replace with derivation using\n     * `ModelRelationship.from(this.model, this.field).relationship`;\n     */\n    relationshipType, \n    /**\n     *\n     */\n    operator, \n    /**\n     *\n     */\n    operands, \n    /**\n     * Whether this GroupCondition is the result of an optimize call.\n     *\n     * This is used to guard against infinitely fetch -> optimize -> fetch\n     * recursion.\n     */\n    isOptimized) {\n        if (isOptimized === void 0) { isOptimized = false; }\n        this.model = model;\n        this.field = field;\n        this.relationshipType = relationshipType;\n        this.operator = operator;\n        this.operands = operands;\n        this.isOptimized = isOptimized;\n        // `groupId` was used for development/debugging.\n        // Should we leave this in for future troubleshooting?\n        this.groupId = getGroupId();\n    }\n    /**\n     * Returns a copy of a GroupCondition, which also returns the copy of a\n     * given reference node to \"extract\".\n     * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n     * @returns [The full copy, the copy of `extract` | undefined]\n     */\n    GroupCondition.prototype.copy = function (extract) {\n        var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n        var extractedCopy = extract === this ? copied : undefined;\n        this.operands.forEach(function (o) {\n            var _a = __read(o.copy(extract), 2), operandCopy = _a[0], extractedFromOperand = _a[1];\n            copied.operands.push(operandCopy);\n            extractedCopy = extractedCopy || extractedFromOperand;\n        });\n        return [copied, extractedCopy];\n    };\n    /**\n     * Creates a new `GroupCondition` that contains only the local field conditions,\n     * omitting related model conditions. That resulting `GroupCondition` can be\n     * used to produce predicates that are compatible with the storage adapters and\n     * Cloud storage.\n     *\n     * @param negate Whether the condition tree should be negated according\n     * to De Morgan's law.\n     */\n    GroupCondition.prototype.withFieldConditionsOnly = function (negate) {\n        var _this = this;\n        var negateChildren = negate !== (this.operator === 'not');\n        return new GroupCondition(this.model, undefined, undefined, (negate ? negations[this.operator] : this.operator), this.operands\n            .filter(function (o) { return o instanceof FieldCondition; })\n            .map(function (o) {\n            return negateChildren ? o.negated(_this.model) : o;\n        }));\n    };\n    /**\n     * Returns a version of the predicate tree with unnecessary logical groups\n     * condensed and merged together. This is intended to create a dense tree\n     * with leaf nodes (`FieldCondition`'s) aggregated under as few group conditions\n     * as possible for the most efficient fetching possible -- it allows `fetch()`.\n     *\n     * E.g. a grouping like this:\n     *\n     * ```yaml\n     * and:\n     * \tand:\n     * \t\tid:\n     * \t\t\teq: \"abc\"\n     * \tand:\n     * \t\tname:\n     * \t\t\teq: \"xyz\"\n     * ```\n     *\n     * Will become this:\n     *\n     * ```yaml\n     * and:\n     * \tid:\n     * \t\teq: \"abc\"\n     * \tname:\n     * \t\teq: \"xyz\"\n     * ```\n     *\n     * This allows `fetch()` to pass both the `id` and `name` conditions to the adapter\n     * together, which can then decide what index to use based on both fields together.\n     *\n     * @param preserveNode Whether to preserve the current node and to explicitly not eliminate\n     * it during optimization. Used internally to preserve the root node and children of\n     * `not` groups. `not` groups will always have a single child, so there's nothing to\n     * optimize below a `not` (for now), and it makes the query logic simpler later.\n     */\n    GroupCondition.prototype.optimized = function (preserveNode) {\n        var _this = this;\n        if (preserveNode === void 0) { preserveNode = true; }\n        var operands = this.operands.map(function (o) {\n            return o instanceof GroupCondition ? o.optimized(_this.operator === 'not') : o;\n        });\n        // we're only collapsing and/or groups that contains a single child for now,\n        // because they're much more common and much more trivial to collapse. basically,\n        // an `and`/`or` that contains a single child doesn't require the layer of\n        // logical grouping.\n        if (!preserveNode &&\n            ['and', 'or'].includes(this.operator) &&\n            !this.field &&\n            operands.length === 1) {\n            var operand = operands[0];\n            if (operand instanceof FieldCondition) {\n                // between conditions should NOT be passed up the chain. if they\n                // need to be *negated* later, it is important that they be properly\n                // contained in an AND group. when de morgan's law is applied, the\n                // conditions are reversed and the AND group flips to an OR. this\n                // doesn't work right if the a `between` doesn't live in an AND group.\n                if (operand.operator !== 'between') {\n                    return operand;\n                }\n            }\n            else {\n                return operand;\n            }\n        }\n        return new GroupCondition(this.model, this.field, this.relationshipType, this.operator, operands, true);\n    };\n    /**\n     * Fetches matching records from a given storage adapter using legacy predicates (for now).\n     * @param storage The storage adapter this predicate will query against.\n     * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n     * GroupdCondition.fetch is nested within.\n     * @param negate Whether to match on the `NOT` of `this`.\n     * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n     */\n    GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n        if (breadcrumb === void 0) { breadcrumb = []; }\n        if (negate === void 0) { negate = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, allJoinConditions, relatives_1, relatives_1_1, relative, relativeConditions, i, predicate, _a, _b, e_1_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n            var e_1, _j, e_2, _k, _l, e_3, _m, e_4, _o, e_5, _p, e_6, _q;\n            var _this = this;\n            return __generator(this, function (_r) {\n                switch (_r.label) {\n                    case 0:\n                        if (!this.isOptimized) {\n                            return [2 /*return*/, this.optimized().fetch(storage)];\n                        }\n                        resultGroups = [];\n                        operator = (negate ? negations[this.operator] : this.operator);\n                        negateChildren = negate !== (this.operator === 'not');\n                        groups = this.operands.filter(function (op) { return op instanceof GroupCondition; });\n                        conditions = this.operands.filter(function (op) { return op instanceof FieldCondition; });\n                        _r.label = 1;\n                    case 1:\n                        _r.trys.push([1, 10, 11, 12]);\n                        groups_1 = __values(groups), groups_1_1 = groups_1.next();\n                        _r.label = 2;\n                    case 2:\n                        if (!!groups_1_1.done) return [3 /*break*/, 9];\n                        g = groups_1_1.value;\n                        return [4 /*yield*/, g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n                    case 3:\n                        relatives = _r.sent();\n                        // no relatives -> no need to attempt to perform a \"join\" query for\n                        // candidate results:\n                        //\n                        // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n                        //\n                        // Additionally, the entire (sub)-query can be short-circuited if\n                        // the operator is `AND`. Illustrated in SQL:\n                        //\n                        // select a.* from a where\n                        //   id in [a,b,c]\n                        //     AND                        <\n                        //   id in EMTPY_SET            <<< Look!\n                        //     AND                        <\n                        //   id in [x,y,z]\n                        //\n                        // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n                        //\n                        if (relatives.length === 0) {\n                            // aggressively short-circuit as soon as we know the group condition will fail\n                            if (operator === 'and') {\n                                return [2 /*return*/, []];\n                            }\n                            // less aggressive short-circuit if we know the relatives will produce no\n                            // candidate results; but aren't sure yet how this affects the group condition.\n                            resultGroups.push([]);\n                            return [3 /*break*/, 8];\n                        }\n                        if (!g.field) return [3 /*break*/, 7];\n                        relationship = ModelRelationship.from(this.model, g.field);\n                        if (!relationship) return [3 /*break*/, 5];\n                        allJoinConditions = [];\n                        try {\n                            for (relatives_1 = (e_2 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                                relative = relatives_1_1.value;\n                                relativeConditions = [];\n                                for (i = 0; i < relationship.localJoinFields.length; i++) {\n                                    relativeConditions.push((_l = {},\n                                        _l[relationship.localJoinFields[i]] = {\n                                            eq: relative[relationship.remoteJoinFields[i]],\n                                        },\n                                        _l));\n                                }\n                                allJoinConditions.push({ and: relativeConditions });\n                            }\n                        }\n                        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                        finally {\n                            try {\n                                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n                            }\n                            finally { if (e_2) throw e_2.error; }\n                        }\n                        predicate = FlatModelPredicateCreator.createFromAST(this.model.schema, {\n                            or: allJoinConditions,\n                        });\n                        _b = (_a = resultGroups).push;\n                        return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n                    case 4:\n                        _b.apply(_a, [_r.sent()]);\n                        return [3 /*break*/, 6];\n                    case 5: throw new Error('Missing field metadata.');\n                    case 6: return [3 /*break*/, 8];\n                    case 7:\n                        // relatives are not actually relatives. they're candidate results.\n                        resultGroups.push(relatives);\n                        _r.label = 8;\n                    case 8:\n                        groups_1_1 = groups_1.next();\n                        return [3 /*break*/, 2];\n                    case 9: return [3 /*break*/, 12];\n                    case 10:\n                        e_1_1 = _r.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 11:\n                        try {\n                            if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                        return [7 /*endfinally*/];\n                    case 12:\n                        if (!(conditions.length > 0)) return [3 /*break*/, 14];\n                        predicate = this.withFieldConditionsOnly(negateChildren).toStoragePredicate();\n                        _d = (_c = resultGroups).push;\n                        return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n                    case 13:\n                        _d.apply(_c, [_r.sent()]);\n                        return [3 /*break*/, 16];\n                    case 14:\n                        if (!(conditions.length === 0 && resultGroups.length === 0)) return [3 /*break*/, 16];\n                        _f = (_e = resultGroups).push;\n                        return [4 /*yield*/, storage.query(this.model.builder)];\n                    case 15:\n                        _f.apply(_e, [_r.sent()]);\n                        _r.label = 16;\n                    case 16:\n                        getPKValue = function (item) {\n                            return JSON.stringify(_this.model.pkField.map(function (name) { return item[name]; }));\n                        };\n                        if (operator === 'and') {\n                            if (resultGroups.length === 0) {\n                                return [2 /*return*/, []];\n                            }\n                            try {\n                                // for each group, we intersect, removing items from the result index\n                                // that aren't present in each subsequent group.\n                                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                                    group = resultGroups_1_1.value;\n                                    if (resultIndex === undefined) {\n                                        resultIndex = new Map(group.map(function (item) { return [getPKValue(item), item]; }));\n                                    }\n                                    else {\n                                        intersectWith = new Map(group.map(function (item) { return [getPKValue(item), item]; }));\n                                        try {\n                                            for (_g = (e_4 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                                                k = _h.value;\n                                                if (!intersectWith.has(k)) {\n                                                    resultIndex.delete(k);\n                                                }\n                                            }\n                                        }\n                                        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                        finally {\n                                            try {\n                                                if (_h && !_h.done && (_o = _g.return)) _o.call(_g);\n                                            }\n                                            finally { if (e_4) throw e_4.error; }\n                                        }\n                                    }\n                                }\n                            }\n                            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                            finally {\n                                try {\n                                    if (resultGroups_1_1 && !resultGroups_1_1.done && (_m = resultGroups_1.return)) _m.call(resultGroups_1);\n                                }\n                                finally { if (e_3) throw e_3.error; }\n                            }\n                        }\n                        else if (operator === 'or' || operator === 'not') {\n                            // it's OK to handle NOT here, because NOT must always only negate\n                            // a single child predicate. NOT logic will have been distributed down\n                            // to the leaf conditions already.\n                            resultIndex = new Map();\n                            try {\n                                // just merge the groups, performing DISTINCT-ification by ID.\n                                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                                    group = resultGroups_2_1.value;\n                                    try {\n                                        for (group_1 = (e_6 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                                            item = group_1_1.value;\n                                            resultIndex.set(getPKValue(item), item);\n                                        }\n                                    }\n                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                                    finally {\n                                        try {\n                                            if (group_1_1 && !group_1_1.done && (_q = group_1.return)) _q.call(group_1);\n                                        }\n                                        finally { if (e_6) throw e_6.error; }\n                                    }\n                                }\n                            }\n                            catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                            finally {\n                                try {\n                                    if (resultGroups_2_1 && !resultGroups_2_1.done && (_p = resultGroups_2.return)) _p.call(resultGroups_2);\n                                }\n                                finally { if (e_5) throw e_5.error; }\n                            }\n                        }\n                        return [2 /*return*/, Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n                }\n            });\n        });\n    };\n    /**\n     * Determines whether a single item matches the conditions of `this`.\n     * When checking the target `item`'s properties, each property will be `await`'d\n     * to ensure lazy-loading is respected where applicable.\n     * @param item The item to match against.\n     * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n     * (Used for iterating over children on HAS_MANY checks.)\n     * @returns A boolean (promise): `true` if matched, `false` otherwise.\n     */\n    GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n        if (ignoreFieldName === void 0) { ignoreFieldName = false; }\n        var e_7, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_7_1;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        if (!(this.field && !ignoreFieldName)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, item[this.field]];\n                    case 1:\n                        _b = _c.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        _b = item;\n                        _c.label = 3;\n                    case 3:\n                        itemToCheck = _b;\n                        // if there is no item to check, we can stop recursing immediately.\n                        // a condition cannot match against an item that does not exist. this\n                        // can occur when `item.field` is optional in the schema.\n                        if (!itemToCheck) {\n                            return [2 /*return*/, false];\n                        }\n                        if (!(this.relationshipType === 'HAS_MANY' &&\n                            typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3 /*break*/, 17];\n                        _c.label = 4;\n                    case 4:\n                        _c.trys.push([4, 10, 11, 16]);\n                        itemToCheck_1 = __asyncValues(itemToCheck);\n                        _c.label = 5;\n                    case 5: return [4 /*yield*/, itemToCheck_1.next()];\n                    case 6:\n                        if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3 /*break*/, 9];\n                        singleItem = itemToCheck_1_1.value;\n                        return [4 /*yield*/, this.matches(singleItem, true)];\n                    case 7:\n                        if (_c.sent()) {\n                            return [2 /*return*/, true];\n                        }\n                        _c.label = 8;\n                    case 8: return [3 /*break*/, 5];\n                    case 9: return [3 /*break*/, 16];\n                    case 10:\n                        e_7_1 = _c.sent();\n                        e_7 = { error: e_7_1 };\n                        return [3 /*break*/, 16];\n                    case 11:\n                        _c.trys.push([11, , 14, 15]);\n                        if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3 /*break*/, 13];\n                        return [4 /*yield*/, _a.call(itemToCheck_1)];\n                    case 12:\n                        _c.sent();\n                        _c.label = 13;\n                    case 13: return [3 /*break*/, 15];\n                    case 14:\n                        if (e_7) throw e_7.error;\n                        return [7 /*endfinally*/];\n                    case 15: return [7 /*endfinally*/];\n                    case 16: return [2 /*return*/, false];\n                    case 17:\n                        if (!(this.operator === 'or')) return [3 /*break*/, 18];\n                        return [2 /*return*/, asyncSome(this.operands, function (c) { return c.matches(itemToCheck); })];\n                    case 18:\n                        if (!(this.operator === 'and')) return [3 /*break*/, 19];\n                        return [2 /*return*/, asyncEvery(this.operands, function (c) { return c.matches(itemToCheck); })];\n                    case 19:\n                        if (!(this.operator === 'not')) return [3 /*break*/, 21];\n                        if (this.operands.length !== 1) {\n                            throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n                        }\n                        return [4 /*yield*/, this.operands[0].matches(itemToCheck)];\n                    case 20: return [2 /*return*/, !(_c.sent())];\n                    case 21: throw new Error('Invalid group operator!');\n                }\n            });\n        });\n    };\n    /**\n     * Tranfsorm to a AppSync GraphQL compatible AST.\n     * (Does not support filtering in nested types.)\n     */\n    GroupCondition.prototype.toAST = function () {\n        var _a;\n        if (this.field)\n            throw new Error('Nested type conditions are not supported!');\n        return _a = {},\n            _a[this.operator] = this.operands.map(function (operand) { return operand.toAST(); }),\n            _a;\n    };\n    /**\n     * Turn this predicate group into something a storage adapter\n     * understands how to use.\n     */\n    GroupCondition.prototype.toStoragePredicate = function () {\n        return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n    };\n    /**\n     * A JSON representation that's good for debugging.\n     */\n    GroupCondition.prototype.toJSON = function () {\n        return __assign(__assign({}, this), { model: this.model.schema.name });\n    };\n    return GroupCondition;\n}());\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n    if (allowRecursion === void 0) { allowRecursion = true; }\n    // to be used if we don't have a base query or tail to build onto\n    var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n    var baseCondition = query && tail ? query : starter;\n    var tailCondition = query && tail ? tail : starter;\n    // our eventual return object, which can be built upon.\n    // next steps will be to add or(), and(), not(), and field.op() methods.\n    var link = {};\n    // so it can be looked up later with in the internals when processing conditions.\n    registerPredicateInternals(baseCondition, link);\n    var copyLink = function () {\n        var _a = __read(baseCondition.copy(tailCondition), 2), query = _a[0], newTail = _a[1];\n        var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n        return { query: query, newTail: newTail, newLink: newLink };\n    };\n    // Adds .or() and .and() methods to the link.\n    // TODO: If revisiting this code, consider writing a Proxy instead.\n    ['and', 'or'].forEach(function (op) {\n        link[op] = function (builder) {\n            // or() and and() will return a copy of the original link\n            // to head off mutability concerns.\n            var _a = copyLink(), query = _a.query, newTail = _a.newTail;\n            var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n            if (!Array.isArray(childConditions)) {\n                throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n            }\n            // the customer will supply a child predicate, which apply to the `model.field`\n            // of the tail GroupCondition.\n            newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) { return internals(c); })));\n            // FinalPredicate\n            return registerPredicateInternals(query);\n        };\n    });\n    // TODO: If revisiting this code, consider proxy.\n    link.not = function (builder) {\n        // not() will return a copy of the original link\n        // to head off mutability concerns.\n        var _a = copyLink(), query = _a.query, newTail = _a.newTail;\n        // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n        // the difference being: not() does not accept an array of predicate-like objects.\n        // it negates only a *single* predicate subtree.\n        newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [\n            internals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n        ]));\n        // A `FinalModelPredicate`.\n        // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n        // or query storage: `.__query.fetch(storage)`.\n        return registerPredicateInternals(query);\n    };\n    var _loop_1 = function (fieldName) {\n        Object.defineProperty(link, fieldName, {\n            enumerable: true,\n            get: function () {\n                var def = ModelType.schema.allFields[fieldName];\n                if (!def.association) {\n                    // we're looking at a value field. we need to return a\n                    // \"field matcher object\", which contains all of the comparison\n                    // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n                    // against the target field (fieldName).\n                    return ops.reduce(function (fieldMatcher, operator) {\n                        var _a;\n                        return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n                            var operands = [];\n                            for (var _i = 0; _i < arguments.length; _i++) {\n                                operands[_i] = arguments[_i];\n                            }\n                            // build off a fresh copy of the existing `link`, just in case\n                            // the same link is being used elsewhere by the customer.\n                            var _a = copyLink(), query = _a.query, newTail = _a.newTail;\n                            // normalize operands. if any of the values are `undefiend`, use\n                            // `null` instead, because that's what will be stored cross-platform.\n                            var normalizedOperands = operands.map(function (o) {\n                                return o === undefined ? null : o;\n                            });\n                            // add the given condition to the link's TAIL node.\n                            // remember: the base link might go N nodes deep! e.g.,\n                            newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, normalizedOperands));\n                            // A `FinalModelPredicate`.\n                            // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n                            // or query storage: `.__query.fetch(storage)`.\n                            return registerPredicateInternals(query);\n                        }, _a));\n                    }, {});\n                }\n                else {\n                    if (!allowRecursion) {\n                        throw new Error('Predication on releated models is not supported in this context.');\n                    }\n                    else if (def.association.connectionType === 'BELONGS_TO' ||\n                        def.association.connectionType === 'HAS_ONE' ||\n                        def.association.connectionType === 'HAS_MANY') {\n                        // the use has just typed '.someRelatedModel'. we need to given them\n                        // back a predicate chain.\n                        var relatedMeta = def.type.modelConstructor;\n                        if (!relatedMeta) {\n                            throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n                        }\n                        // `Model.reletedModelField` returns a copy of the original link,\n                        // and will contains copies of internal GroupConditions\n                        // to head off mutability concerns.\n                        var _a = __read(baseCondition.copy(tailCondition), 2), newquery = _a[0], oldtail = _a[1];\n                        var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n                        // `oldtail` here refers to the *copy* of the old tail.\n                        // so, it's safe to modify at this point. and we need to modify\n                        // it to push the *new* tail onto the end of it.\n                        oldtail.operands.push(newtail);\n                        var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n                        return newlink;\n                    }\n                    else {\n                        throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n                    }\n                }\n            },\n        });\n    };\n    // For each field on the model schema, we want to add a getter\n    // that creates the appropriate new `link` in the query chain.\n    // TODO: If revisiting, consider a proxy.\n    for (var fieldName in ModelType.schema.allFields) {\n        _loop_1(fieldName);\n    }\n    return link;\n}\nexport function predicateFor(ModelType) {\n    // the cast here is just a cheap way to reduce the surface area from\n    // the recursive type.\n    return recursivePredicateFor(ModelType, false);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}