{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread, __values } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { GRAPHQL_AUTH_MODE } from '@aws-amplify/api-graphql';\nimport { GraphQLAuthError } from '@aws-amplify/api';\nimport { Logger } from '@aws-amplify/core';\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isSchemaModelWithAttributes, isTargetNameAssociation, isNonModelFieldType, OpType, ModelOperation, isPredicateGroup } from '../types';\nimport { extractPrimaryKeyFieldNames, establishRelationAndKeys, IDENTIFIER_KEY_SEPARATOR } from '../util';\nvar logger = new Logger('DataStore');\nvar GraphQLOperationType;\n\n(function (GraphQLOperationType) {\n  GraphQLOperationType[\"LIST\"] = \"query\";\n  GraphQLOperationType[\"CREATE\"] = \"mutation\";\n  GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n  GraphQLOperationType[\"DELETE\"] = \"mutation\";\n  GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\n\nexport var TransformerMutationType;\n\n(function (TransformerMutationType) {\n  TransformerMutationType[\"CREATE\"] = \"Create\";\n  TransformerMutationType[\"UPDATE\"] = \"Update\";\n  TransformerMutationType[\"DELETE\"] = \"Delete\";\n  TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\n\nvar dummyMetadata = {\n  _version: undefined,\n  _lastChangedAt: undefined,\n  _deleted: undefined\n};\nvar metadataFields = Object.keys(dummyMetadata);\nexport function getMetadataFields() {\n  return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n  var scalarFields = getScalarFields(modelDefinition);\n  var nonModelFields = getNonModelFields(namespace, modelDefinition);\n  var implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n  var scalarAndMetadataFields = Object.values(scalarFields).map(function (_a) {\n    var name = _a.name;\n    return name;\n  }).concat(implicitOwnerField).concat(nonModelFields);\n\n  if (isSchemaModel(modelDefinition)) {\n    scalarAndMetadataFields = scalarAndMetadataFields.concat(getMetadataFields()).concat(getConnectionFields(modelDefinition, namespace));\n  }\n\n  var result = scalarAndMetadataFields.join('\\n');\n  return result;\n}\n\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n  var ownerFields = getOwnerFields(modelDefinition);\n\n  if (!scalarFields.owner && ownerFields.includes('owner')) {\n    return ['owner'];\n  }\n\n  return [];\n}\n\nfunction getOwnerFields(modelDefinition) {\n  var ownerFields = [];\n\n  if (isSchemaModelWithAttributes(modelDefinition)) {\n    modelDefinition.attributes.forEach(function (attr) {\n      if (attr.properties && attr.properties.rules) {\n        var rule = attr.properties.rules.find(function (rule) {\n          return rule.allow === 'owner';\n        });\n\n        if (rule && rule.ownerField) {\n          ownerFields.push(rule.ownerField);\n        }\n      }\n    });\n  }\n\n  return ownerFields;\n}\n\nfunction getScalarFields(modelDefinition) {\n  var fields = modelDefinition.fields;\n  var result = Object.values(fields).filter(function (field) {\n    if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n      return true;\n    }\n\n    return false;\n  }).reduce(function (acc, field) {\n    acc[field.name] = field;\n    return acc;\n  }, {});\n  return result;\n} // Used for generating the selection set for queries and mutations\n\n\nfunction getConnectionFields(modelDefinition, namespace) {\n  var result = [];\n  Object.values(modelDefinition.fields).filter(function (_a) {\n    var association = _a.association;\n    return association && Object.keys(association).length;\n  }).forEach(function (_a) {\n    var name = _a.name,\n        association = _a.association;\n    var connectionType = (association || {}).connectionType;\n\n    switch (connectionType) {\n      case 'HAS_ONE':\n      case 'HAS_MANY':\n        // Intentionally blank\n        break;\n\n      case 'BELONGS_TO':\n        if (isTargetNameAssociation(association)) {\n          // New codegen (CPK)\n          if (association.targetNames && association.targetNames.length > 0) {\n            // Need to retrieve relations in order to get connected model keys\n            var _b = __read(establishRelationAndKeys(namespace), 1),\n                relations = _b[0];\n\n            var connectedModelName = modelDefinition.fields[name].type['model'];\n            var byPkIndex = relations[connectedModelName].indexes.find(function (_a) {\n              var _b = __read(_a, 1),\n                  name = _b[0];\n\n              return name === 'byPk';\n            });\n            var keyFields = byPkIndex && byPkIndex[1];\n            var keyFieldSelectionSet = keyFields === null || keyFields === void 0 ? void 0 : keyFields.join(' '); // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n\n            result.push(name + \" { \" + keyFieldSelectionSet + \" _deleted }\");\n          } else {\n            // backwards-compatability for schema generated prior to custom primary key support\n            result.push(name + \" { id _deleted }\");\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Invalid connection type \" + connectionType);\n    }\n  });\n  return result;\n}\n\nfunction getNonModelFields(namespace, modelDefinition) {\n  var result = [];\n  Object.values(modelDefinition.fields).forEach(function (_a) {\n    var name = _a.name,\n        type = _a.type;\n\n    if (isNonModelFieldType(type)) {\n      var typeDefinition = namespace.nonModels[type.nonModel];\n      var scalarFields = Object.values(getScalarFields(typeDefinition)).map(function (_a) {\n        var name = _a.name;\n        return name;\n      });\n      var nested_1 = [];\n      Object.values(typeDefinition.fields).forEach(function (field) {\n        var type = field.type,\n            name = field.name;\n\n        if (isNonModelFieldType(type)) {\n          var typeDefinition_1 = namespace.nonModels[type.nonModel];\n          nested_1.push(name + \" { \" + generateSelectionSet(namespace, typeDefinition_1) + \" }\");\n        }\n      });\n      result.push(name + \" { \" + scalarFields.join(' ') + \" \" + nested_1.join(' ') + \" }\");\n    }\n  });\n  return result;\n}\n\nexport function getAuthorizationRules(modelDefinition) {\n  // Searching for owner authorization on attributes\n  var authConfig = [].concat(modelDefinition.attributes || []).find(function (attr) {\n    return attr && attr.type === 'auth';\n  });\n  var _a = (authConfig || {}).properties,\n      _b = (_a === void 0 ? {} : _a).rules,\n      rules = _b === void 0 ? [] : _b;\n  var resultRules = []; // Multiple rules can be declared for allow: owner\n\n  rules.forEach(function (rule) {\n    // setting defaults for backwards compatibility with old cli\n    var _a = rule.identityClaim,\n        identityClaim = _a === void 0 ? 'cognito:username' : _a,\n        _b = rule.ownerField,\n        ownerField = _b === void 0 ? 'owner' : _b,\n        _c = rule.operations,\n        operations = _c === void 0 ? ['create', 'update', 'delete', 'read'] : _c,\n        _d = rule.provider,\n        provider = _d === void 0 ? 'userPools' : _d,\n        _e = rule.groupClaim,\n        groupClaim = _e === void 0 ? 'cognito:groups' : _e,\n        _f = rule.allow,\n        authStrategy = _f === void 0 ? 'iam' : _f,\n        _g = rule.groups,\n        groups = _g === void 0 ? [] : _g,\n        _h = rule.groupsField,\n        groupsField = _h === void 0 ? '' : _h;\n    var isReadAuthorized = operations.includes('read');\n    var isOwnerAuth = authStrategy === 'owner';\n\n    if (!isReadAuthorized && !isOwnerAuth) {\n      return;\n    }\n\n    var authRule = {\n      identityClaim: identityClaim,\n      ownerField: ownerField,\n      provider: provider,\n      groupClaim: groupClaim,\n      authStrategy: authStrategy,\n      groups: groups,\n      groupsField: groupsField,\n      areSubscriptionsPublic: false\n    };\n\n    if (isOwnerAuth) {\n      // look for the subscription level override\n      // only pay attention to the public level\n      var modelConfig = [].concat(modelDefinition.attributes || []).find(function (attr) {\n        return attr && attr.type === 'model';\n      }); // find the subscriptions level. ON is default\n\n      var _j = (modelConfig || {}).properties,\n          _k = (_j === void 0 ? {} : _j).subscriptions,\n          _l = (_k === void 0 ? {} : _k).level,\n          level = _l === void 0 ? 'on' : _l; // treat subscriptions as public for owner auth with unprotected reads\n      // when `read` is omitted from `operations`\n\n      authRule.areSubscriptionsPublic = !operations.includes('read') || level === 'public';\n    }\n\n    if (isOwnerAuth) {\n      // owner rules has least priority\n      resultRules.push(authRule);\n      return;\n    }\n\n    resultRules.unshift(authRule);\n  });\n  return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg) {\n  if (filterArg === void 0) {\n    filterArg = false;\n  }\n\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name;\n  var opName = \"on\" + transformerMutationType + typeName;\n  var docArgs = [];\n  var opArgs = [];\n\n  if (filterArg) {\n    docArgs.push(\"$filter: ModelSubscription\" + typeName + \"FilterInput\");\n    opArgs.push('filter: $filter');\n  }\n\n  if (isOwnerAuthorization) {\n    docArgs.push(\"$\" + ownerField + \": String!\");\n    opArgs.push(ownerField + \": $\" + ownerField);\n  }\n\n  var docStr = docArgs.length ? \"(\" + docArgs.join(',') + \")\" : '';\n  var opStr = opArgs.length ? \"(\" + opArgs.join(',') + \")\" : '';\n  return [transformerMutationType, opName, \"subscription operation\" + docStr + \"{\\n\\t\\t\\t\" + opName + opStr + \"{\\n\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t}\\n\\t\\t}\"];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n  var selectionSet = generateSelectionSet(namespace, modelDefinition);\n  var typeName = modelDefinition.name,\n      pluralTypeName = modelDefinition.pluralName;\n  var operation;\n  var documentArgs;\n  var operationArgs;\n  var transformerMutationType;\n\n  switch (graphQLOpType) {\n    case 'LIST':\n      operation = \"sync\" + pluralTypeName;\n      documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\" + typeName + \"FilterInput)\";\n      operationArgs = '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n      selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\";\n      break;\n\n    case 'CREATE':\n      operation = \"create\" + typeName;\n      documentArgs = \"($input: Create\" + typeName + \"Input!)\";\n      operationArgs = '(input: $input)';\n      transformerMutationType = TransformerMutationType.CREATE;\n      break;\n\n    case 'UPDATE':\n      operation = \"update\" + typeName;\n      documentArgs = \"($input: Update\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.UPDATE;\n      break;\n\n    case 'DELETE':\n      operation = \"delete\" + typeName;\n      documentArgs = \"($input: Delete\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n      operationArgs = '(input: $input, condition: $condition)';\n      transformerMutationType = TransformerMutationType.DELETE;\n      break;\n\n    case 'GET':\n      operation = \"get\" + typeName;\n      documentArgs = \"($id: ID!)\";\n      operationArgs = '(id: $id)';\n      transformerMutationType = TransformerMutationType.GET;\n      break;\n\n    default:\n      throw new Error(\"Invalid graphQlOpType \" + graphQLOpType);\n  }\n\n  return [[transformerMutationType, operation, GraphQLOperationType[graphQLOpType] + \" operation\" + documentArgs + \"{\\n\\t\\t\" + operation + operationArgs + \"{\\n\\t\\t\\t\" + selectionSet + \"\\n\\t\\t}\\n\\t}\"]];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n  var operation;\n\n  switch (opType) {\n    case OpType.INSERT:\n      operation = TransformerMutationType.CREATE;\n      break;\n\n    case OpType.UPDATE:\n      operation = TransformerMutationType.UPDATE;\n      break;\n\n    case OpType.DELETE:\n      operation = TransformerMutationType.DELETE;\n      break;\n\n    default:\n      throw new Error(\"Invalid opType \" + opType);\n  } // stringify nested objects of type AWSJSON\n  // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n  // but still send the object correctly over the wire\n\n\n  var replacer = function (k, v) {\n    var isAWSJSON = k && v !== null && typeof v === 'object' && modelDefinition.fields[k] && modelDefinition.fields[k].type === 'AWSJSON';\n\n    if (isAWSJSON) {\n      return JSON.stringify(v);\n    }\n\n    return v;\n  };\n\n  var modelId = getIdentifierValue(modelDefinition, element);\n  var optionalId = OpType.INSERT && id ? {\n    id: id\n  } : {};\n  var mutationEvent = modelInstanceCreator(MutationEventConstructor, __assign(__assign({}, optionalId), {\n    data: JSON.stringify(element, replacer),\n    modelId: modelId,\n    model: model.name,\n    operation: operation,\n    condition: JSON.stringify(condition)\n  }));\n  return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate, modelDefinition) {\n  var result = {};\n\n  if (!predicate || !Array.isArray(predicate.predicates)) {\n    return result;\n  } // This is compatible with how the GQL Transform currently generates the Condition Input,\n  // i.e. any PK and SK fields are omitted and can't be used as conditions.\n  // However, I think this limits usability.\n  // What if we want to delete all records where SK > some value\n  // Or all records where PK = some value but SKs are different values\n  // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n  // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n\n\n  var keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n  return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\n\nexport function predicateToGraphQLFilter(predicatesGroup, fieldsToOmit, root) {\n  if (fieldsToOmit === void 0) {\n    fieldsToOmit = [];\n  }\n\n  if (root === void 0) {\n    root = true;\n  }\n\n  var result = {};\n\n  if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n    return result;\n  }\n\n  var type = predicatesGroup.type,\n      predicates = predicatesGroup.predicates;\n  var isList = type === 'and' || type === 'or';\n  result[type] = isList ? [] : {};\n  var children = [];\n  predicates.forEach(function (predicate) {\n    var _a, _b;\n\n    if (isPredicateObj(predicate)) {\n      var field = predicate.field,\n          operator = predicate.operator,\n          operand = predicate.operand;\n      if (fieldsToOmit.includes(field)) return;\n      var gqlField = (_a = {}, _a[field] = (_b = {}, _b[operator] = operand, _b), _a);\n      children.push(gqlField);\n      return;\n    }\n\n    var child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n\n    if (Object.keys(child).length > 0) {\n      children.push(child);\n    }\n  }); // flatten redundant list predicates\n\n  if (children.length === 1) {\n    var _a = __read(children, 1),\n        child = _a[0];\n\n    if ( // any nested list node\n    isList && !root || // root list node where the only child is also a list node\n    isList && root && ('and' in child || 'or' in child)) {\n      delete result[type];\n      Object.assign(result, child);\n      return result;\n    }\n  }\n\n  children.forEach(function (child) {\n    if (isList) {\n      result[type].push(child);\n    } else {\n      result[type] = child;\n    }\n  });\n\n  if (isList) {\n    if (result[type].length === 0) return {};\n  } else {\n    if (Object.keys(result[type]).length === 0) return {};\n  }\n\n  return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\n\nexport function filterFields(group) {\n  var fields = new Set();\n  if (!group || !Array.isArray(group.predicates)) return fields;\n  var predicates = group.predicates;\n\n  var stack = __spread(predicates);\n\n  while (stack.length > 0) {\n    var current = stack.pop();\n\n    if (isPredicateObj(current)) {\n      fields.add(current.field);\n    } else if (isPredicateGroup(current)) {\n      stack.push.apply(stack, __spread(current.predicates));\n    }\n  }\n\n  return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\n\nexport function dynamicAuthFields(modelDefinition) {\n  var e_1, _a;\n\n  var rules = getAuthorizationRules(modelDefinition);\n  var fields = new Set();\n\n  try {\n    for (var rules_1 = __values(rules), rules_1_1 = rules_1.next(); !rules_1_1.done; rules_1_1 = rules_1.next()) {\n      var rule = rules_1_1.value;\n\n      if (rule.groupsField && !rule.groups.length) {\n        // dynamic group rule will have no values in `rule.groups`\n        fields.add(rule.groupsField);\n      } else if (rule.ownerField) {\n        fields.add(rule.ownerField);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (rules_1_1 && !rules_1_1.done && (_a = rules_1.return)) _a.call(rules_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\n\nexport function countFilterCombinations(group) {\n  if (!group || !Array.isArray(group.predicates)) return 0;\n  var count = 0;\n  var stack = [group];\n\n  while (stack.length > 0) {\n    var current = stack.pop();\n\n    if (isPredicateGroup(current)) {\n      var predicates = current.predicates,\n          type = current.type; // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n\n      if (type === 'or' && predicates.length > 1) {\n        count += predicates.length;\n      }\n\n      stack.push.apply(stack, __spread(predicates));\n    }\n  } // if we didn't encounter any OR groups, default to 1\n\n\n  return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\n\nexport function repeatedFieldInGroup(group) {\n  if (!group || !Array.isArray(group.predicates)) return null; // convert to filter in order to flatten redundant groups\n\n  var gqlFilter = predicateToGraphQLFilter(group);\n  var stack = [gqlFilter];\n\n  var hasGroupRepeatedFields = function (fields) {\n    var e_2, _a;\n\n    var seen = {};\n\n    try {\n      for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n        var f = fields_1_1.value;\n\n        var _b = __read(Object.keys(f), 1),\n            fieldName = _b[0];\n\n        if (seen[fieldName]) {\n          return fieldName;\n        }\n\n        seen[fieldName] = true;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return null;\n  };\n\n  while (stack.length > 0) {\n    var current = stack.pop();\n\n    var _a = __read(Object.keys(current), 1),\n        key = _a[0];\n\n    var values = current[key];\n\n    if (!Array.isArray(values)) {\n      return null;\n    } // field value will be single object\n\n\n    var predicateObjects = values.filter(function (v) {\n      return !Array.isArray(Object.values(v)[0]);\n    }); // group value will be an array\n\n    var predicateGroups = values.filter(function (v) {\n      return Array.isArray(Object.values(v)[0]);\n    });\n\n    if (key === 'and') {\n      var repeatedField = hasGroupRepeatedFields(predicateObjects);\n\n      if (repeatedField) {\n        return repeatedField;\n      }\n    }\n\n    stack.push.apply(stack, __spread(predicateGroups));\n  }\n\n  return null;\n}\nexport var RTFError;\n\n(function (RTFError) {\n  RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n  RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n  RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n  RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n  RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n  RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\n\nexport function generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n  var selSyncFields = filterFields(predicatesGroup);\n\n  var selSyncFieldStr = __spread(selSyncFields).join(', ');\n\n  var dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n\n  var dynamicAuthFieldsStr = __spread(dynamicAuthModeFields).join(', ');\n\n  var filterCombinations = countFilterCombinations(predicatesGroup);\n  var repeatedField = repeatedFieldInGroup(predicatesGroup);\n\n  switch (errorType) {\n    case RTFError.UnknownField:\n      return \"Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.\" + 'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`';\n\n    case RTFError.MaxAttributes:\n      {\n        var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + selSyncFields.size + \" different model fields: \" + selSyncFieldStr + \".\\n\\n\";\n\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n\" + (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n        }\n\n        return message;\n      }\n\n    case RTFError.MaxCombinations:\n      {\n        var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + filterCombinations + \" field combinations (total number of predicates in an OR expression).\\n\\n\";\n\n        if (dynamicAuthModeFields.size > 0) {\n          message += \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" + \"Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n\" + (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n        }\n\n        return message;\n      }\n\n    case RTFError.RepeatedFieldname:\n      return \"Your selective sync expression for \" + modelDefinition.name + \" contains multiple entries for \" + repeatedField + \" in the same AND group.\";\n\n    case RTFError.NotGroup:\n      return \"Your selective sync expression for \" + modelDefinition.name + \" uses a `not` group. If you'd like to filter subscriptions in the backend, \" + \"rewrite your expression using `ne` or `notContains` operators.\";\n\n    case RTFError.FieldNotInType:\n      // no remediation instructions. We'll surface the message directly\n      return '';\n  }\n}\nexport function getUserGroupsFromToken(token, rule) {\n  // validate token against groupClaim\n  var userGroups = token[rule.groupClaim] || [];\n\n  if (typeof userGroups === 'string') {\n    var parsedGroups = void 0;\n\n    try {\n      parsedGroups = JSON.parse(userGroups);\n    } catch (e) {\n      parsedGroups = userGroups;\n    }\n\n    userGroups = [].concat(parsedGroups);\n  }\n\n  return userGroups;\n}\nexport function getModelAuthModes(_a) {\n  var authModeStrategy = _a.authModeStrategy,\n      defaultAuthMode = _a.defaultAuthMode,\n      modelName = _a.modelName,\n      schema = _a.schema;\n  return __awaiter(this, void 0, void 0, function () {\n    var operations, modelAuthModes, error_1;\n\n    var _this = this;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          operations = Object.values(ModelOperation);\n          modelAuthModes = {\n            CREATE: [],\n            READ: [],\n            UPDATE: [],\n            DELETE: []\n          };\n          _b.label = 1;\n\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , Promise.all(operations.map(function (operation) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var authModes;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , authModeStrategy({\n                      schema: schema,\n                      modelName: modelName,\n                      operation: operation\n                    })];\n\n                  case 1:\n                    authModes = _a.sent();\n\n                    if (typeof authModes === 'string') {\n                      modelAuthModes[operation] = [authModes];\n                    } else if (Array.isArray(authModes) && authModes.length) {\n                      modelAuthModes[operation] = authModes;\n                    } else {\n                      // Use default auth mode if nothing is returned from authModeStrategy\n                      modelAuthModes[operation] = [defaultAuthMode];\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }))];\n\n        case 2:\n          _b.sent();\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          error_1 = _b.sent();\n          logger.debug(\"Error getting auth modes for model: \" + modelName, error_1);\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [2\n          /*return*/\n          , modelAuthModes];\n      }\n    });\n  });\n}\nexport function getForbiddenError(error) {\n  var forbiddenErrorMessages = ['Request failed with status code 401', 'Request failed with status code 403'];\n  var forbiddenError;\n\n  if (error && error.errors) {\n    forbiddenError = error.errors.find(function (err) {\n      return forbiddenErrorMessages.includes(err.message);\n    });\n  } else if (error && error.message) {\n    forbiddenError = error;\n  }\n\n  if (forbiddenError) {\n    return forbiddenError.message;\n  }\n\n  return null;\n}\nexport function getClientSideAuthError(error) {\n  var clientSideAuthErrors = Object.values(GraphQLAuthError);\n  var clientSideError = error && error.message && clientSideAuthErrors.find(function (clientError) {\n    return error.message.includes(clientError);\n  });\n  return clientSideError || null;\n}\nexport function getTokenForCustomAuth(authMode, amplifyConfig) {\n  if (amplifyConfig === void 0) {\n    amplifyConfig = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, functionAuthProvider, token, error_2;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          if (!(authMode === GRAPHQL_AUTH_MODE.AWS_LAMBDA)) return [3\n          /*break*/\n          , 6];\n          _a = amplifyConfig.authProviders, functionAuthProvider = (_a === void 0 ? {\n            functionAuthProvider: null\n          } : _a).functionAuthProvider;\n          if (!(functionAuthProvider && typeof functionAuthProvider === 'function')) return [3\n          /*break*/\n          , 5];\n          _b.label = 1;\n\n        case 1:\n          _b.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , functionAuthProvider()];\n\n        case 2:\n          token = _b.sent().token;\n          return [2\n          /*return*/\n          , token];\n\n        case 3:\n          error_2 = _b.sent();\n          throw new Error(\"Error retrieving token from `functionAuthProvider`: \" + error_2);\n\n        case 4:\n          return [3\n          /*break*/\n          , 6];\n\n        case 5:\n          // TODO: add docs link once available\n          throw new Error(\"You must provide a `functionAuthProvider` function to `DataStore.configure` when using \" + GRAPHQL_AUTH_MODE.AWS_LAMBDA);\n\n        case 6:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n} // Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\n\nexport function getIdentifierValue(modelDefinition, model) {\n  var pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n  var idOrPk = pkFieldNames.map(function (f) {\n    return model[f];\n  }).join(IDENTIFIER_KEY_SEPARATOR);\n  return idOrPk;\n}","map":{"version":3,"names":["__assign","__awaiter","__generator","__read","__spread","__values","GRAPHQL_AUTH_MODE","GraphQLAuthError","Logger","isEnumFieldType","isGraphQLScalarType","isPredicateObj","isSchemaModel","isSchemaModelWithAttributes","isTargetNameAssociation","isNonModelFieldType","OpType","ModelOperation","isPredicateGroup","extractPrimaryKeyFieldNames","establishRelationAndKeys","IDENTIFIER_KEY_SEPARATOR","logger","GraphQLOperationType","TransformerMutationType","dummyMetadata","_version","undefined","_lastChangedAt","_deleted","metadataFields","Object","keys","getMetadataFields","generateSelectionSet","namespace","modelDefinition","scalarFields","getScalarFields","nonModelFields","getNonModelFields","implicitOwnerField","getImplicitOwnerField","scalarAndMetadataFields","values","map","_a","name","concat","getConnectionFields","result","join","ownerFields","getOwnerFields","owner","includes","attributes","forEach","attr","properties","rules","rule","find","allow","ownerField","push","fields","filter","field","type","reduce","acc","association","length","connectionType","targetNames","_b","relations","connectedModelName","byPkIndex","indexes","keyFields","keyFieldSelectionSet","Error","typeDefinition","nonModels","nonModel","nested_1","typeDefinition_1","getAuthorizationRules","authConfig","resultRules","identityClaim","_c","operations","_d","provider","_e","groupClaim","_f","authStrategy","_g","groups","_h","groupsField","isReadAuthorized","isOwnerAuth","authRule","areSubscriptionsPublic","modelConfig","_j","_k","subscriptions","_l","level","unshift","buildSubscriptionGraphQLOperation","transformerMutationType","isOwnerAuthorization","filterArg","selectionSet","typeName","opName","docArgs","opArgs","docStr","opStr","buildGraphQLOperation","graphQLOpType","pluralTypeName","pluralName","operation","documentArgs","operationArgs","CREATE","UPDATE","DELETE","GET","createMutationInstanceFromModelOperation","relationships","opType","model","element","condition","MutationEventConstructor","modelInstanceCreator","id","INSERT","replacer","k","v","isAWSJSON","JSON","stringify","modelId","getIdentifierValue","optionalId","mutationEvent","data","predicateToGraphQLCondition","predicate","Array","isArray","predicates","predicateToGraphQLFilter","predicatesGroup","fieldsToOmit","root","isList","children","operator","operand","gqlField","child","assign","filterFields","group","Set","stack","current","pop","add","apply","dynamicAuthFields","e_1","rules_1","rules_1_1","next","done","value","e_1_1","error","return","call","countFilterCombinations","count","repeatedFieldInGroup","gqlFilter","hasGroupRepeatedFields","e_2","seen","fields_1","fields_1_1","f","fieldName","e_2_1","key","predicateObjects","predicateGroups","repeatedField","RTFError","generateRTFRemediation","errorType","selSyncFields","selSyncFieldStr","dynamicAuthModeFields","dynamicAuthFieldsStr","filterCombinations","UnknownField","MaxAttributes","message","size","MaxCombinations","RepeatedFieldname","NotGroup","FieldNotInType","getUserGroupsFromToken","token","userGroups","parsedGroups","parse","e","getModelAuthModes","authModeStrategy","defaultAuthMode","modelName","schema","modelAuthModes","error_1","_this","label","READ","trys","Promise","all","authModes","sent","debug","getForbiddenError","forbiddenErrorMessages","forbiddenError","errors","err","getClientSideAuthError","clientSideAuthErrors","clientSideError","clientError","getTokenForCustomAuth","authMode","amplifyConfig","functionAuthProvider","error_2","AWS_LAMBDA","authProviders","pkFieldNames","idOrPk"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/datastore/lib-esm/sync/utils.js"],"sourcesContent":["import { __assign, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { GRAPHQL_AUTH_MODE } from '@aws-amplify/api-graphql';\nimport { GraphQLAuthError } from '@aws-amplify/api';\nimport { Logger } from '@aws-amplify/core';\nimport { isEnumFieldType, isGraphQLScalarType, isPredicateObj, isSchemaModel, isSchemaModelWithAttributes, isTargetNameAssociation, isNonModelFieldType, OpType, ModelOperation, isPredicateGroup, } from '../types';\nimport { extractPrimaryKeyFieldNames, establishRelationAndKeys, IDENTIFIER_KEY_SEPARATOR, } from '../util';\nvar logger = new Logger('DataStore');\nvar GraphQLOperationType;\n(function (GraphQLOperationType) {\n    GraphQLOperationType[\"LIST\"] = \"query\";\n    GraphQLOperationType[\"CREATE\"] = \"mutation\";\n    GraphQLOperationType[\"UPDATE\"] = \"mutation\";\n    GraphQLOperationType[\"DELETE\"] = \"mutation\";\n    GraphQLOperationType[\"GET\"] = \"query\";\n})(GraphQLOperationType || (GraphQLOperationType = {}));\nexport var TransformerMutationType;\n(function (TransformerMutationType) {\n    TransformerMutationType[\"CREATE\"] = \"Create\";\n    TransformerMutationType[\"UPDATE\"] = \"Update\";\n    TransformerMutationType[\"DELETE\"] = \"Delete\";\n    TransformerMutationType[\"GET\"] = \"Get\";\n})(TransformerMutationType || (TransformerMutationType = {}));\nvar dummyMetadata = {\n    _version: undefined,\n    _lastChangedAt: undefined,\n    _deleted: undefined,\n};\nvar metadataFields = (Object.keys(dummyMetadata));\nexport function getMetadataFields() {\n    return metadataFields;\n}\nexport function generateSelectionSet(namespace, modelDefinition) {\n    var scalarFields = getScalarFields(modelDefinition);\n    var nonModelFields = getNonModelFields(namespace, modelDefinition);\n    var implicitOwnerField = getImplicitOwnerField(modelDefinition, scalarFields);\n    var scalarAndMetadataFields = Object.values(scalarFields)\n        .map(function (_a) {\n        var name = _a.name;\n        return name;\n    })\n        .concat(implicitOwnerField)\n        .concat(nonModelFields);\n    if (isSchemaModel(modelDefinition)) {\n        scalarAndMetadataFields = scalarAndMetadataFields\n            .concat(getMetadataFields())\n            .concat(getConnectionFields(modelDefinition, namespace));\n    }\n    var result = scalarAndMetadataFields.join('\\n');\n    return result;\n}\nfunction getImplicitOwnerField(modelDefinition, scalarFields) {\n    var ownerFields = getOwnerFields(modelDefinition);\n    if (!scalarFields.owner && ownerFields.includes('owner')) {\n        return ['owner'];\n    }\n    return [];\n}\nfunction getOwnerFields(modelDefinition) {\n    var ownerFields = [];\n    if (isSchemaModelWithAttributes(modelDefinition)) {\n        modelDefinition.attributes.forEach(function (attr) {\n            if (attr.properties && attr.properties.rules) {\n                var rule = attr.properties.rules.find(function (rule) { return rule.allow === 'owner'; });\n                if (rule && rule.ownerField) {\n                    ownerFields.push(rule.ownerField);\n                }\n            }\n        });\n    }\n    return ownerFields;\n}\nfunction getScalarFields(modelDefinition) {\n    var fields = modelDefinition.fields;\n    var result = Object.values(fields)\n        .filter(function (field) {\n        if (isGraphQLScalarType(field.type) || isEnumFieldType(field.type)) {\n            return true;\n        }\n        return false;\n    })\n        .reduce(function (acc, field) {\n        acc[field.name] = field;\n        return acc;\n    }, {});\n    return result;\n}\n// Used for generating the selection set for queries and mutations\nfunction getConnectionFields(modelDefinition, namespace) {\n    var result = [];\n    Object.values(modelDefinition.fields)\n        .filter(function (_a) {\n        var association = _a.association;\n        return association && Object.keys(association).length;\n    })\n        .forEach(function (_a) {\n        var name = _a.name, association = _a.association;\n        var connectionType = (association || {}).connectionType;\n        switch (connectionType) {\n            case 'HAS_ONE':\n            case 'HAS_MANY':\n                // Intentionally blank\n                break;\n            case 'BELONGS_TO':\n                if (isTargetNameAssociation(association)) {\n                    // New codegen (CPK)\n                    if (association.targetNames && association.targetNames.length > 0) {\n                        // Need to retrieve relations in order to get connected model keys\n                        var _b = __read(establishRelationAndKeys(namespace), 1), relations = _b[0];\n                        var connectedModelName = modelDefinition.fields[name].type['model'];\n                        var byPkIndex = relations[connectedModelName].indexes.find(function (_a) {\n                            var _b = __read(_a, 1), name = _b[0];\n                            return name === 'byPk';\n                        });\n                        var keyFields = byPkIndex && byPkIndex[1];\n                        var keyFieldSelectionSet = keyFields === null || keyFields === void 0 ? void 0 : keyFields.join(' ');\n                        // We rely on `_deleted` when we process the sync query (e.g. in batchSave in the adapters)\n                        result.push(name + \" { \" + keyFieldSelectionSet + \" _deleted }\");\n                    }\n                    else {\n                        // backwards-compatability for schema generated prior to custom primary key support\n                        result.push(name + \" { id _deleted }\");\n                    }\n                }\n                break;\n            default:\n                throw new Error(\"Invalid connection type \" + connectionType);\n        }\n    });\n    return result;\n}\nfunction getNonModelFields(namespace, modelDefinition) {\n    var result = [];\n    Object.values(modelDefinition.fields).forEach(function (_a) {\n        var name = _a.name, type = _a.type;\n        if (isNonModelFieldType(type)) {\n            var typeDefinition = namespace.nonModels[type.nonModel];\n            var scalarFields = Object.values(getScalarFields(typeDefinition)).map(function (_a) {\n                var name = _a.name;\n                return name;\n            });\n            var nested_1 = [];\n            Object.values(typeDefinition.fields).forEach(function (field) {\n                var type = field.type, name = field.name;\n                if (isNonModelFieldType(type)) {\n                    var typeDefinition_1 = namespace.nonModels[type.nonModel];\n                    nested_1.push(name + \" { \" + generateSelectionSet(namespace, typeDefinition_1) + \" }\");\n                }\n            });\n            result.push(name + \" { \" + scalarFields.join(' ') + \" \" + nested_1.join(' ') + \" }\");\n        }\n    });\n    return result;\n}\nexport function getAuthorizationRules(modelDefinition) {\n    // Searching for owner authorization on attributes\n    var authConfig = []\n        .concat(modelDefinition.attributes || [])\n        .find(function (attr) { return attr && attr.type === 'auth'; });\n    var _a = (authConfig || {}).properties, _b = (_a === void 0 ? {} : _a).rules, rules = _b === void 0 ? [] : _b;\n    var resultRules = [];\n    // Multiple rules can be declared for allow: owner\n    rules.forEach(function (rule) {\n        // setting defaults for backwards compatibility with old cli\n        var _a = rule.identityClaim, identityClaim = _a === void 0 ? 'cognito:username' : _a, _b = rule.ownerField, ownerField = _b === void 0 ? 'owner' : _b, _c = rule.operations, operations = _c === void 0 ? ['create', 'update', 'delete', 'read'] : _c, _d = rule.provider, provider = _d === void 0 ? 'userPools' : _d, _e = rule.groupClaim, groupClaim = _e === void 0 ? 'cognito:groups' : _e, _f = rule.allow, authStrategy = _f === void 0 ? 'iam' : _f, _g = rule.groups, groups = _g === void 0 ? [] : _g, _h = rule.groupsField, groupsField = _h === void 0 ? '' : _h;\n        var isReadAuthorized = operations.includes('read');\n        var isOwnerAuth = authStrategy === 'owner';\n        if (!isReadAuthorized && !isOwnerAuth) {\n            return;\n        }\n        var authRule = {\n            identityClaim: identityClaim,\n            ownerField: ownerField,\n            provider: provider,\n            groupClaim: groupClaim,\n            authStrategy: authStrategy,\n            groups: groups,\n            groupsField: groupsField,\n            areSubscriptionsPublic: false,\n        };\n        if (isOwnerAuth) {\n            // look for the subscription level override\n            // only pay attention to the public level\n            var modelConfig = []\n                .concat(modelDefinition.attributes || [])\n                .find(function (attr) { return attr && attr.type === 'model'; });\n            // find the subscriptions level. ON is default\n            var _j = (modelConfig || {}).properties, _k = (_j === void 0 ? {} : _j).subscriptions, _l = (_k === void 0 ? {} : _k).level, level = _l === void 0 ? 'on' : _l;\n            // treat subscriptions as public for owner auth with unprotected reads\n            // when `read` is omitted from `operations`\n            authRule.areSubscriptionsPublic =\n                !operations.includes('read') || level === 'public';\n        }\n        if (isOwnerAuth) {\n            // owner rules has least priority\n            resultRules.push(authRule);\n            return;\n        }\n        resultRules.unshift(authRule);\n    });\n    return resultRules;\n}\nexport function buildSubscriptionGraphQLOperation(namespace, modelDefinition, transformerMutationType, isOwnerAuthorization, ownerField, filterArg) {\n    if (filterArg === void 0) { filterArg = false; }\n    var selectionSet = generateSelectionSet(namespace, modelDefinition);\n    var typeName = modelDefinition.name;\n    var opName = \"on\" + transformerMutationType + typeName;\n    var docArgs = [];\n    var opArgs = [];\n    if (filterArg) {\n        docArgs.push(\"$filter: ModelSubscription\" + typeName + \"FilterInput\");\n        opArgs.push('filter: $filter');\n    }\n    if (isOwnerAuthorization) {\n        docArgs.push(\"$\" + ownerField + \": String!\");\n        opArgs.push(ownerField + \": $\" + ownerField);\n    }\n    var docStr = docArgs.length ? \"(\" + docArgs.join(',') + \")\" : '';\n    var opStr = opArgs.length ? \"(\" + opArgs.join(',') + \")\" : '';\n    return [\n        transformerMutationType,\n        opName,\n        \"subscription operation\" + docStr + \"{\\n\\t\\t\\t\" + opName + opStr + \"{\\n\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t}\\n\\t\\t}\",\n    ];\n}\nexport function buildGraphQLOperation(namespace, modelDefinition, graphQLOpType) {\n    var selectionSet = generateSelectionSet(namespace, modelDefinition);\n    var typeName = modelDefinition.name, pluralTypeName = modelDefinition.pluralName;\n    var operation;\n    var documentArgs;\n    var operationArgs;\n    var transformerMutationType;\n    switch (graphQLOpType) {\n        case 'LIST':\n            operation = \"sync\" + pluralTypeName;\n            documentArgs = \"($limit: Int, $nextToken: String, $lastSync: AWSTimestamp, $filter: Model\" + typeName + \"FilterInput)\";\n            operationArgs =\n                '(limit: $limit, nextToken: $nextToken, lastSync: $lastSync, filter: $filter)';\n            selectionSet = \"items {\\n\\t\\t\\t\\t\\t\\t\\t\" + selectionSet + \"\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tnextToken\\n\\t\\t\\t\\t\\t\\tstartedAt\";\n            break;\n        case 'CREATE':\n            operation = \"create\" + typeName;\n            documentArgs = \"($input: Create\" + typeName + \"Input!)\";\n            operationArgs = '(input: $input)';\n            transformerMutationType = TransformerMutationType.CREATE;\n            break;\n        case 'UPDATE':\n            operation = \"update\" + typeName;\n            documentArgs = \"($input: Update\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.UPDATE;\n            break;\n        case 'DELETE':\n            operation = \"delete\" + typeName;\n            documentArgs = \"($input: Delete\" + typeName + \"Input!, $condition: Model\" + typeName + \"ConditionInput)\";\n            operationArgs = '(input: $input, condition: $condition)';\n            transformerMutationType = TransformerMutationType.DELETE;\n            break;\n        case 'GET':\n            operation = \"get\" + typeName;\n            documentArgs = \"($id: ID!)\";\n            operationArgs = '(id: $id)';\n            transformerMutationType = TransformerMutationType.GET;\n            break;\n        default:\n            throw new Error(\"Invalid graphQlOpType \" + graphQLOpType);\n    }\n    return [\n        [\n            transformerMutationType,\n            operation,\n            GraphQLOperationType[graphQLOpType] + \" operation\" + documentArgs + \"{\\n\\t\\t\" + operation + operationArgs + \"{\\n\\t\\t\\t\" + selectionSet + \"\\n\\t\\t}\\n\\t}\",\n        ],\n    ];\n}\nexport function createMutationInstanceFromModelOperation(relationships, modelDefinition, opType, model, element, condition, MutationEventConstructor, modelInstanceCreator, id) {\n    var operation;\n    switch (opType) {\n        case OpType.INSERT:\n            operation = TransformerMutationType.CREATE;\n            break;\n        case OpType.UPDATE:\n            operation = TransformerMutationType.UPDATE;\n            break;\n        case OpType.DELETE:\n            operation = TransformerMutationType.DELETE;\n            break;\n        default:\n            throw new Error(\"Invalid opType \" + opType);\n    }\n    // stringify nested objects of type AWSJSON\n    // this allows us to return parsed JSON to users (see `castInstanceType()` in datastore.ts),\n    // but still send the object correctly over the wire\n    var replacer = function (k, v) {\n        var isAWSJSON = k &&\n            v !== null &&\n            typeof v === 'object' &&\n            modelDefinition.fields[k] &&\n            modelDefinition.fields[k].type === 'AWSJSON';\n        if (isAWSJSON) {\n            return JSON.stringify(v);\n        }\n        return v;\n    };\n    var modelId = getIdentifierValue(modelDefinition, element);\n    var optionalId = OpType.INSERT && id ? { id: id } : {};\n    var mutationEvent = modelInstanceCreator(MutationEventConstructor, __assign(__assign({}, optionalId), { data: JSON.stringify(element, replacer), modelId: modelId, model: model.name, operation: operation, condition: JSON.stringify(condition) }));\n    return mutationEvent;\n}\nexport function predicateToGraphQLCondition(predicate, modelDefinition) {\n    var result = {};\n    if (!predicate || !Array.isArray(predicate.predicates)) {\n        return result;\n    }\n    // This is compatible with how the GQL Transform currently generates the Condition Input,\n    // i.e. any PK and SK fields are omitted and can't be used as conditions.\n    // However, I think this limits usability.\n    // What if we want to delete all records where SK > some value\n    // Or all records where PK = some value but SKs are different values\n    // TODO: if the Transform gets updated we'll need to modify this logic to only omit\n    // key fields from the predicate/condition when ALL of the keyFields are present and using `eq` operators\n    var keyFields = extractPrimaryKeyFieldNames(modelDefinition);\n    return predicateToGraphQLFilter(predicate, keyFields);\n}\n/**\n * @param predicatesGroup - Predicate Group\n    @returns GQL Filter Expression from Predicate Group\n    \n    @remarks Flattens redundant list predicates\n    @example\n\n    ```js\n    { and:[{ and:[{ username:  { eq: 'bob' }}] }] }\n    ```\n    Becomes\n    ```js\n    { and:[{ username: { eq: 'bob' }}] }\n    ```\n    */\nexport function predicateToGraphQLFilter(predicatesGroup, fieldsToOmit, root) {\n    if (fieldsToOmit === void 0) { fieldsToOmit = []; }\n    if (root === void 0) { root = true; }\n    var result = {};\n    if (!predicatesGroup || !Array.isArray(predicatesGroup.predicates)) {\n        return result;\n    }\n    var type = predicatesGroup.type, predicates = predicatesGroup.predicates;\n    var isList = type === 'and' || type === 'or';\n    result[type] = isList ? [] : {};\n    var children = [];\n    predicates.forEach(function (predicate) {\n        var _a, _b;\n        if (isPredicateObj(predicate)) {\n            var field = predicate.field, operator = predicate.operator, operand = predicate.operand;\n            if (fieldsToOmit.includes(field))\n                return;\n            var gqlField = (_a = {},\n                _a[field] = (_b = {}, _b[operator] = operand, _b),\n                _a);\n            children.push(gqlField);\n            return;\n        }\n        var child = predicateToGraphQLFilter(predicate, fieldsToOmit, false);\n        if (Object.keys(child).length > 0) {\n            children.push(child);\n        }\n    });\n    // flatten redundant list predicates\n    if (children.length === 1) {\n        var _a = __read(children, 1), child = _a[0];\n        if (\n        // any nested list node\n        (isList && !root) ||\n            // root list node where the only child is also a list node\n            (isList && root && ('and' in child || 'or' in child))) {\n            delete result[type];\n            Object.assign(result, child);\n            return result;\n        }\n    }\n    children.forEach(function (child) {\n        if (isList) {\n            result[type].push(child);\n        }\n        else {\n            result[type] = child;\n        }\n    });\n    if (isList) {\n        if (result[type].length === 0)\n            return {};\n    }\n    else {\n        if (Object.keys(result[type]).length === 0)\n            return {};\n    }\n    return result;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns set of distinct field names in the filter group\n */\nexport function filterFields(group) {\n    var fields = new Set();\n    if (!group || !Array.isArray(group.predicates))\n        return fields;\n    var predicates = group.predicates;\n    var stack = __spread(predicates);\n    while (stack.length > 0) {\n        var current = stack.pop();\n        if (isPredicateObj(current)) {\n            fields.add(current.field);\n        }\n        else if (isPredicateGroup(current)) {\n            stack.push.apply(stack, __spread(current.predicates));\n        }\n    }\n    return fields;\n}\n/**\n *\n * @param modelDefinition\n * @returns set of field names used with dynamic auth modes configured for the provided model definition\n */\nexport function dynamicAuthFields(modelDefinition) {\n    var e_1, _a;\n    var rules = getAuthorizationRules(modelDefinition);\n    var fields = new Set();\n    try {\n        for (var rules_1 = __values(rules), rules_1_1 = rules_1.next(); !rules_1_1.done; rules_1_1 = rules_1.next()) {\n            var rule = rules_1_1.value;\n            if (rule.groupsField && !rule.groups.length) {\n                // dynamic group rule will have no values in `rule.groups`\n                fields.add(rule.groupsField);\n            }\n            else if (rule.ownerField) {\n                fields.add(rule.ownerField);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (rules_1_1 && !rules_1_1.done && (_a = rules_1.return)) _a.call(rules_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return fields;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns the total number of OR'd predicates in the filter group\n *\n * @example returns 2\n * ```js\n * { type: \"or\", predicates: [\n * { field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * { field: \"title\", operator: \"contains\", operand: \"abc\" },\n * ]}\n * ```\n */\nexport function countFilterCombinations(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return 0;\n    var count = 0;\n    var stack = [group];\n    while (stack.length > 0) {\n        var current = stack.pop();\n        if (isPredicateGroup(current)) {\n            var predicates = current.predicates, type = current.type;\n            // ignore length = 1; groups with 1 predicate will get flattened when converted to gqlFilter\n            if (type === 'or' && predicates.length > 1) {\n                count += predicates.length;\n            }\n            stack.push.apply(stack, __spread(predicates));\n        }\n    }\n    // if we didn't encounter any OR groups, default to 1\n    return count || 1;\n}\n/**\n *\n * @param group - selective sync predicate group\n * @returns name of repeated field | null\n *\n * @example returns \"username\"\n * ```js\n * { type: \"and\", predicates: [\n * \t\t{ field: \"username\", operator: \"beginsWith\", operand: \"a\" },\n * \t\t{ field: \"username\", operator: \"contains\", operand: \"abc\" },\n * ] }\n * ```\n */\nexport function repeatedFieldInGroup(group) {\n    if (!group || !Array.isArray(group.predicates))\n        return null;\n    // convert to filter in order to flatten redundant groups\n    var gqlFilter = predicateToGraphQLFilter(group);\n    var stack = [gqlFilter];\n    var hasGroupRepeatedFields = function (fields) {\n        var e_2, _a;\n        var seen = {};\n        try {\n            for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {\n                var f = fields_1_1.value;\n                var _b = __read(Object.keys(f), 1), fieldName = _b[0];\n                if (seen[fieldName]) {\n                    return fieldName;\n                }\n                seen[fieldName] = true;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return null;\n    };\n    while (stack.length > 0) {\n        var current = stack.pop();\n        var _a = __read(Object.keys(current), 1), key = _a[0];\n        var values = current[key];\n        if (!Array.isArray(values)) {\n            return null;\n        }\n        // field value will be single object\n        var predicateObjects = values.filter(function (v) { return !Array.isArray(Object.values(v)[0]); });\n        // group value will be an array\n        var predicateGroups = values.filter(function (v) {\n            return Array.isArray(Object.values(v)[0]);\n        });\n        if (key === 'and') {\n            var repeatedField = hasGroupRepeatedFields(predicateObjects);\n            if (repeatedField) {\n                return repeatedField;\n            }\n        }\n        stack.push.apply(stack, __spread(predicateGroups));\n    }\n    return null;\n}\nexport var RTFError;\n(function (RTFError) {\n    RTFError[RTFError[\"UnknownField\"] = 0] = \"UnknownField\";\n    RTFError[RTFError[\"MaxAttributes\"] = 1] = \"MaxAttributes\";\n    RTFError[RTFError[\"MaxCombinations\"] = 2] = \"MaxCombinations\";\n    RTFError[RTFError[\"RepeatedFieldname\"] = 3] = \"RepeatedFieldname\";\n    RTFError[RTFError[\"NotGroup\"] = 4] = \"NotGroup\";\n    RTFError[RTFError[\"FieldNotInType\"] = 5] = \"FieldNotInType\";\n})(RTFError || (RTFError = {}));\nexport function generateRTFRemediation(errorType, modelDefinition, predicatesGroup) {\n    var selSyncFields = filterFields(predicatesGroup);\n    var selSyncFieldStr = __spread(selSyncFields).join(', ');\n    var dynamicAuthModeFields = dynamicAuthFields(modelDefinition);\n    var dynamicAuthFieldsStr = __spread(dynamicAuthModeFields).join(', ');\n    var filterCombinations = countFilterCombinations(predicatesGroup);\n    var repeatedField = repeatedFieldInGroup(predicatesGroup);\n    switch (errorType) {\n        case RTFError.UnknownField:\n            return (\"Your API was generated with an older version of the CLI that doesn't support backend subscription filtering.\" +\n                'To enable backend subscription filtering, upgrade your Amplify CLI to the latest version and push your app by running `amplify upgrade` followed by `amplify push`');\n        case RTFError.MaxAttributes: {\n            var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + selSyncFields.size + \" different model fields: \" + selSyncFieldStr + \".\\n\\n\";\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" +\n                        \"Dynamic auth modes, such as owner auth and dynamic group auth each utilize 1 field.\\n\" +\n                        (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n            }\n            return message;\n        }\n        case RTFError.MaxCombinations: {\n            var message = \"Your selective sync expression for \" + modelDefinition.name + \" contains \" + filterCombinations + \" field combinations (total number of predicates in an OR expression).\\n\\n\";\n            if (dynamicAuthModeFields.size > 0) {\n                message +=\n                    \"Note: the number of fields you can use with selective sync is affected by @auth rules configured on the model.\\n\\n\" +\n                        \"Dynamic auth modes, such as owner auth and dynamic group auth factor in to the number of combinations you're using.\\n\" +\n                        (\"You currently have \" + dynamicAuthModeFields.size + \" dynamic auth mode(s) configured on this model: \" + dynamicAuthFieldsStr + \".\");\n            }\n            return message;\n        }\n        case RTFError.RepeatedFieldname:\n            return \"Your selective sync expression for \" + modelDefinition.name + \" contains multiple entries for \" + repeatedField + \" in the same AND group.\";\n        case RTFError.NotGroup:\n            return (\"Your selective sync expression for \" + modelDefinition.name + \" uses a `not` group. If you'd like to filter subscriptions in the backend, \" +\n                \"rewrite your expression using `ne` or `notContains` operators.\");\n        case RTFError.FieldNotInType:\n            // no remediation instructions. We'll surface the message directly\n            return '';\n    }\n}\nexport function getUserGroupsFromToken(token, rule) {\n    // validate token against groupClaim\n    var userGroups = token[rule.groupClaim] || [];\n    if (typeof userGroups === 'string') {\n        var parsedGroups = void 0;\n        try {\n            parsedGroups = JSON.parse(userGroups);\n        }\n        catch (e) {\n            parsedGroups = userGroups;\n        }\n        userGroups = [].concat(parsedGroups);\n    }\n    return userGroups;\n}\nexport function getModelAuthModes(_a) {\n    var authModeStrategy = _a.authModeStrategy, defaultAuthMode = _a.defaultAuthMode, modelName = _a.modelName, schema = _a.schema;\n    return __awaiter(this, void 0, void 0, function () {\n        var operations, modelAuthModes, error_1;\n        var _this = this;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    operations = Object.values(ModelOperation);\n                    modelAuthModes = {\n                        CREATE: [],\n                        READ: [],\n                        UPDATE: [],\n                        DELETE: [],\n                    };\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, Promise.all(operations.map(function (operation) { return __awaiter(_this, void 0, void 0, function () {\n                            var authModes;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, authModeStrategy({\n                                            schema: schema,\n                                            modelName: modelName,\n                                            operation: operation,\n                                        })];\n                                    case 1:\n                                        authModes = _a.sent();\n                                        if (typeof authModes === 'string') {\n                                            modelAuthModes[operation] = [authModes];\n                                        }\n                                        else if (Array.isArray(authModes) && authModes.length) {\n                                            modelAuthModes[operation] = authModes;\n                                        }\n                                        else {\n                                            // Use default auth mode if nothing is returned from authModeStrategy\n                                            modelAuthModes[operation] = [defaultAuthMode];\n                                        }\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); }))];\n                case 2:\n                    _b.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _b.sent();\n                    logger.debug(\"Error getting auth modes for model: \" + modelName, error_1);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/, modelAuthModes];\n            }\n        });\n    });\n}\nexport function getForbiddenError(error) {\n    var forbiddenErrorMessages = [\n        'Request failed with status code 401',\n        'Request failed with status code 403',\n    ];\n    var forbiddenError;\n    if (error && error.errors) {\n        forbiddenError = error.errors.find(function (err) {\n            return forbiddenErrorMessages.includes(err.message);\n        });\n    }\n    else if (error && error.message) {\n        forbiddenError = error;\n    }\n    if (forbiddenError) {\n        return forbiddenError.message;\n    }\n    return null;\n}\nexport function getClientSideAuthError(error) {\n    var clientSideAuthErrors = Object.values(GraphQLAuthError);\n    var clientSideError = error &&\n        error.message &&\n        clientSideAuthErrors.find(function (clientError) {\n            return error.message.includes(clientError);\n        });\n    return clientSideError || null;\n}\nexport function getTokenForCustomAuth(authMode, amplifyConfig) {\n    if (amplifyConfig === void 0) { amplifyConfig = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, functionAuthProvider, token, error_2;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(authMode === GRAPHQL_AUTH_MODE.AWS_LAMBDA)) return [3 /*break*/, 6];\n                    _a = amplifyConfig.authProviders, functionAuthProvider = (_a === void 0 ? { functionAuthProvider: null } : _a).functionAuthProvider;\n                    if (!(functionAuthProvider && typeof functionAuthProvider === 'function')) return [3 /*break*/, 5];\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, functionAuthProvider()];\n                case 2:\n                    token = (_b.sent()).token;\n                    return [2 /*return*/, token];\n                case 3:\n                    error_2 = _b.sent();\n                    throw new Error(\"Error retrieving token from `functionAuthProvider`: \" + error_2);\n                case 4: return [3 /*break*/, 6];\n                case 5: \n                // TODO: add docs link once available\n                throw new Error(\"You must provide a `functionAuthProvider` function to `DataStore.configure` when using \" + GRAPHQL_AUTH_MODE.AWS_LAMBDA);\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\n// Util that takes a modelDefinition and model and returns either the id value(s) or the custom primary key value(s)\nexport function getIdentifierValue(modelDefinition, model) {\n    var pkFieldNames = extractPrimaryKeyFieldNames(modelDefinition);\n    var idOrPk = pkFieldNames.map(function (f) { return model[f]; }).join(IDENTIFIER_KEY_SEPARATOR);\n    return idOrPk;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}