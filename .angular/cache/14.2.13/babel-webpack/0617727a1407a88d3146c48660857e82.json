{"ast":null,"code":"import { Crc32 } from \"@aws-crypto/crc32\";\nconst PRELUDE_MEMBER_LENGTH = 4;\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\nconst CHECKSUM_LENGTH = 4;\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\nexport function splitMessage({\n  byteLength,\n  byteOffset,\n  buffer\n}) {\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n  }\n\n  const view = new DataView(buffer, byteOffset, byteLength);\n  const messageLength = view.getUint32(0, false);\n\n  if (byteLength !== messageLength) {\n    throw new Error(\"Reported message length does not match received message length\");\n  }\n\n  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);\n  }\n\n  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);\n  }\n\n  return {\n    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n  };\n}","map":{"version":3,"names":["Crc32","PRELUDE_MEMBER_LENGTH","PRELUDE_LENGTH","CHECKSUM_LENGTH","MINIMUM_MESSAGE_LENGTH","splitMessage","byteLength","byteOffset","buffer","Error","view","DataView","messageLength","getUint32","headerLength","expectedPreludeChecksum","expectedMessageChecksum","checksummer","update","Uint8Array","digest","headers","body"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/eventstream-codec/dist-es/splitMessage.js"],"sourcesContent":["import { Crc32 } from \"@aws-crypto/crc32\";\nconst PRELUDE_MEMBER_LENGTH = 4;\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\nconst CHECKSUM_LENGTH = 4;\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\nexport function splitMessage({ byteLength, byteOffset, buffer }) {\n    if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n    }\n    const view = new DataView(buffer, byteOffset, byteLength);\n    const messageLength = view.getUint32(0, false);\n    if (byteLength !== messageLength) {\n        throw new Error(\"Reported message length does not match received message length\");\n    }\n    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n    if (expectedPreludeChecksum !== checksummer.digest()) {\n        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);\n    }\n    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n    if (expectedMessageChecksum !== checksummer.digest()) {\n        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);\n    }\n    return {\n        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),\n    };\n}\n"],"mappings":"AAAA,SAASA,KAAT,QAAsB,mBAAtB;AACA,MAAMC,qBAAqB,GAAG,CAA9B;AACA,MAAMC,cAAc,GAAGD,qBAAqB,GAAG,CAA/C;AACA,MAAME,eAAe,GAAG,CAAxB;AACA,MAAMC,sBAAsB,GAAGF,cAAc,GAAGC,eAAe,GAAG,CAAlE;AACA,OAAO,SAASE,YAAT,CAAsB;EAAEC,UAAF;EAAcC,UAAd;EAA0BC;AAA1B,CAAtB,EAA0D;EAC7D,IAAIF,UAAU,GAAGF,sBAAjB,EAAyC;IACrC,MAAM,IAAIK,KAAJ,CAAU,yEAAV,CAAN;EACH;;EACD,MAAMC,IAAI,GAAG,IAAIC,QAAJ,CAAaH,MAAb,EAAqBD,UAArB,EAAiCD,UAAjC,CAAb;EACA,MAAMM,aAAa,GAAGF,IAAI,CAACG,SAAL,CAAe,CAAf,EAAkB,KAAlB,CAAtB;;EACA,IAAIP,UAAU,KAAKM,aAAnB,EAAkC;IAC9B,MAAM,IAAIH,KAAJ,CAAU,gEAAV,CAAN;EACH;;EACD,MAAMK,YAAY,GAAGJ,IAAI,CAACG,SAAL,CAAeZ,qBAAf,EAAsC,KAAtC,CAArB;EACA,MAAMc,uBAAuB,GAAGL,IAAI,CAACG,SAAL,CAAeX,cAAf,EAA+B,KAA/B,CAAhC;EACA,MAAMc,uBAAuB,GAAGN,IAAI,CAACG,SAAL,CAAeP,UAAU,GAAGH,eAA5B,EAA6C,KAA7C,CAAhC;EACA,MAAMc,WAAW,GAAG,IAAIjB,KAAJ,GAAYkB,MAAZ,CAAmB,IAAIC,UAAJ,CAAeX,MAAf,EAAuBD,UAAvB,EAAmCL,cAAnC,CAAnB,CAApB;;EACA,IAAIa,uBAAuB,KAAKE,WAAW,CAACG,MAAZ,EAAhC,EAAsD;IAClD,MAAM,IAAIX,KAAJ,CAAW,kDAAiDM,uBAAwB,mDAAkDE,WAAW,CAACG,MAAZ,EAAqB,GAA3J,CAAN;EACH;;EACDH,WAAW,CAACC,MAAZ,CAAmB,IAAIC,UAAJ,CAAeX,MAAf,EAAuBD,UAAU,GAAGL,cAApC,EAAoDI,UAAU,IAAIJ,cAAc,GAAGC,eAArB,CAA9D,CAAnB;;EACA,IAAIa,uBAAuB,KAAKC,WAAW,CAACG,MAAZ,EAAhC,EAAsD;IAClD,MAAM,IAAIX,KAAJ,CAAW,yBAAwBQ,WAAW,CAACG,MAAZ,EAAqB,yCAAwCJ,uBAAwB,EAAxH,CAAN;EACH;;EACD,OAAO;IACHK,OAAO,EAAE,IAAIV,QAAJ,CAAaH,MAAb,EAAqBD,UAAU,GAAGL,cAAb,GAA8BC,eAAnD,EAAoEW,YAApE,CADN;IAEHQ,IAAI,EAAE,IAAIH,UAAJ,CAAeX,MAAf,EAAuBD,UAAU,GAAGL,cAAb,GAA8BC,eAA9B,GAAgDW,YAAvE,EAAqFF,aAAa,GAAGE,YAAhB,IAAgCZ,cAAc,GAAGC,eAAjB,GAAmCA,eAAnE,CAArF;EAFH,CAAP;AAIH"},"metadata":{},"sourceType":"module"}