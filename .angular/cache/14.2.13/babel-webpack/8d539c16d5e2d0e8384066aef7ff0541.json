{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { slice_util, StridedSlice, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nlet wasmStridedSlice;\n\nfunction setup(backend) {\n  wasmStridedSlice = backend.wasm.cwrap(StridedSlice, null\n  /*void*/\n  , ['number', 'array', 'number', 'array', 'array', 'array', 'array', 'array', 'number', 'number']);\n}\n\nexport function stridedSlice(args) {\n  const {\n    backend,\n    inputs,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  } = attrs;\n  const {\n    finalShapeSparse,\n    finalShape,\n    isIdentity,\n    sliceDim0,\n    isSimpleSlice,\n    begin: $begin,\n    end: $end,\n    strides: $strides\n  } = slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n  let result;\n\n  if (isIdentity) {\n    // Optimization #1, slice is a no-op plus reshape\n    result = reshape({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        shape: finalShape\n      }\n    });\n  } else if (sliceDim0 || isSimpleSlice) {\n    // Optimization #2, slice is memory contiguous (only occurs in dim 0)\n    util.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);\n    const size = slice_util.computeOutShape($begin, $end, $strides); // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).\n\n    const sliced = slice({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        begin: $begin,\n        size\n      }\n    });\n    result = reshape({\n      inputs: {\n        x: sliced\n      },\n      backend,\n      attrs: {\n        shape: finalShape\n      }\n    });\n    backend.disposeData(sliced.dataId);\n  } else {\n    const out = backend.makeOutput(finalShapeSparse, 'float32');\n    const xId = backend.dataIdMap.get(x.dataId).id;\n    const xStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(x.shape)).buffer);\n    const beginBytes = new Uint8Array(new Int32Array($begin).buffer);\n    const endBytes = new Uint8Array(new Int32Array($end).buffer);\n    const stridesBytes = new Uint8Array(new Int32Array($strides).buffer);\n    const outputShapeBytes = new Uint8Array(new Int32Array(finalShapeSparse).buffer);\n    const outStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(finalShapeSparse)).buffer);\n    const outId = backend.dataIdMap.get(out.dataId).id;\n    wasmStridedSlice(xId, xStridesBytes, x.shape.length, beginBytes, endBytes, stridesBytes, outputShapeBytes, outStridesBytes, finalShapeSparse.length, outId);\n    result = reshape({\n      inputs: {\n        x: out\n      },\n      backend,\n      attrs: {\n        shape: finalShape\n      }\n    });\n    backend.disposeData(out.dataId);\n  }\n\n  return result;\n}\nexport const stridedSliceConfig = {\n  kernelName: StridedSlice,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: stridedSlice\n};","map":{"version":3,"names":["slice_util","StridedSlice","util","reshape","slice","wasmStridedSlice","setup","backend","wasm","cwrap","stridedSlice","args","inputs","attrs","x","begin","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","finalShapeSparse","finalShape","isIdentity","sliceDim0","isSimpleSlice","$begin","$end","$strides","sliceInfo","shape","result","assert","length","size","computeOutShape","sliced","disposeData","dataId","out","makeOutput","xId","dataIdMap","get","id","xStridesBytes","Uint8Array","Int32Array","computeStrides","buffer","beginBytes","endBytes","stridesBytes","outputShapeBytes","outStridesBytes","outId","stridedSliceConfig","kernelName","backendName","setupFunc","kernelFunc"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-wasm/dist/kernels/StridedSlice.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { slice_util, StridedSlice, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\nlet wasmStridedSlice;\nfunction setup(backend) {\n    wasmStridedSlice = backend.wasm.cwrap(StridedSlice, null /*void*/, [\n        'number',\n        'array',\n        'number',\n        'array',\n        'array',\n        'array',\n        'array',\n        'array',\n        'number',\n        'number',\n    ]);\n}\nexport function stridedSlice(args) {\n    const { backend, inputs, attrs } = args;\n    const { x } = inputs;\n    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;\n    const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);\n    let result;\n    if (isIdentity) {\n        // Optimization #1, slice is a no-op plus reshape\n        result = reshape({ inputs: { x }, backend, attrs: { shape: finalShape } });\n    }\n    else if (sliceDim0 || isSimpleSlice) {\n        // Optimization #2, slice is memory contiguous (only occurs in dim 0)\n        util.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);\n        const size = slice_util.computeOutShape($begin, $end, $strides);\n        // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).\n        const sliced = slice({ inputs: { x }, backend, attrs: { begin: $begin, size } });\n        result =\n            reshape({ inputs: { x: sliced }, backend, attrs: { shape: finalShape } });\n        backend.disposeData(sliced.dataId);\n    }\n    else {\n        const out = backend.makeOutput(finalShapeSparse, 'float32');\n        const xId = backend.dataIdMap.get(x.dataId).id;\n        const xStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(x.shape)).buffer);\n        const beginBytes = new Uint8Array(new Int32Array($begin).buffer);\n        const endBytes = new Uint8Array(new Int32Array($end).buffer);\n        const stridesBytes = new Uint8Array(new Int32Array($strides).buffer);\n        const outputShapeBytes = new Uint8Array(new Int32Array(finalShapeSparse).buffer);\n        const outStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(finalShapeSparse)).buffer);\n        const outId = backend.dataIdMap.get(out.dataId).id;\n        wasmStridedSlice(xId, xStridesBytes, x.shape.length, beginBytes, endBytes, stridesBytes, outputShapeBytes, outStridesBytes, finalShapeSparse.length, outId);\n        result = reshape({ inputs: { x: out }, backend, attrs: { shape: finalShape } });\n        backend.disposeData(out.dataId);\n    }\n    return result;\n}\nexport const stridedSliceConfig = {\n    kernelName: StridedSlice,\n    backendName: 'wasm',\n    setupFunc: setup,\n    kernelFunc: stridedSlice\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}