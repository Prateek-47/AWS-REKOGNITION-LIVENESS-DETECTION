{"ast":null,"code":"import { __assign, __spreadArray, __read, __values } from './_virtual/_tslib.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { init, raise as raise$1, send as send$1, update, log as log$1, cancel as cancel$1, assign as assign$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nimport * as actionTypes from './actionTypes.js';\nexport { actionTypes };\nimport { toSCXMLEvent, isString, isFunction, toEventObject, getEventType, updateContext, flatten, isArray, toArray, toGuard, evaluateGuard, warn } from './utils.js';\nimport { IS_PRODUCTION } from './environment.js';\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\n\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\n\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  return actionObject;\n}\n\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\n\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\n\nfunction raise(event, options) {\n  return {\n    type: raise$1,\n    event: typeof event === 'function' ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options === null || options === void 0 ? void 0 : options.id\n  };\n}\n\nfunction resolveRaise(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  };\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  return __assign(__assign({}, action), {\n    type: raise$1,\n    _event: resolvedEvent,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @deprecated Use the `sendTo(...)` action creator instead.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    // TODO: don't auto-generate IDs here like that\n    // there is too big chance of the ID collision\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\n\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\n\nfunction sendTo(actor, event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\n\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\n\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\n\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction done(id, data) {\n  var type = \"\".concat(ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction error(id, data) {\n  var type = \"\".concat(ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction forwardTo(target, options) {\n  if (!IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n\n    target = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, __spreadArray([], __read(args), false)) : originalTarget_1;\n\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n\n      return resolvedTarget;\n    };\n  }\n\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nvar pluckAssigns = function (actionBlocks) {\n  var e_1, _a;\n\n  var assignActions = [];\n\n  try {\n    for (var actionBlocks_1 = __values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n\n      while (i < block.actions.length) {\n        if (block.actions[i].type === assign$1) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return assignActions;\n};\n\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n\n  function handleAction(blockType, actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        {\n          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);\n\n          if (predictableExec && typeof raisedAction.delay === 'number') {\n            predictableExec(raisedAction, updatedContext, _event);\n          }\n\n          return raisedAction;\n        }\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here\n\n          warn(!isString(configuredDelay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(configuredDelay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n\n        if (predictableExec && sendAction.to !== SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n\n        return sendAction;\n\n      case log$1:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _b = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromChoose = _b[0],\n              resolvedContextFromChoose = _b[1];\n\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _c = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromPure = _c[0],\n              resolvedContext = _c[1];\n\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n\n      case stop$1:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n\n      case assign$1:\n        {\n          updatedContext = updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n\n          var wrapped = __assign(__assign({}, resolvedActionObject), {\n            exec: function (_ctx) {\n              var args = [];\n\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n\n              exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));\n            }\n          });\n\n          resolvedActionObject = wrapped;\n        }\n\n        return resolvedActionObject;\n    }\n  }\n\n  function processBlock(block) {\n    var e_2, _a;\n\n    var resolvedActions = [];\n\n    try {\n      for (var _b = __values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n\n  var resolvedActions = flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, isActionObject, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendTo, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };","map":{"version":3,"names":["__assign","__spreadArray","__read","__values","SpecialTargets","ActionTypes","init","raise","raise$1","send","send$1","update","log","log$1","cancel","cancel$1","assign","assign$1","error","error$1","stop","stop$1","pure","pure$1","choose","choose$1","actionTypes","toSCXMLEvent","isString","isFunction","toEventObject","getEventType","updateContext","flatten","isArray","toArray","toGuard","evaluateGuard","warn","IS_PRODUCTION","initEvent","type","getActionFunction","actionType","actionFunctionMap","undefined","toActionObject","action","actionObject","exec","name","toString","toActionObjects","actions","map","subAction","toActivityDefinition","id","event","options","delay","resolveRaise","ctx","_event","delaysMap","meta","resolvedEvent","data","resolvedDelay","configDelay","to","resolveSend","resolvedTarget","sendParent","Parent","sendTo","actor","sendUpdate","respond","_","__","_a","origin","defaultLogExpr","context","expr","label","resolveLog","value","sendId","start","activity","activityDef","Start","actorRef","Stop","resolveStop","actorRefOrString","resolvedActorRef","assignment","isActionObject","after","delayRef","idSuffix","concat","After","done","DoneState","eventObject","doneInvoke","DoneInvoke","ErrorPlatform","getActions","Pure","get","forwardTo","target","originalTarget_1","args","_i","arguments","length","apply","Error","escalate","errorData","conds","Choose","pluckAssigns","actionBlocks","e_1","assignActions","actionBlocks_1","actionBlocks_1_1","next","block","i","push","splice","e_1_1","return","call","resolveActions","machine","currentState","currentContext","predictableExec","preserveActionOrder","updatedContext","preservedContexts","deferredToBlockEnd","handleAction","blockType","raisedAction","delays","sendAction","configuredDelay","Internal","resolved","chooseAction","matchedActions","find","condition","guard","cond","guards","_b","resolvedActionsFromChoose","resolvedContextFromChoose","_c","resolvedActionsFromPure","resolvedContext","resolvedActionObject","exec_1","contextIndex_1","wrapped","_ctx","processBlock","e_2","resolvedActions","e_2_1","forEach"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/xstate/es/actions.js"],"sourcesContent":["import { __assign, __spreadArray, __read, __values } from './_virtual/_tslib.js';\nimport { SpecialTargets, ActionTypes } from './types.js';\nimport { init, raise as raise$1, send as send$1, update, log as log$1, cancel as cancel$1, assign as assign$1, error as error$1, stop as stop$1, pure as pure$1, choose as choose$1 } from './actionTypes.js';\nimport * as actionTypes from './actionTypes.js';\nexport { actionTypes };\nimport { toSCXMLEvent, isString, isFunction, toEventObject, getEventType, updateContext, flatten, isArray, toArray, toGuard, evaluateGuard, warn } from './utils.js';\nimport { IS_PRODUCTION } from './environment.js';\n\nvar initEvent = /*#__PURE__*/toSCXMLEvent({\n  type: init\n});\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  return actionObject;\n}\nvar toActionObjects = function (action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n/**\r\n * Raises an event. This places the event in the internal event queue, so that\r\n * the event is immediately consumed by the machine in the current step.\r\n *\r\n * @param eventType The event to raise.\r\n */\n\nfunction raise(event, options) {\n  return {\n    type: raise$1,\n    event: typeof event === 'function' ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options === null || options === void 0 ? void 0 : options.id\n  };\n}\nfunction resolveRaise(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  };\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  return __assign(__assign({}, action), {\n    type: raise$1,\n    _event: resolvedEvent,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event. This returns an action that will be read by an interpreter to\r\n * send the event in the next step, after the current step is finished executing.\r\n *\r\n * @deprecated Use the `sendTo(...)` action creator instead.\r\n *\r\n * @param event The event to send.\r\n * @param options Options to pass into the send event:\r\n *  - `id` - The unique send event identifier (used with `cancel()`).\r\n *  - `delay` - The number of milliseconds to delay the sending of the event.\r\n *  - `to` - The target of this event (by default, the machine the event was sent from).\r\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: send$1,\n    event: isFunction(event) ? event : toEventObject(event),\n    delay: options ? options.delay : undefined,\n    // TODO: don't auto-generate IDs here like that\n    // there is too big chance of the ID collision\n    id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)\n  };\n}\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n/**\r\n * Sends an event to this machine's parent.\r\n *\r\n * @param event The event to send to the parent machine.\r\n * @param options Options to pass into the send event.\r\n */\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\n/**\r\n * Sends an event to an actor.\r\n *\r\n * @param actor The `ActorRef` to send the event to.\r\n * @param event The event to send, or an expression that evaluates to the event to send\r\n * @param options Send action options\r\n * @returns An XState send action object\r\n */\n\nfunction sendTo(actor, event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: actor\n  }));\n}\n/**\r\n * Sends an update event to this machine's parent.\r\n */\n\nfunction sendUpdate() {\n  return sendParent(update);\n}\n/**\r\n * Sends an event back to the sender of the original event.\r\n *\r\n * @param event The event to send back to the sender\r\n * @param options Options to pass into the send event\r\n */\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function (_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nvar defaultLogExpr = function (context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\r\n *\r\n * @param expr The expression function to evaluate which will be logged.\r\n *  Takes in 2 arguments:\r\n *  - `ctx` - the current state context\r\n *  - `event` - the event that caused this action to be executed.\r\n * @param label The label to give to the logged expression.\r\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: log$1,\n    label: label,\n    expr: expr\n  };\n}\nvar resolveLog = function (action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n/**\r\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\r\n * be executed, nor will its event be sent, unless it has already been sent\r\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\r\n *\r\n * @param sendId The `id` of the `send(...)` action to cancel.\r\n */\n\nvar cancel = function (sendId) {\n  return {\n    type: cancel$1,\n    sendId: sendId\n  };\n};\n/**\r\n * Starts an activity.\r\n *\r\n * @param activity The activity to start.\r\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n/**\r\n * Stops an activity.\r\n *\r\n * @param actorRef The activity to stop.\r\n */\n\nfunction stop(actorRef) {\n  var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n/**\r\n * Updates the current context of the machine.\r\n *\r\n * @param assignment An object that represents the partial context to update.\r\n */\n\nvar assign = function (assignment) {\n  return {\n    type: assign$1,\n    assignment: assignment\n  };\n};\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n/**\r\n * Returns an event type that represents an implicit event that\r\n * is sent after the specified `delay`.\r\n *\r\n * @param delayRef The delay in milliseconds\r\n * @param id The state node ID where this event is handled\r\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\".concat(id) : '';\n  return \"\".concat(ActionTypes.After, \"(\").concat(delayRef, \")\").concat(idSuffix);\n}\n/**\r\n * Returns an event that represents that a final state node\r\n * has been reached in the parent state node.\r\n *\r\n * @param id The final state node's parent state node `id`\r\n * @param data The data to pass into the event\r\n */\n\nfunction done(id, data) {\n  var type = \"\".concat(ActionTypes.DoneState, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n/**\r\n * Returns an event that represents that an invoked service has terminated.\r\n *\r\n * An invoked service is terminated when it has reached a top-level final state node,\r\n * but not when it is canceled.\r\n *\r\n * @param id The final state node ID\r\n * @param data The data to pass into the event\r\n */\n\nfunction doneInvoke(id, data) {\n  var type = \"\".concat(ActionTypes.DoneInvoke, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction error(id, data) {\n  var type = \"\".concat(ActionTypes.ErrorPlatform, \".\").concat(id);\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\nfunction pure(getActions) {\n  return {\n    type: ActionTypes.Pure,\n    get: getActions\n  };\n}\n/**\r\n * Forwards (sends) an event to a specified service.\r\n *\r\n * @param target The target service to forward the event to.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction forwardTo(target, options) {\n  if (!IS_PRODUCTION && (!target || typeof target === 'function')) {\n    var originalTarget_1 = target;\n\n    target = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var resolvedTarget = typeof originalTarget_1 === 'function' ? originalTarget_1.apply(void 0, __spreadArray([], __read(args), false)) : originalTarget_1;\n\n      if (!resolvedTarget) {\n        throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n      }\n\n      return resolvedTarget;\n    };\n  }\n\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n/**\r\n * Escalates an error by sending it as an event to this machine's parent.\r\n *\r\n * @param errorData The error data to send, or the expression function that\r\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\r\n * @param options Options to pass into the send action creator.\r\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: error$1,\n      data: isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: SpecialTargets.Parent\n  }));\n}\nfunction choose(conds) {\n  return {\n    type: ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nvar pluckAssigns = function (actionBlocks) {\n  var e_1, _a;\n\n  var assignActions = [];\n\n  try {\n    for (var actionBlocks_1 = __values(actionBlocks), actionBlocks_1_1 = actionBlocks_1.next(); !actionBlocks_1_1.done; actionBlocks_1_1 = actionBlocks_1.next()) {\n      var block = actionBlocks_1_1.value;\n      var i = 0;\n\n      while (i < block.actions.length) {\n        if (block.actions[i].type === assign$1) {\n          assignActions.push(block.actions[i]);\n          block.actions.splice(i, 1);\n          continue;\n        }\n\n        i++;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (actionBlocks_1_1 && !actionBlocks_1_1.done && (_a = actionBlocks_1.return)) _a.call(actionBlocks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return assignActions;\n};\n\nfunction resolveActions(machine, currentState, currentContext, _event, actionBlocks, predictableExec, preserveActionOrder) {\n  if (preserveActionOrder === void 0) {\n    preserveActionOrder = false;\n  }\n\n  var assignActions = preserveActionOrder ? [] : pluckAssigns(actionBlocks);\n  var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var preservedContexts = preserveActionOrder ? [currentContext] : undefined;\n  var deferredToBlockEnd = [];\n\n  function handleAction(blockType, actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case raise$1:\n        {\n          var raisedAction = resolveRaise(actionObject, updatedContext, _event, machine.options.delays);\n\n          if (predictableExec && typeof raisedAction.delay === 'number') {\n            predictableExec(raisedAction, updatedContext, _event);\n          }\n\n          return raisedAction;\n        }\n\n      case send$1:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!IS_PRODUCTION) {\n          var configuredDelay = actionObject.delay; // warn after resolving as we can create better contextual message here\n\n          warn(!isString(configuredDelay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\".concat(configuredDelay, \"' was found on machine '\").concat(machine.id, \"'\"));\n        }\n\n        if (predictableExec && sendAction.to !== SpecialTargets.Internal) {\n          if (blockType === 'entry') {\n            deferredToBlockEnd.push(sendAction);\n          } else {\n            predictableExec(sendAction, updatedContext, _event);\n          }\n        }\n\n        return sendAction;\n\n      case log$1:\n        {\n          var resolved = resolveLog(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, updatedContext, _event);\n          return resolved;\n        }\n\n      case choose$1:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = toGuard(condition.cond, machine.options.guards);\n            return !guard || evaluateGuard(machine, guard, updatedContext, _event, !predictableExec ? currentState : undefined);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _b = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromChoose = _b[0],\n              resolvedContextFromChoose = _b[1];\n\n          updatedContext = resolvedContextFromChoose;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromChoose;\n        }\n\n      case pure$1:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var _c = __read(resolveActions(machine, currentState, updatedContext, _event, [{\n            type: blockType,\n            actions: toActionObjects(toArray(matchedActions), machine.options.actions)\n          }], predictableExec, preserveActionOrder), 2),\n              resolvedActionsFromPure = _c[0],\n              resolvedContext = _c[1];\n\n          updatedContext = resolvedContext;\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          return resolvedActionsFromPure;\n        }\n\n      case stop$1:\n        {\n          var resolved = resolveStop(actionObject, updatedContext, _event);\n          predictableExec === null || predictableExec === void 0 ? void 0 : predictableExec(resolved, currentContext, _event);\n          return resolved;\n        }\n\n      case assign$1:\n        {\n          updatedContext = updateContext(updatedContext, _event, [actionObject], !predictableExec ? currentState : undefined);\n          preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);\n          break;\n        }\n\n      default:\n        var resolvedActionObject = toActionObject(actionObject, machine.options.actions);\n        var exec_1 = resolvedActionObject.exec;\n\n        if (predictableExec) {\n          predictableExec(resolvedActionObject, updatedContext, _event);\n        } else if (exec_1 && preservedContexts) {\n          var contextIndex_1 = preservedContexts.length - 1;\n\n          var wrapped = __assign(__assign({}, resolvedActionObject), {\n            exec: function (_ctx) {\n              var args = [];\n\n              for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n              }\n\n              exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));\n            }\n          });\n\n          resolvedActionObject = wrapped;\n        }\n\n        return resolvedActionObject;\n    }\n  }\n\n  function processBlock(block) {\n    var e_2, _a;\n\n    var resolvedActions = [];\n\n    try {\n      for (var _b = __values(block.actions), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var action = _c.value;\n        var resolved = handleAction(block.type, action);\n\n        if (resolved) {\n          resolvedActions = resolvedActions.concat(resolved);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    deferredToBlockEnd.forEach(function (action) {\n      predictableExec(action, updatedContext, _event);\n    });\n    deferredToBlockEnd.length = 0;\n    return resolvedActions;\n  }\n\n  var resolvedActions = flatten(actionBlocks.map(processBlock));\n  return [resolvedActions, updatedContext];\n}\n\nexport { after, assign, cancel, choose, done, doneInvoke, error, escalate, forwardTo, getActionFunction, initEvent, isActionObject, log, pure, raise, resolveActions, resolveLog, resolveRaise, resolveSend, resolveStop, respond, send, sendParent, sendTo, sendUpdate, start, stop, toActionObject, toActionObjects, toActivityDefinition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}