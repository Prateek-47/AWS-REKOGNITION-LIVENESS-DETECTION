{"ast":null,"code":"import _asyncToGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HeaderMarshaller } from \"@aws-sdk/eventstream-codec\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { fromUtf8, toUint8Array, toUtf8 } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n  constructor({\n    applyChecksum,\n    credentials,\n    region,\n    service,\n    sha256,\n    uriEscapePath = true\n  }) {\n    this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n\n  presign(originalRequest, options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        signingDate = new Date(),\n        expiresIn = 3600,\n        unsignableHeaders,\n        unhoistableHeaders,\n        signableHeaders,\n        signingRegion,\n        signingService\n      } = options;\n      const credentials = yield _this.credentialProvider();\n\n      _this.validateResolvedCredentials(credentials);\n\n      const region = signingRegion ?? (yield _this.regionProvider());\n      const {\n        longDate,\n        shortDate\n      } = formatDate(signingDate);\n\n      if (expiresIn > MAX_PRESIGNED_TTL) {\n        return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n      }\n\n      const scope = createScope(shortDate, region, signingService ?? _this.service);\n      const request = moveHeadersToQuery(prepareRequest(originalRequest), {\n        unhoistableHeaders\n      });\n\n      if (credentials.sessionToken) {\n        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n      }\n\n      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n      request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n      request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n      request.query[SIGNATURE_QUERY_PARAM] = yield _this.getSignature(longDate, scope, _this.getSigningKey(credentials, region, shortDate, signingService), _this.createCanonicalRequest(request, canonicalHeaders, yield getPayloadHash(originalRequest, _this.sha256)));\n      return request;\n    })();\n  }\n\n  sign(toSign, options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof toSign === \"string\") {\n        return _this2.signString(toSign, options);\n      } else if (toSign.headers && toSign.payload) {\n        return _this2.signEvent(toSign, options);\n      } else if (toSign.message) {\n        return _this2.signMessage(toSign, options);\n      } else {\n        return _this2.signRequest(toSign, options);\n      }\n    })();\n  }\n\n  signEvent({\n    headers,\n    payload\n  }, {\n    signingDate = new Date(),\n    priorSignature,\n    signingRegion,\n    signingService\n  }) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const region = signingRegion ?? (yield _this3.regionProvider());\n      const {\n        shortDate,\n        longDate\n      } = formatDate(signingDate);\n      const scope = createScope(shortDate, region, signingService ?? _this3.service);\n      const hashedPayload = yield getPayloadHash({\n        headers: {},\n        body: payload\n      }, _this3.sha256);\n      const hash = new _this3.sha256();\n      hash.update(headers);\n      const hashedHeaders = toHex(yield hash.digest());\n      const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n      return _this3.signString(stringToSign, {\n        signingDate,\n        signingRegion: region,\n        signingService\n      });\n    })();\n  }\n\n  signMessage(signableMessage, {\n    signingDate = new Date(),\n    signingRegion,\n    signingService\n  }) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const promise = _this4.signEvent({\n        headers: _this4.headerMarshaller.format(signableMessage.message.headers),\n        payload: signableMessage.message.body\n      }, {\n        signingDate,\n        signingRegion,\n        signingService,\n        priorSignature: signableMessage.priorSignature\n      });\n\n      return promise.then(signature => {\n        return {\n          message: signableMessage.message,\n          signature\n        };\n      });\n    })();\n  }\n\n  signString(stringToSign, {\n    signingDate = new Date(),\n    signingRegion,\n    signingService\n  } = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const credentials = yield _this5.credentialProvider();\n\n      _this5.validateResolvedCredentials(credentials);\n\n      const region = signingRegion ?? (yield _this5.regionProvider());\n      const {\n        shortDate\n      } = formatDate(signingDate);\n      const hash = new _this5.sha256(yield _this5.getSigningKey(credentials, region, shortDate, signingService));\n      hash.update(toUint8Array(stringToSign));\n      return toHex(yield hash.digest());\n    })();\n  }\n\n  signRequest(requestToSign, {\n    signingDate = new Date(),\n    signableHeaders,\n    unsignableHeaders,\n    signingRegion,\n    signingService\n  } = {}) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const credentials = yield _this6.credentialProvider();\n\n      _this6.validateResolvedCredentials(credentials);\n\n      const region = signingRegion ?? (yield _this6.regionProvider());\n      const request = prepareRequest(requestToSign);\n      const {\n        longDate,\n        shortDate\n      } = formatDate(signingDate);\n      const scope = createScope(shortDate, region, signingService ?? _this6.service);\n      request.headers[AMZ_DATE_HEADER] = longDate;\n\n      if (credentials.sessionToken) {\n        request.headers[TOKEN_HEADER] = credentials.sessionToken;\n      }\n\n      const payloadHash = yield getPayloadHash(request, _this6.sha256);\n\n      if (!hasHeader(SHA256_HEADER, request.headers) && _this6.applyChecksum) {\n        request.headers[SHA256_HEADER] = payloadHash;\n      }\n\n      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n      const signature = yield _this6.getSignature(longDate, scope, _this6.getSigningKey(credentials, region, shortDate, signingService), _this6.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;\n      return request;\n    })();\n  }\n\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n\n  createStringToSign(longDate, credentialScope, canonicalRequest) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const hash = new _this7.sha256();\n      hash.update(toUint8Array(canonicalRequest));\n      const hashedRequest = yield hash.digest();\n      return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    })();\n  }\n\n  getCanonicalPath({\n    path\n  }) {\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n\n      for (const pathSegment of path.split(\"/\")) {\n        if (pathSegment?.length === 0) continue;\n        if (pathSegment === \".\") continue;\n\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n\n      const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n      const doubleEncoded = encodeURIComponent(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  }\n\n  getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const stringToSign = yield _this8.createStringToSign(longDate, credentialScope, canonicalRequest);\n      const hash = new _this8.sha256(yield keyPromise);\n      hash.update(toUint8Array(stringToSign));\n      return toHex(yield hash.digest());\n    })();\n  }\n\n  getSigningKey(credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n\n}\n\nconst formatDate = now => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\n\nconst getCanonicalHeaderList = headers => Object.keys(headers).sort().join(\";\");","map":{"version":3,"names":["HeaderMarshaller","toHex","normalizeProvider","fromUtf8","toUint8Array","toUtf8","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","SignatureV4","constructor","applyChecksum","credentials","region","service","sha256","uriEscapePath","headerMarshaller","regionProvider","credentialProvider","presign","originalRequest","options","signingDate","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","validateResolvedCredentials","longDate","shortDate","formatDate","Promise","reject","scope","request","sessionToken","query","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","getSignature","createCanonicalRequest","sign","toSign","signString","headers","payload","signEvent","message","signMessage","signRequest","priorSignature","hashedPayload","body","hash","update","hashedHeaders","digest","stringToSign","join","signableMessage","promise","format","then","signature","requestToSign","payloadHash","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","createStringToSign","credentialScope","canonicalRequest","hashedRequest","path","normalizedPathSegments","pathSegment","split","length","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","encodeURIComponent","replace","keyPromise","secretAccessKey","Error","now","slice"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js"],"sourcesContent":["import { HeaderMarshaller } from \"@aws-sdk/eventstream-codec\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { fromUtf8, toUint8Array, toUtf8 } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else if (toSign.message) {\n            return this.signMessage(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {\n        const promise = this.signEvent({\n            headers: this.headerMarshaller.format(signableMessage.message.headers),\n            payload: signableMessage.message.body,\n        }, {\n            signingDate,\n            signingRegion,\n            signingService,\n            priorSignature: signableMessage.priorSignature,\n        });\n        return promise.then((signature) => {\n            return { message: signableMessage.message, signature };\n        });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = encodeURIComponent(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n}\nconst formatDate = (now) => {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    };\n};\nconst getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(\";\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}