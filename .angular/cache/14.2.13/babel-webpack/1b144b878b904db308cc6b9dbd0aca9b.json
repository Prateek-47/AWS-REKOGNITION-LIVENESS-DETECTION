{"ast":null,"code":"import { __assign, __read, __spread } from \"tslib\";\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\nvar logger = new Logger('Predictions');\n\nvar PredictionsClass =\n/** @class */\nfunction () {\n  /**\n   * Initialize Predictions with AWS configurations\n   * @param {PredictionsOptions} options - Configuration object for Predictions\n   */\n  function PredictionsClass(options) {\n    this._options = options;\n    this._convertPluggables = [];\n    this._identifyPluggables = [];\n    this._interpretPluggables = [];\n  }\n\n  PredictionsClass.prototype.getModuleName = function () {\n    return 'Predictions';\n  };\n  /**\n   * add plugin/pluggable into Predictions category\n   * @param {Object} pluggable - an instance of the plugin/pluggable\n   **/\n\n\n  PredictionsClass.prototype.addPluggable = function (pluggable) {\n    if (this.getPluggable(pluggable.getProviderName())) {\n      throw new Error(\"Pluggable with name \" + pluggable.getProviderName() + \" has already been added.\");\n    }\n\n    var pluggableAdded = false;\n\n    if (this.implementsConvertPluggable(pluggable)) {\n      this._convertPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (this.implementsIdentifyPluggable(pluggable)) {\n      this._identifyPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (this.implementsInterpretPluggable(pluggable)) {\n      this._interpretPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (pluggableAdded) {\n      this.configurePluggable(pluggable);\n    }\n  };\n  /**\n   * Get the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  PredictionsClass.prototype.getPluggable = function (providerName) {\n    var pluggable = this.getAllProviders().find(function (pluggable) {\n      return pluggable.getProviderName() === providerName;\n    });\n\n    if (pluggable === undefined) {\n      logger.debug('No plugin found with providerName=>', providerName);\n      return null;\n    } else return pluggable;\n  };\n  /**\n   * Remove the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  PredictionsClass.prototype.removePluggable = function (providerName) {\n    this._convertPluggables = this._convertPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    this._identifyPluggables = this._identifyPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    this._interpretPluggables = this._interpretPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    return;\n  };\n  /**\n   * To make both top level providers and category level providers work with same interface and configuration\n   * this method duplicates Predictions config into parent level config (for top level provider) and\n   * category level config (such as convert, identify etc) and pass both to each provider.\n   */\n\n\n  PredictionsClass.prototype.configure = function (options) {\n    var _this = this;\n\n    var predictionsConfig = options ? options.predictions || options : {};\n    predictionsConfig = __assign(__assign({}, predictionsConfig), options);\n    this._options = Object.assign({}, this._options, predictionsConfig);\n    logger.debug('configure Predictions', this._options);\n    this.getAllProviders().forEach(function (pluggable) {\n      return _this.configurePluggable(pluggable);\n    });\n  };\n\n  PredictionsClass.prototype.interpret = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._interpretPluggables, options);\n    return pluggableToExecute.interpret(input);\n  };\n\n  PredictionsClass.prototype.convert = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._convertPluggables, options);\n    return pluggableToExecute.convert(input);\n  };\n\n  PredictionsClass.prototype.identify = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._identifyPluggables, options);\n    return pluggableToExecute.identify(input);\n  }; // tslint:disable-next-line: max-line-length\n\n\n  PredictionsClass.prototype.getPluggableToExecute = function (pluggables, providerOptions) {\n    // Give preference to provider name first since it is more specific to this call, even if\n    // there is only one provider configured to error out if the name provided is not the one matched.\n    if (providerOptions && providerOptions.providerName) {\n      return __spread(pluggables).find(function (pluggable) {\n        return pluggable.getProviderName() === providerOptions.providerName;\n      });\n    } else {\n      if (pluggables.length === 1) {\n        return pluggables[0];\n      } else {\n        throw new Error('More than one or no providers are configured, ' + 'Either specify a provider name or configure exactly one provider');\n      }\n    }\n  };\n\n  PredictionsClass.prototype.getAllProviders = function () {\n    return __spread(this._convertPluggables, this._identifyPluggables, this._interpretPluggables);\n  };\n\n  PredictionsClass.prototype.configurePluggable = function (pluggable) {\n    var categoryConfig = Object.assign({}, this._options['predictions'], // Parent predictions config for the top level provider\n    this._options[pluggable.getCategory().toLowerCase()] // Actual category level config\n    );\n    pluggable.configure(categoryConfig);\n  };\n\n  PredictionsClass.prototype.implementsConvertPluggable = function (obj) {\n    return obj && typeof obj.convert === 'function';\n  };\n\n  PredictionsClass.prototype.implementsIdentifyPluggable = function (obj) {\n    return obj && typeof obj.identify === 'function';\n  };\n\n  PredictionsClass.prototype.implementsInterpretPluggable = function (obj) {\n    return obj && typeof obj.interpret === 'function';\n  };\n\n  return PredictionsClass;\n}();\n\nexport { PredictionsClass };\nexport var Predictions = new PredictionsClass({});\nAmplify.register(Predictions);","map":{"version":3,"names":["__assign","__read","__spread","Amplify","ConsoleLogger","Logger","logger","PredictionsClass","options","_options","_convertPluggables","_identifyPluggables","_interpretPluggables","prototype","getModuleName","addPluggable","pluggable","getPluggable","getProviderName","Error","pluggableAdded","implementsConvertPluggable","push","implementsIdentifyPluggable","implementsInterpretPluggable","configurePluggable","providerName","getAllProviders","find","undefined","debug","removePluggable","filter","configure","_this","predictionsConfig","predictions","Object","assign","forEach","interpret","input","pluggableToExecute","getPluggableToExecute","convert","identify","pluggables","providerOptions","length","categoryConfig","getCategory","toLowerCase","obj","Predictions","register"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/predictions/lib-esm/Predictions.js"],"sourcesContent":["import { __assign, __read, __spread } from \"tslib\";\nimport { Amplify, ConsoleLogger as Logger } from '@aws-amplify/core';\nvar logger = new Logger('Predictions');\nvar PredictionsClass = /** @class */ (function () {\n    /**\n     * Initialize Predictions with AWS configurations\n     * @param {PredictionsOptions} options - Configuration object for Predictions\n     */\n    function PredictionsClass(options) {\n        this._options = options;\n        this._convertPluggables = [];\n        this._identifyPluggables = [];\n        this._interpretPluggables = [];\n    }\n    PredictionsClass.prototype.getModuleName = function () {\n        return 'Predictions';\n    };\n    /**\n     * add plugin/pluggable into Predictions category\n     * @param {Object} pluggable - an instance of the plugin/pluggable\n     **/\n    PredictionsClass.prototype.addPluggable = function (pluggable) {\n        if (this.getPluggable(pluggable.getProviderName())) {\n            throw new Error(\"Pluggable with name \" + pluggable.getProviderName() + \" has already been added.\");\n        }\n        var pluggableAdded = false;\n        if (this.implementsConvertPluggable(pluggable)) {\n            this._convertPluggables.push(pluggable);\n            pluggableAdded = true;\n        }\n        if (this.implementsIdentifyPluggable(pluggable)) {\n            this._identifyPluggables.push(pluggable);\n            pluggableAdded = true;\n        }\n        if (this.implementsInterpretPluggable(pluggable)) {\n            this._interpretPluggables.push(pluggable);\n            pluggableAdded = true;\n        }\n        if (pluggableAdded) {\n            this.configurePluggable(pluggable);\n        }\n    };\n    /**\n     * Get the plugin object\n     * @param providerName - the name of the plugin\n     */\n    PredictionsClass.prototype.getPluggable = function (providerName) {\n        var pluggable = this.getAllProviders().find(function (pluggable) { return pluggable.getProviderName() === providerName; });\n        if (pluggable === undefined) {\n            logger.debug('No plugin found with providerName=>', providerName);\n            return null;\n        }\n        else\n            return pluggable;\n    };\n    /**\n     * Remove the plugin object\n     * @param providerName - the name of the plugin\n     */\n    PredictionsClass.prototype.removePluggable = function (providerName) {\n        this._convertPluggables = this._convertPluggables.filter(function (pluggable) { return pluggable.getProviderName() !== providerName; });\n        this._identifyPluggables = this._identifyPluggables.filter(function (pluggable) { return pluggable.getProviderName() !== providerName; });\n        this._interpretPluggables = this._interpretPluggables.filter(function (pluggable) { return pluggable.getProviderName() !== providerName; });\n        return;\n    };\n    /**\n     * To make both top level providers and category level providers work with same interface and configuration\n     * this method duplicates Predictions config into parent level config (for top level provider) and\n     * category level config (such as convert, identify etc) and pass both to each provider.\n     */\n    PredictionsClass.prototype.configure = function (options) {\n        var _this = this;\n        var predictionsConfig = options ? options.predictions || options : {};\n        predictionsConfig = __assign(__assign({}, predictionsConfig), options);\n        this._options = Object.assign({}, this._options, predictionsConfig);\n        logger.debug('configure Predictions', this._options);\n        this.getAllProviders().forEach(function (pluggable) {\n            return _this.configurePluggable(pluggable);\n        });\n    };\n    PredictionsClass.prototype.interpret = function (input, options) {\n        var pluggableToExecute = this.getPluggableToExecute(this._interpretPluggables, options);\n        return pluggableToExecute.interpret(input);\n    };\n    PredictionsClass.prototype.convert = function (input, options) {\n        var pluggableToExecute = this.getPluggableToExecute(this._convertPluggables, options);\n        return pluggableToExecute.convert(input);\n    };\n    PredictionsClass.prototype.identify = function (input, options) {\n        var pluggableToExecute = this.getPluggableToExecute(this._identifyPluggables, options);\n        return pluggableToExecute.identify(input);\n    };\n    // tslint:disable-next-line: max-line-length\n    PredictionsClass.prototype.getPluggableToExecute = function (pluggables, providerOptions) {\n        // Give preference to provider name first since it is more specific to this call, even if\n        // there is only one provider configured to error out if the name provided is not the one matched.\n        if (providerOptions && providerOptions.providerName) {\n            return __spread(pluggables).find(function (pluggable) {\n                return pluggable.getProviderName() === providerOptions.providerName;\n            });\n        }\n        else {\n            if (pluggables.length === 1) {\n                return pluggables[0];\n            }\n            else {\n                throw new Error('More than one or no providers are configured, ' +\n                    'Either specify a provider name or configure exactly one provider');\n            }\n        }\n    };\n    PredictionsClass.prototype.getAllProviders = function () {\n        return __spread(this._convertPluggables, this._identifyPluggables, this._interpretPluggables);\n    };\n    PredictionsClass.prototype.configurePluggable = function (pluggable) {\n        var categoryConfig = Object.assign({}, this._options['predictions'], // Parent predictions config for the top level provider\n        this._options[pluggable.getCategory().toLowerCase()] // Actual category level config\n        );\n        pluggable.configure(categoryConfig);\n    };\n    PredictionsClass.prototype.implementsConvertPluggable = function (obj) {\n        return obj && typeof obj.convert === 'function';\n    };\n    PredictionsClass.prototype.implementsIdentifyPluggable = function (obj) {\n        return obj && typeof obj.identify === 'function';\n    };\n    PredictionsClass.prototype.implementsInterpretPluggable = function (obj) {\n        return obj && typeof obj.interpret === 'function';\n    };\n    return PredictionsClass;\n}());\nexport { PredictionsClass };\nexport var Predictions = new PredictionsClass({});\nAmplify.register(Predictions);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}