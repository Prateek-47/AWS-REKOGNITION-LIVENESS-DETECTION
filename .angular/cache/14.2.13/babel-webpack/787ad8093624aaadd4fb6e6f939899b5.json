{"ast":null,"code":"/**\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\n */\nimport { closest } from './closest';\nimport { matches } from './matches';\n/**\n * Delegates the handling of events for an element matching a selector to an\n * ancestor of the matching element.\n * @param {!Node} ancestor The ancestor element to add the listener to.\n * @param {string} eventType The event type to listen to.\n * @param {string} selector A CSS selector to match against child elements.\n * @param {!Function} callback A function to run any time the event happens.\n * @param {Object=} opts A configuration options object. The available options:\n *     - useCapture<boolean>: If true, bind to the event capture phase.\n *     - deep<boolean>: If true, delegate into shadow trees.\n * @return {Object} The delegate object. It contains a destroy method.\n */\n\nexport function delegate(ancestor, eventType, selector, callback, opts) {\n  if (opts === void 0) {\n    opts = {};\n  } // Defines the event listener.\n\n\n  var listener = function (event) {\n    var delegateTarget; // If opts.composed is true and the event originated from inside a Shadow\n    // tree, check the composed path nodes.\n\n    if (opts['composed'] && typeof event['composedPath'] === 'function') {\n      var composedPath = event.composedPath();\n\n      for (var i = 0, node = void 0; node = composedPath[i]; i++) {\n        if (node.nodeType === 1 && matches(node, selector)) {\n          delegateTarget = node;\n        }\n      }\n    } else {\n      // Otherwise check the parents.\n      delegateTarget = closest(event.target, selector, true);\n    }\n\n    if (delegateTarget) {\n      callback.call(delegateTarget, event, delegateTarget);\n    }\n  };\n\n  ancestor.addEventListener(eventType, listener, opts['useCapture']);\n  return {\n    destroy: function () {\n      ancestor.removeEventListener(eventType, listener, opts['useCapture']);\n    }\n  };\n}","map":{"version":3,"names":["closest","matches","delegate","ancestor","eventType","selector","callback","opts","listener","event","delegateTarget","composedPath","i","node","nodeType","target","call","addEventListener","destroy","removeEventListener"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-amplify/analytics/lib-esm/vendor/dom-utils/delegate.js"],"sourcesContent":["/**\n * Copyright (c) 2017, Philip Walton <philip@philipwalton.com>\n */\nimport { closest } from './closest';\nimport { matches } from './matches';\n/**\n * Delegates the handling of events for an element matching a selector to an\n * ancestor of the matching element.\n * @param {!Node} ancestor The ancestor element to add the listener to.\n * @param {string} eventType The event type to listen to.\n * @param {string} selector A CSS selector to match against child elements.\n * @param {!Function} callback A function to run any time the event happens.\n * @param {Object=} opts A configuration options object. The available options:\n *     - useCapture<boolean>: If true, bind to the event capture phase.\n *     - deep<boolean>: If true, delegate into shadow trees.\n * @return {Object} The delegate object. It contains a destroy method.\n */\nexport function delegate(ancestor, eventType, selector, callback, opts) {\n    if (opts === void 0) { opts = {}; }\n    // Defines the event listener.\n    var listener = function (event) {\n        var delegateTarget;\n        // If opts.composed is true and the event originated from inside a Shadow\n        // tree, check the composed path nodes.\n        if (opts['composed'] && typeof event['composedPath'] === 'function') {\n            var composedPath = event.composedPath();\n            for (var i = 0, node = void 0; (node = composedPath[i]); i++) {\n                if (node.nodeType === 1 && matches(node, selector)) {\n                    delegateTarget = node;\n                }\n            }\n        }\n        else {\n            // Otherwise check the parents.\n            delegateTarget = closest(event.target, selector, true);\n        }\n        if (delegateTarget) {\n            callback.call(delegateTarget, event, delegateTarget);\n        }\n    };\n    ancestor.addEventListener(eventType, listener, opts['useCapture']);\n    return {\n        destroy: function () {\n            ancestor.removeEventListener(eventType, listener, opts['useCapture']);\n        },\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,OAAT,QAAwB,WAAxB;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,SAA5B,EAAuCC,QAAvC,EAAiDC,QAAjD,EAA2DC,IAA3D,EAAiE;EACpE,IAAIA,IAAI,KAAK,KAAK,CAAlB,EAAqB;IAAEA,IAAI,GAAG,EAAP;EAAY,CADiC,CAEpE;;;EACA,IAAIC,QAAQ,GAAG,UAAUC,KAAV,EAAiB;IAC5B,IAAIC,cAAJ,CAD4B,CAE5B;IACA;;IACA,IAAIH,IAAI,CAAC,UAAD,CAAJ,IAAoB,OAAOE,KAAK,CAAC,cAAD,CAAZ,KAAiC,UAAzD,EAAqE;MACjE,IAAIE,YAAY,GAAGF,KAAK,CAACE,YAAN,EAAnB;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,KAAK,CAA5B,EAAgCA,IAAI,GAAGF,YAAY,CAACC,CAAD,CAAnD,EAAyDA,CAAC,EAA1D,EAA8D;QAC1D,IAAIC,IAAI,CAACC,QAAL,KAAkB,CAAlB,IAAuBb,OAAO,CAACY,IAAD,EAAOR,QAAP,CAAlC,EAAoD;UAChDK,cAAc,GAAGG,IAAjB;QACH;MACJ;IACJ,CAPD,MAQK;MACD;MACAH,cAAc,GAAGV,OAAO,CAACS,KAAK,CAACM,MAAP,EAAeV,QAAf,EAAyB,IAAzB,CAAxB;IACH;;IACD,IAAIK,cAAJ,EAAoB;MAChBJ,QAAQ,CAACU,IAAT,CAAcN,cAAd,EAA8BD,KAA9B,EAAqCC,cAArC;IACH;EACJ,CAnBD;;EAoBAP,QAAQ,CAACc,gBAAT,CAA0Bb,SAA1B,EAAqCI,QAArC,EAA+CD,IAAI,CAAC,YAAD,CAAnD;EACA,OAAO;IACHW,OAAO,EAAE,YAAY;MACjBf,QAAQ,CAACgB,mBAAT,CAA6Bf,SAA7B,EAAwCI,QAAxC,EAAkDD,IAAI,CAAC,YAAD,CAAtD;IACH;EAHE,CAAP;AAKH"},"metadata":{},"sourceType":"module"}