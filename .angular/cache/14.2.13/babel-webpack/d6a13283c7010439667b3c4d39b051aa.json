{"ast":null,"code":"import _asyncToGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _awaitAsyncGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { iterableToReadableStream, readableStreamtoIterable } from \"@aws-sdk/eventstream-serde-browser\";\nimport { FetchHttpHandler } from \"@aws-sdk/fetch-http-handler\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { formatUrl } from \"@aws-sdk/util-format-url\";\nimport { isWebSocketRequest } from \"./utils\";\nconst DEFAULT_WS_CONNECTION_TIMEOUT_MS = 2000;\nexport class WebSocketFetchHandler {\n  constructor(options, httpHandler = new FetchHttpHandler()) {\n    this.metadata = {\n      handlerProtocol: \"websocket/h1.1\"\n    };\n    this.sockets = {};\n    this.httpHandler = httpHandler;\n\n    if (typeof options === \"function\") {\n      this.configPromise = options().then(opts => opts ?? {});\n    } else {\n      this.configPromise = Promise.resolve(options ?? {});\n    }\n  }\n\n  destroy() {\n    for (const [key, sockets] of Object.entries(this.sockets)) {\n      for (const socket of sockets) {\n        socket.close(1000, `Socket closed through destroy() call`);\n      }\n\n      delete this.sockets[key];\n    }\n  }\n\n  handle(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!isWebSocketRequest(request)) {\n        return _this.httpHandler.handle(request);\n      }\n\n      const url = formatUrl(request);\n      const socket = new WebSocket(url);\n\n      if (!_this.sockets[url]) {\n        _this.sockets[url] = [];\n      }\n\n      _this.sockets[url].push(socket);\n\n      socket.binaryType = \"arraybuffer\";\n      const {\n        connectionTimeout = DEFAULT_WS_CONNECTION_TIMEOUT_MS\n      } = yield _this.configPromise;\n      yield _this.waitForReady(socket, connectionTimeout);\n      const {\n        body\n      } = request;\n      const bodyStream = getIterator(body);\n\n      const asyncIterable = _this.connect(socket, bodyStream);\n\n      const outputPayload = toReadableStream(asyncIterable);\n      return {\n        response: new HttpResponse({\n          statusCode: 200,\n          body: outputPayload\n        })\n      };\n    })();\n  }\n\n  removeNotUsableSockets(url) {\n    this.sockets[url] = (this.sockets[url] ?? []).filter(socket => ![WebSocket.CLOSING, WebSocket.CLOSED].includes(socket.readyState));\n  }\n\n  waitForReady(socket, connectionTimeout) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        this.removeNotUsableSockets(socket.url);\n        reject({\n          $metadata: {\n            httpStatusCode: 500\n          }\n        });\n      }, connectionTimeout);\n\n      socket.onopen = () => {\n        clearTimeout(timeout);\n        resolve();\n      };\n    });\n  }\n\n  connect(socket, data) {\n    let streamError = undefined;\n    let socketErrorOccurred = false;\n\n    let reject = () => {};\n\n    let resolve = () => {};\n\n    socket.onmessage = event => {\n      resolve({\n        done: false,\n        value: new Uint8Array(event.data)\n      });\n    };\n\n    socket.onerror = error => {\n      socketErrorOccurred = true;\n      socket.close();\n      reject(error);\n    };\n\n    socket.onclose = () => {\n      this.removeNotUsableSockets(socket.url);\n      if (socketErrorOccurred) return;\n\n      if (streamError) {\n        reject(streamError);\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    };\n\n    const outputStream = {\n      [Symbol.asyncIterator]: () => ({\n        next: () => {\n          return new Promise((_resolve, _reject) => {\n            resolve = _resolve;\n            reject = _reject;\n          });\n        }\n      })\n    };\n\n    const send = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        try {\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n\n          var _iteratorError;\n\n          try {\n            for (var _iterator = _asyncIterator(data), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n              const inputChunk = _step.value;\n              socket.send(inputChunk);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                yield _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        } catch (err) {\n          streamError = err;\n        } finally {\n          socket.close(1000);\n        }\n      });\n\n      return function send() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    send();\n    return outputStream;\n  }\n\n}\n\nconst getIterator = stream => {\n  if (stream[Symbol.asyncIterator]) {\n    return stream;\n  }\n\n  if (isReadableStream(stream)) {\n    return readableStreamtoIterable(stream);\n  }\n\n  return {\n    [Symbol.asyncIterator]: _wrapAsyncGenerator(function* () {\n      yield stream;\n    })\n  };\n};\n\nconst toReadableStream = asyncIterable => typeof ReadableStream === \"function\" ? iterableToReadableStream(asyncIterable) : asyncIterable;\n\nconst isReadableStream = payload => typeof ReadableStream === \"function\" && payload instanceof ReadableStream;","map":{"version":3,"names":["iterableToReadableStream","readableStreamtoIterable","FetchHttpHandler","HttpResponse","formatUrl","isWebSocketRequest","DEFAULT_WS_CONNECTION_TIMEOUT_MS","WebSocketFetchHandler","constructor","options","httpHandler","metadata","handlerProtocol","sockets","configPromise","then","opts","Promise","resolve","destroy","key","Object","entries","socket","close","handle","request","url","WebSocket","push","binaryType","connectionTimeout","waitForReady","body","bodyStream","getIterator","asyncIterable","connect","outputPayload","toReadableStream","response","statusCode","removeNotUsableSockets","filter","CLOSING","CLOSED","includes","readyState","reject","timeout","setTimeout","$metadata","httpStatusCode","onopen","clearTimeout","data","streamError","undefined","socketErrorOccurred","onmessage","event","done","value","Uint8Array","onerror","error","onclose","outputStream","Symbol","asyncIterator","next","_resolve","_reject","send","inputChunk","err","stream","isReadableStream","ReadableStream","payload"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/middleware-websocket/dist-es/websocket-fetch-handler.js"],"sourcesContent":["import { iterableToReadableStream, readableStreamtoIterable } from \"@aws-sdk/eventstream-serde-browser\";\nimport { FetchHttpHandler } from \"@aws-sdk/fetch-http-handler\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { formatUrl } from \"@aws-sdk/util-format-url\";\nimport { isWebSocketRequest } from \"./utils\";\nconst DEFAULT_WS_CONNECTION_TIMEOUT_MS = 2000;\nexport class WebSocketFetchHandler {\n    constructor(options, httpHandler = new FetchHttpHandler()) {\n        this.metadata = {\n            handlerProtocol: \"websocket/h1.1\",\n        };\n        this.sockets = {};\n        this.httpHandler = httpHandler;\n        if (typeof options === \"function\") {\n            this.configPromise = options().then((opts) => opts ?? {});\n        }\n        else {\n            this.configPromise = Promise.resolve(options ?? {});\n        }\n    }\n    destroy() {\n        for (const [key, sockets] of Object.entries(this.sockets)) {\n            for (const socket of sockets) {\n                socket.close(1000, `Socket closed through destroy() call`);\n            }\n            delete this.sockets[key];\n        }\n    }\n    async handle(request) {\n        if (!isWebSocketRequest(request)) {\n            return this.httpHandler.handle(request);\n        }\n        const url = formatUrl(request);\n        const socket = new WebSocket(url);\n        if (!this.sockets[url]) {\n            this.sockets[url] = [];\n        }\n        this.sockets[url].push(socket);\n        socket.binaryType = \"arraybuffer\";\n        const { connectionTimeout = DEFAULT_WS_CONNECTION_TIMEOUT_MS } = await this.configPromise;\n        await this.waitForReady(socket, connectionTimeout);\n        const { body } = request;\n        const bodyStream = getIterator(body);\n        const asyncIterable = this.connect(socket, bodyStream);\n        const outputPayload = toReadableStream(asyncIterable);\n        return {\n            response: new HttpResponse({\n                statusCode: 200,\n                body: outputPayload,\n            }),\n        };\n    }\n    removeNotUsableSockets(url) {\n        this.sockets[url] = (this.sockets[url] ?? []).filter((socket) => ![WebSocket.CLOSING, WebSocket.CLOSED].includes(socket.readyState));\n    }\n    waitForReady(socket, connectionTimeout) {\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this.removeNotUsableSockets(socket.url);\n                reject({\n                    $metadata: {\n                        httpStatusCode: 500,\n                    },\n                });\n            }, connectionTimeout);\n            socket.onopen = () => {\n                clearTimeout(timeout);\n                resolve();\n            };\n        });\n    }\n    connect(socket, data) {\n        let streamError = undefined;\n        let socketErrorOccurred = false;\n        let reject = () => { };\n        let resolve = () => { };\n        socket.onmessage = (event) => {\n            resolve({\n                done: false,\n                value: new Uint8Array(event.data),\n            });\n        };\n        socket.onerror = (error) => {\n            socketErrorOccurred = true;\n            socket.close();\n            reject(error);\n        };\n        socket.onclose = () => {\n            this.removeNotUsableSockets(socket.url);\n            if (socketErrorOccurred)\n                return;\n            if (streamError) {\n                reject(streamError);\n            }\n            else {\n                resolve({\n                    done: true,\n                    value: undefined,\n                });\n            }\n        };\n        const outputStream = {\n            [Symbol.asyncIterator]: () => ({\n                next: () => {\n                    return new Promise((_resolve, _reject) => {\n                        resolve = _resolve;\n                        reject = _reject;\n                    });\n                },\n            }),\n        };\n        const send = async () => {\n            try {\n                for await (const inputChunk of data) {\n                    socket.send(inputChunk);\n                }\n            }\n            catch (err) {\n                streamError = err;\n            }\n            finally {\n                socket.close(1000);\n            }\n        };\n        send();\n        return outputStream;\n    }\n}\nconst getIterator = (stream) => {\n    if (stream[Symbol.asyncIterator]) {\n        return stream;\n    }\n    if (isReadableStream(stream)) {\n        return readableStreamtoIterable(stream);\n    }\n    return {\n        [Symbol.asyncIterator]: async function* () {\n            yield stream;\n        },\n    };\n};\nconst toReadableStream = (asyncIterable) => typeof ReadableStream === \"function\" ? iterableToReadableStream(asyncIterable) : asyncIterable;\nconst isReadableStream = (payload) => typeof ReadableStream === \"function\" && payload instanceof ReadableStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}