{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { zeros } from '../utils/zeros_impl';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { real } from './Real';\nexport function cast(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x\n  } = inputs;\n  const {\n    dtype\n  } = attrs; // Casting to complex64.\n\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({\n        inputs: {\n          x\n        },\n        backend\n      });\n    }\n\n    const zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n    const floatX = cast({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    const result = complex({\n      inputs: {\n        real: floatX,\n        imag: zerosTensorInfo\n      },\n      backend\n    });\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    backend.disposeIntermediateTensorInfo(floatX);\n    return result;\n  } // Casting from complex64\n\n\n  if (x.dtype === 'complex64') {\n    const realPart = real({\n      inputs: {\n        input: x\n      },\n      backend\n    });\n    const result = cast({\n      inputs: {\n        x: realPart\n      },\n      backend,\n      attrs: {\n        dtype\n      }\n    });\n    backend.disposeIntermediateTensorInfo(realPart);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({\n      inputs: {\n        x\n      },\n      backend\n    });\n    return {\n      dataId: result.dataId,\n      shape: result.shape,\n      dtype\n    };\n  }\n\n  if (dtype === 'int32') {\n    const values = backend.data.get(x.dataId).values;\n    const resultValues = Int32Array.from(values);\n    return backend.makeTensorInfo(x.shape, 'int32', resultValues);\n  }\n\n  if (dtype === 'bool') {\n    // This is essentially the result of notEqual(x, 0). We avoid using\n    // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n    // cast -> notEqual -> binary_utils.\n    const xVals = backend.data.get(x.dataId).values;\n    const zero = util.toTypedArray([0], x.dtype);\n    const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(x.shape, [], xVals, zero, 'bool');\n    return backend.makeTensorInfo(resultShape, 'bool', resultData);\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n  kernelName: Cast,\n  backendName: 'cpu',\n  kernelFunc: cast\n};","map":{"version":3,"names":["Cast","util","createSimpleBinaryKernelImpl","zeros","complex","identity","real","cast","args","inputs","backend","attrs","x","dtype","zerosTensorInfo","shape","floatX","result","imag","disposeIntermediateTensorInfo","realPart","input","hasEncodingLoss","dataId","values","data","get","resultValues","Int32Array","from","makeTensorInfo","xVals","zero","toTypedArray","resultData","resultShape","a","b","Error","castConfig","kernelName","backendName","kernelFunc"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Cast, util } from '@tensorflow/tfjs-core';\nimport { createSimpleBinaryKernelImpl } from '../utils/binary_impl';\nimport { zeros } from '../utils/zeros_impl';\nimport { complex } from './Complex';\nimport { identity } from './Identity';\nimport { real } from './Real';\nexport function cast(args) {\n    const { inputs, backend, attrs } = args;\n    const { x } = inputs;\n    const { dtype } = attrs;\n    // Casting to complex64.\n    if (dtype === 'complex64') {\n        if (x.dtype === 'complex64') {\n            return identity({ inputs: { x }, backend });\n        }\n        const zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n        const floatX = cast({ inputs: { x }, backend, attrs: { dtype: 'float32' } });\n        const result = complex({ inputs: { real: floatX, imag: zerosTensorInfo }, backend });\n        backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n        backend.disposeIntermediateTensorInfo(floatX);\n        return result;\n    }\n    // Casting from complex64\n    if (x.dtype === 'complex64') {\n        const realPart = real({ inputs: { input: x }, backend });\n        const result = cast({ inputs: { x: realPart }, backend, attrs: { dtype } });\n        backend.disposeIntermediateTensorInfo(realPart);\n        return result;\n    }\n    if (!util.hasEncodingLoss(x.dtype, dtype)) {\n        // We don't change the underlying data, since we cast to higher\n        // precision.\n        const result = identity({ inputs: { x }, backend });\n        return { dataId: result.dataId, shape: result.shape, dtype };\n    }\n    if (dtype === 'int32') {\n        const values = backend.data.get(x.dataId).values;\n        const resultValues = Int32Array.from(values);\n        return backend.makeTensorInfo(x.shape, 'int32', resultValues);\n    }\n    if (dtype === 'bool') {\n        // This is essentially the result of notEqual(x, 0). We avoid using\n        // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n        // cast -> notEqual -> binary_utils.\n        const xVals = backend.data.get(x.dataId).values;\n        const zero = util.toTypedArray([0], x.dtype);\n        const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => (a !== b) ? 1 : 0)(x.shape, [], xVals, zero, 'bool');\n        return backend.makeTensorInfo(resultShape, 'bool', resultData);\n    }\n    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\nexport const castConfig = {\n    kernelName: Cast,\n    backendName: 'cpu',\n    kernelFunc: cast\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}