{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\n\nvar exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {\n  if (attempt > attemptCeiling) return maxDelay;\n  var delay = minDelay * Math.pow(2, attempt - 1);\n  return randomInRange(minDelay, delay);\n};\n\nvar randomInRange = function (min, max) {\n  return min + Math.random() * (max - min);\n};\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\n\n\nexport var runPolling = function (_a, input, acceptorChecks) {\n  var minDelay = _a.minDelay,\n      maxDelay = _a.maxDelay,\n      maxWaitTime = _a.maxWaitTime,\n      abortController = _a.abortController,\n      client = _a.client;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;\n\n    var _b;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , acceptorChecks(client, input)];\n\n        case 1:\n          state = _c.sent().state;\n\n          if (state !== WaiterState.RETRY) {\n            return [2\n            /*return*/\n            , {\n              state: state\n            }];\n          }\n\n          currentAttempt = 1;\n          waitUntil = Date.now() + maxWaitTime * 1000;\n          attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n          _c.label = 2;\n\n        case 2:\n          if (!true) return [3\n          /*break*/\n          , 5];\n\n          if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n            return [2\n            /*return*/\n            , {\n              state: WaiterState.ABORTED\n            }];\n          }\n\n          delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt); // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n          // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n\n          if (Date.now() + delay * 1000 > waitUntil) {\n            return [2\n            /*return*/\n            , {\n              state: WaiterState.TIMEOUT\n            }];\n          }\n\n          return [4\n          /*yield*/\n          , sleep(delay)];\n\n        case 3:\n          _c.sent();\n\n          return [4\n          /*yield*/\n          , acceptorChecks(client, input)];\n\n        case 4:\n          state_1 = _c.sent().state;\n\n          if (state_1 !== WaiterState.RETRY) {\n            return [2\n            /*return*/\n            , {\n              state: state_1\n            }];\n          }\n\n          currentAttempt += 1;\n          return [3\n          /*break*/\n          , 2];\n\n        case 5:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};","map":{"version":3,"names":["__awaiter","__generator","sleep","WaiterState","exponentialBackoffWithJitter","minDelay","maxDelay","attemptCeiling","attempt","delay","Math","pow","randomInRange","min","max","random","runPolling","_a","input","acceptorChecks","maxWaitTime","abortController","client","state","currentAttempt","waitUntil","state_1","_b","_c","label","sent","RETRY","Date","now","log","signal","aborted","ABORTED","TIMEOUT"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/util-waiter/dist/es/poller.js"],"sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\nvar exponentialBackoffWithJitter = function (minDelay, maxDelay, attemptCeiling, attempt) {\n    if (attempt > attemptCeiling)\n        return maxDelay;\n    var delay = minDelay * Math.pow(2, (attempt - 1));\n    return randomInRange(minDelay, delay);\n};\nvar randomInRange = function (min, max) { return min + Math.random() * (max - min); };\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\nexport var runPolling = function (_a, input, acceptorChecks) {\n    var minDelay = _a.minDelay, maxDelay = _a.maxDelay, maxWaitTime = _a.maxWaitTime, abortController = _a.abortController, client = _a.client;\n    return __awaiter(void 0, void 0, void 0, function () {\n        var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;\n        var _b;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0: return [4 /*yield*/, acceptorChecks(client, input)];\n                case 1:\n                    state = (_c.sent()).state;\n                    if (state !== WaiterState.RETRY) {\n                        return [2 /*return*/, { state: state }];\n                    }\n                    currentAttempt = 1;\n                    waitUntil = Date.now() + maxWaitTime * 1000;\n                    attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n                    _c.label = 2;\n                case 2:\n                    if (!true) return [3 /*break*/, 5];\n                    if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n                        return [2 /*return*/, { state: WaiterState.ABORTED }];\n                    }\n                    delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n                    // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n                    // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n                    if (Date.now() + delay * 1000 > waitUntil) {\n                        return [2 /*return*/, { state: WaiterState.TIMEOUT }];\n                    }\n                    return [4 /*yield*/, sleep(delay)];\n                case 3:\n                    _c.sent();\n                    return [4 /*yield*/, acceptorChecks(client, input)];\n                case 4:\n                    state_1 = (_c.sent()).state;\n                    if (state_1 !== WaiterState.RETRY) {\n                        return [2 /*return*/, { state: state_1 }];\n                    }\n                    currentAttempt += 1;\n                    return [3 /*break*/, 2];\n                case 5: return [2 /*return*/];\n            }\n        });\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}