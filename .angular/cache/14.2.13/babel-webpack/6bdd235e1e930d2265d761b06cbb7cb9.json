{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n  const {\n    inputs: {\n      x\n    },\n    attrs: {\n      begin,\n      size\n    },\n    backend\n  } = args;\n  const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n  const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  const xVals = backend.readSync(x.dataId);\n  const out = backend.makeOutput(size_, x.dtype);\n  const xStrides = util.computeStrides(x.shape);\n  const outData = backend.dataIdMap.get(out.dataId);\n\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n\n    if (x.dtype === 'string') {\n      outData.stringBytes = xVals.slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      const outVals = backend.typedArrayFromHeap(out);\n      outVals.set(xVals.subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n\n    return out;\n  }\n\n  if (x.dtype === 'string') {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res;\n    return out;\n  }\n\n  const outVals = backend.typedArrayFromHeap(out);\n  const rank = x.shape.length;\n\n  if (rank === 2) {\n    slice2d(xVals, xStrides[0], outVals, begin_, size_);\n  } else if (rank === 3) {\n    slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n  } else if (rank === 4) {\n    slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n  } else {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outVals.set(res);\n  }\n\n  return out;\n}\n\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const endI = beginI + size[0];\n\n  for (let i = beginI; i < endI; i++) {\n    const xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\n\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      const xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\n\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  const endK = beginK + size[2];\n  const beginL = begin[3];\n\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      for (let k = beginK; k < endK; k++) {\n        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\n\nexport const sliceConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice\n};","map":{"version":3,"names":["Slice","slice_util","util","sliceImplCPU","slice","args","inputs","x","attrs","begin","size","backend","begin_","size_","parseSliceParams","isContinous","isSliceContinous","shape","xVals","readSync","dataId","out","makeOutput","dtype","xStrides","computeStrides","outData","dataIdMap","get","flatOffset","computeFlatOffset","stringBytes","sizeFromShape","outVals","typedArrayFromHeap","set","subarray","res","rank","length","slice2d","slice3d","slice4d","xStride","outOffset","beginI","beginJ","endI","i","xOffset","xStride1","xStride2","beginK","endJ","j","xStride3","endK","beginL","k","sliceConfig","kernelName","backendName","kernelFunc"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@tensorflow/tfjs-backend-wasm/dist/kernels/Slice.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n    const { inputs: { x }, attrs: { begin, size }, backend } = args;\n    const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n    const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n    const xVals = backend.readSync(x.dataId);\n    const out = backend.makeOutput(size_, x.dtype);\n    const xStrides = util.computeStrides(x.shape);\n    const outData = backend.dataIdMap.get(out.dataId);\n    if (isContinous) {\n        const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n        if (x.dtype === 'string') {\n            outData.stringBytes =\n                xVals\n                    .slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n        }\n        else {\n            const outVals = backend.typedArrayFromHeap(out);\n            outVals.set(xVals\n                .subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n        }\n        return out;\n    }\n    if (x.dtype === 'string') {\n        const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n        outData.stringBytes = res;\n        return out;\n    }\n    const outVals = backend.typedArrayFromHeap(out);\n    const rank = x.shape.length;\n    if (rank === 2) {\n        slice2d(xVals, xStrides[0], outVals, begin_, size_);\n    }\n    else if (rank === 3) {\n        slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n    }\n    else if (rank === 4) {\n        slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n    }\n    else {\n        const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n        outVals.set(res);\n    }\n    return out;\n}\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const endI = beginI + size[0];\n    for (let i = beginI; i < endI; i++) {\n        const xOffset = i * xStride + beginJ;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n        outOffset += size[1];\n    }\n}\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const beginK = begin[2];\n    const endI = beginI + size[0];\n    const endJ = beginJ + size[1];\n    for (let i = beginI; i < endI; i++) {\n        for (let j = beginJ; j < endJ; j++) {\n            const xOffset = i * xStride1 + j * xStride2 + beginK;\n            outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n            outOffset += size[2];\n        }\n    }\n}\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n    let outOffset = 0;\n    const beginI = begin[0];\n    const beginJ = begin[1];\n    const beginK = begin[2];\n    const endI = beginI + size[0];\n    const endJ = beginJ + size[1];\n    const endK = beginK + size[2];\n    const beginL = begin[3];\n    for (let i = beginI; i < endI; i++) {\n        for (let j = beginJ; j < endJ; j++) {\n            for (let k = beginK; k < endK; k++) {\n                const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n                outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n                outOffset += size[3];\n            }\n        }\n    }\n}\nexport const sliceConfig = {\n    kernelName: Slice,\n    backendName: 'wasm',\n    kernelFunc: slice,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}