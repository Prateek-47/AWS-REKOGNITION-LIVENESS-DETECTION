{"ast":null,"code":"import _awaitAsyncGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"D:/aws-rekognition-liveness-detection-main/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nexport function getChunkedStream(source) {\n  let currentMessageTotalLength = 0;\n  let currentMessagePendingLength = 0;\n  let currentMessage = null;\n  let messageLengthBuffer = null;\n\n  const allocateMessage = size => {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    const currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false);\n  };\n\n  const iterator = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* () {\n      const sourceIterator = source[Symbol.asyncIterator]();\n\n      while (true) {\n        const {\n          value,\n          done\n        } = yield _awaitAsyncGenerator(sourceIterator.next());\n\n        if (done) {\n          if (!currentMessageTotalLength) {\n            return;\n          } else if (currentMessageTotalLength === currentMessagePendingLength) {\n            yield currentMessage;\n          } else {\n            throw new Error(\"Truncated event message received.\");\n          }\n\n          return;\n        }\n\n        const chunkLength = value.length;\n        let currentOffset = 0;\n\n        while (currentOffset < chunkLength) {\n          if (!currentMessage) {\n            const bytesRemaining = chunkLength - currentOffset;\n\n            if (!messageLengthBuffer) {\n              messageLengthBuffer = new Uint8Array(4);\n            }\n\n            const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesForTotal;\n            currentOffset += numBytesForTotal;\n\n            if (currentMessagePendingLength < 4) {\n              break;\n            }\n\n            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n            messageLengthBuffer = null;\n          }\n\n          const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n          currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n          currentMessagePendingLength += numBytesToWrite;\n          currentOffset += numBytesToWrite;\n\n          if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n            yield currentMessage;\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n          }\n        }\n      }\n    });\n\n    return function iterator() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    [Symbol.asyncIterator]: iterator\n  };\n}","map":{"version":3,"names":["getChunkedStream","source","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","allocateMessage","size","Error","Uint8Array","currentMessageView","DataView","buffer","setUint32","iterator","sourceIterator","Symbol","asyncIterator","value","done","next","chunkLength","length","currentOffset","bytesRemaining","numBytesForTotal","Math","min","set","slice","getUint32","numBytesToWrite"],"sources":["D:/aws-rekognition-liveness-detection-main/node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getChunkedStream.js"],"sourcesContent":["export function getChunkedStream(source) {\n    let currentMessageTotalLength = 0;\n    let currentMessagePendingLength = 0;\n    let currentMessage = null;\n    let messageLengthBuffer = null;\n    const allocateMessage = (size) => {\n        if (typeof size !== \"number\") {\n            throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n        }\n        currentMessageTotalLength = size;\n        currentMessagePendingLength = 4;\n        currentMessage = new Uint8Array(size);\n        const currentMessageView = new DataView(currentMessage.buffer);\n        currentMessageView.setUint32(0, size, false);\n    };\n    const iterator = async function* () {\n        const sourceIterator = source[Symbol.asyncIterator]();\n        while (true) {\n            const { value, done } = await sourceIterator.next();\n            if (done) {\n                if (!currentMessageTotalLength) {\n                    return;\n                }\n                else if (currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                }\n                else {\n                    throw new Error(\"Truncated event message received.\");\n                }\n                return;\n            }\n            const chunkLength = value.length;\n            let currentOffset = 0;\n            while (currentOffset < chunkLength) {\n                if (!currentMessage) {\n                    const bytesRemaining = chunkLength - currentOffset;\n                    if (!messageLengthBuffer) {\n                        messageLengthBuffer = new Uint8Array(4);\n                    }\n                    const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n                    messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n                    currentMessagePendingLength += numBytesForTotal;\n                    currentOffset += numBytesForTotal;\n                    if (currentMessagePendingLength < 4) {\n                        break;\n                    }\n                    allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n                    messageLengthBuffer = null;\n                }\n                const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n                currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n                currentMessagePendingLength += numBytesToWrite;\n                currentOffset += numBytesToWrite;\n                if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                    currentMessage = null;\n                    currentMessageTotalLength = 0;\n                    currentMessagePendingLength = 0;\n                }\n            }\n        }\n    };\n    return {\n        [Symbol.asyncIterator]: iterator,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}